*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="thor_proc_sidekick.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS msg AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: centerwindow
		*m: showmsg
		*m: timerproc
		*m: wndproc
		*p: hwnd		&& Specifies the Window handle of the Window.
		*p: hwnd_msgbox
		*p: lchangebutton
		*p: ltimeout
		*p: ltransparent
		*p: ntimeout
		*p: ntransvalue
		*p: porgproc
		*a: abuttons[3,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		Height = 105
		hwnd = 0
		hwnd_msgbox = 0
		lchangebutton = .F.
		ltimeout = .F.
		ltransparent = .F.
		Name = "msg"
		ntimeout = 0
		ntransvalue = 0
		porgproc = 0
		Width = 306
		_memberdata = <VFPData>
			<memberdata name="hwnd" display="hWnd"/>
			<memberdata name="hwnd_msgbox" display="hWnd_MsgBox"/>
			<memberdata name="lchangebutton" display="lChangeButton"/>
			<memberdata name="ltransparent" display="lTransparent"/>
			<memberdata name="ntimeout" display="nTimeOut"/>
			<memberdata name="ltimeout" display="lTimeOut"/>
			<memberdata name="ntransvalue" display="nTransValue"/>
			<memberdata name="showmsg" display="ShowMsg"/>
			<memberdata name="centerwindow" display="CenterWindow"/>
			<memberdata name="wndproc" display="WndProc"/>
			<memberdata name="timerproc" display="TimerProc"/>
			<memberdata name="porgproc" display="pOrgProc"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE centerwindow
		Lparameters th_WndParent, th_WndChild
		Local ln_Bottom, ln_Height, ln_Left, ln_Right, ln_TargetLeft, ln_TargetTop, ln_Top, ln_Width
		Local ls_Rect
		
		ls_Rect = Space( 16 )
		** Get container area (parent)
		GetWindowRect( m.th_WndParent, @m.ls_Rect )
		ln_TargetLeft = CToBin( Substr( m.ls_Rect, 1, 4 ), [4rs] )
		ln_TargetTop = CToBin( Substr( m.ls_Rect, 5, 4 ), [4rs] )
		ln_Right = CToBin( Substr( m.ls_Rect, 9, 4 ), [4rs] ) + 1
		ln_Bottom = CToBin( Substr( m.ls_Rect, 13, 4 ), [4rs] ) + 1
		ln_Width = m.ln_Right - m.ln_TargetLeft
		ln_Height = m.ln_Bottom - m.ln_TargetTop
		
		** Get contained area (child)
		GetWindowRect( m.th_WndChild, @m.ls_Rect )
		ln_Left = CToBin( Substr( m.ls_Rect, 1, 4 ), [4rs] )
		ln_Top = CToBin( Substr( m.ls_Rect, 5, 4 ), [4rs] )
		ln_Right = CToBin( Substr( m.ls_Rect, 9, 4 ), [4rs] ) + 1
		ln_Bottom = CToBin( Substr( m.ls_Rect, 13, 4 ), [4rs] ) + 1
		
		** Get Left & Top position (XY coordinate)
		ln_Left = ((m.ln_Width - (m.ln_Right - m.ln_Left)) / 2) + m.ln_TargetLeft
		ln_Top = (m.ln_Height - (m.ln_Bottom - m.ln_Top)) / 2 + m.ln_TargetTop
		SetWindowPos( m.th_WndChild, 0, m.ln_Left, m.ln_Top, 0, 0, Bitor( 0x1, 0x10, 0x400 ))
	ENDPROC

	PROCEDURE Destroy
		Clear Dlls
	ENDPROC

	PROCEDURE Init
		Declare Long SetLayeredWindowAttributes in User32 ;
		Long nhWnd, Long crKey, Short bAlpha, Long dwFlags
		
		Declare Long GetDesktopWindow in User32
		
		Declare Long GetWindowLong in User32 ;
		Long nhWnd, Integer nIndex
		
		Declare Long SetWindowLong in User32 ;
		Long nhWnd, Integer nIndex, Long dwNewLong
		
		Declare Long GetWindowRect in User32 ;
		Long nhWnd, String @O_lpRect
		
		Declare Long SetWindowPos in User32 ;
		Long nhWnd, Long hWndInsertAfter, ;
		Integer nX, Integer nY, Integer nWidth, Integer nHeight, Long nFlags
		
		Declare Long CallWindowProc in User32 ;
		Long lpPrevWndFunc, Long nhWnd, ;
		Long uMsg, Long wParam, Long lParam
		
		Declare Long FindWindowEx in User32 ;
		Long hWndParent, Long hWndChildAfter, ;
		String lpszClass, String lpszWindow
		
		Declare Long SendMessage in User32 as SendMessageStr ;
		Long nhWnd, Long uMsg, Long wParam, String @lParam
		Declare Long SetTimer in User32 ;
		Long nhWnd, Long nEventId, Long uElapse, Long lpTimerFunc
		
		Declare Long KillTimer in User32 Long nhWnd, Long nEventId
		
		This.hWnd = iif( (VarType( th_Wnd )== 'N'), ;
		iif( th_Wnd != 0, th_Wnd, GetDesktopWindow() ), _VFP.hWnd )
		This.pOrgProc = GetWindowLong( _VFP.hWnd, -4 )
	ENDPROC

	PROCEDURE showmsg
		Lparameters tc_Msg, tn_Type, tc_Title, tn_Timeout
		Local ln_Return
		
		#Define WM_TIMER  0x0113
		#Define IDT_TIMER 1
		
		If (Vartype( m.tn_Timeout ) == [N])
		  This.nTimeOut = Iif( m.tn_Timeout < 1000, 1000, m.tn_Timeout )
		Endif
		Bindevent( 0, 0x06, This, [WndProc] )
		If (Vartype( m.tc_Title ) == [C])
		  ln_Return = Messagebox( m.tc_Msg, m.tn_Type, m.tc_Title )
		Else
		  ln_Return = Messagebox( m.tc_Msg, m.tn_Type )
		Endif
		Unbindevents( 0, 0x06 )
		
		If (This.nTimeOut > 0)
		  If ( This.lTimeout )
		    ln_Return = -1
		    KillTimer( This.hWnd_MsgBox, IDT_TIMER )
		    Unbindevents( This.hWnd_MsgBox, IDT_TIMER )
		  Else
		    KillTimer( This.HWnd, IDT_TIMER )
		    Unbindevents( This.HWnd, IDT_TIMER )
		  Endif
		Endif
		
		Store 0 To This.nTimeOut, This.hWnd_MsgBox
		This.lTimeout = .F.
		Return m.ln_Return
	ENDPROC

	PROCEDURE timerproc
		Lparameters th_Wnd, tn_Msg, t_wParam, t_lParam
		#Define WM_TIMER  0x0113
		#Define IDT_TIMER 1
		
		KillTimer( m.th_Wnd, IDT_TIMER)
		Unbindevents( m.th_Wnd, IDT_TIMER )
		
		SetTimer( This.hWnd_MsgBox, IDT_TIMER, This.nTimeOut, 0 )
		This.lTimeout = .T.
		Return 0
	ENDPROC

	PROCEDURE wndproc
		Lparameters th_Wnd, tn_Msg, t_wParam, t_lParam
		Local lh_WndChild, ln_Transparent, ln_X
		
		#Define WM_TIMER  0x0113
		#Define IDT_TIMER 1
		
		If (m.tn_Msg == 0x06) And (m.t_wParam == 0)
		  If (This.nTimeOut > 0)
		    This.hWnd_MsgBox = m.t_lParam
		    Bindevent( m.th_Wnd, WM_TIMER, This, [TimerProc] )
		    SetTimer( m.th_Wnd, IDT_TIMER, This.nTimeOut - 60, 0 )
		    This.nTimeOut = 200
		  Endif
		
		  With This
		    .CenterWindow( .HWnd, m.t_lParam )
		
		    If ( .lChangeButton )
		      lh_WndChild = 0
		      For ln_X = 1 To 3
		        lh_WndChild = FindWindowEx( m.t_lParam, m.lh_WndChild, [Button], 0 )
		        If (m.lh_WndChild == 0)
		          ln_X = 4
		        Else
		          If !Empty( .aButtons[ m.ln_X ] )
		            SendMessageStr( m.lh_WndChild, 0x0C, 0, .aButtons[ m.ln_X ] )
		          Endif
		        Endif
		      Next
		    Endif
		
		    If ( .lTransparent ) And (.nTransValue > 0)
		      ln_Transparent = Int((255 * This.nTransValue) / 100)
		      SetWindowLong( m.t_lParam, -20, ;
		          Bitor( GetWindowLong( m.t_lParam, -20 ), 0x80000 ))
		      SetLayeredWindowAttributes( m.t_lParam, 0, m.ln_Transparent, 2 )
		    Endif
		  Endwith
		
		  Return 0
		Endif
		
		Return CallWindowProc( This.pOrgProc, m.th_Wnd, m.tn_Msg, m.t_wParam, m.t_lParam )
	ENDPROC

ENDDEFINE

DEFINE CLASS oapi_apprun AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: checkprocessexitcode
		*m: extractdword
		*m: getprochandle
		*m: killproc
		*m: launchapp
		*m: launchappandwait
		*m: parseprocessinfostruc
		*m: releasehandle
		*p: iccommandline
		*p: icerrormessage
		*p: iclaunchdir
		*p: icwindowmode
		*p: inprocesshandle
		*p: inthreadhandle
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED inprocesshandle,inthreadhandle
	*<PropValue>
		Height = 95
		iccommandline = 0
		icerrormessage = 0
		iclaunchdir = 0
		icwindowmode = 0
		inprocesshandle = 0
		inthreadhandle = 0
		Name = "oapi_apprun"
		Width = 190
		_memberdata = <VFPData>
			<memberdata name="icerrormessage" display="icErrorMessage"/>
			<memberdata name="iccommandline" display="icCommandLine"/>
			<memberdata name="iclaunchdir" display="icLaunchDir"/>
			<memberdata name="icwindowmode" display="icWindowMode"/>
			<memberdata name="inprocesshandle" display="inProcessHandle"/>
			<memberdata name="inthreadhandle" display="inThreadHandle"/>
			<memberdata name="launchapp" display="LaunchApp"/>
			<memberdata name="launchappandwait" display="LaunchAppAndWait"/>
			<memberdata name="checkprocessexitcode" display="CheckProcessExitCode"/>
			<memberdata name="releasehandle" display="ReleaseHandle"/>
			<memberdata name="getprochandle" display="GetProcHandle"/>
			<memberdata name="killproc" display="KillProc"/>
			<memberdata name="parseprocessinfostruc" display="ParsePROCESSINFOStruc"/>
			<memberdata name="extractdword" display="ExtractDWORD"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE checkprocessexitcode
		*  examine the Process handle object's termination code member
		*  Provide the user with the option to examine another process
		*  termination code by passing an explicit handle, otherwise
		*  use the object's process instance
		Lparameter nProcessToCheck
		Local nExitCode
		
		If Type([nProcessToCheck]) # [N]
		  nProcessToCheck = This.inProcessHandle
		Endif
		Declare SHORT GetExitCodeProcess In Win32API As CheckExitCode ;
		  Integer hProcess, ;
		  Integer @lpdwExitCode
		nExitCode = 0
		If ! Isnull(m.nProcessToCheck)
		  If CheckExitCode(m.nProcessToCheck, @m.nExitCode) = 1
		    *  We retrieved an exit code (259 means still running, tho)
		    Return m.nExitCode
		  Else
		    *  Process did not exist in process table - no exit status
		    This.icErrorMessage = [Process to check not in active Process Table]
		    Return Null
		  Endif
		Else
		  This.icErrorMessage = [NULL process handle passed to CheckProcessExitCode()]
		  Return Null
		Endif
		
		
	ENDPROC

	PROCEDURE Destroy
		*  Mommy, mommy make it go away!
		With This
		  If Type([.inThreadHandle]) = [N] And Not Isnull(.inThreadHandle)
		    *  If we still hold it, dispose the Thread handle
		    .ReleaseHandle(.inThreadHandle)
		    .inThreadHandle = Null
		  Endif
		  If Type([.inProcessHandle]) = [N] And Not Isnull(.inProcessHandle)
		    *  If we still hold it, dispose the Process handle
		    .ReleaseHandle(.inProcessHandle)
		    .inProcessHandle = Null
		  Endif
		  *  NB - the process and thread object hang around until all handles to them are
		  *  disposed by CloseHandle - going out of scope doesn't release them.
		Endwith
		DoDefault()
	ENDPROC

	PROCEDURE extractdword
		*  Convert a 4 byte string to an unsigned long (DWORD)                                                                                                                                                                                                      
		Lparameter cStringToExtractFrom
		If Type([cStringToExtractFrom]) = [C] And Len(m.cStringToExtractFrom) >= 4
		  Return (((Asc(Subst(m.cStringToExtractFrom, 4, 1)) * 256) + ;
		        Asc(Subst(m.cStringToExtractFrom, 3, 1))) * 256 + ;
		      Asc(Subst(m.cStringToExtractFrom, 2, 1))) * 256 + ;
		    Asc(Left(m.cStringToExtractFrom, 1))
		Else
		  This.icErrorMessage = [Invalid DWORD string passed for conversion]
		  Return Null
		Endif
		
		
	ENDPROC

	PROCEDURE getprochandle
		*  Hand back the process handle in case someone needs it
		Return This.inProcessHandle
		
	ENDPROC

	PROCEDURE Init
		*                                                                                                                                                                                                                                                           
		*  API_AppRun - use the CreateProcess() API to launch, monitor, and kill an Executable                                                                                                                                                                       
		*                                                                                                                                                                                                                                                           
		*  Properties:                                                                                                                                                                                                                                               
		*                                                                                                                                                                                                                                                           
		*  inProcessHandle      (P)  ProcessHandle generated by CreateProcess()                                                                                                                                                                                          
		*  inThreadHandle      (P) ThreadHandle for First Thread of inProcessHandle                                                                                                                                                                                     
		*  icErrorMessage      R/O Error Message Detailed Description                                                                                                                                                                                                   
		*  icCommandLine      R/W Command Line to launch via CreateProcess()                                                                                                                                                                                            
		*  icLaunchDir        R/W Directory to use as startup dir for CreateProcess()                                                                                                                                                                                    
		*  icWindowMode      R/W Window Start Mode, one of (HID, NOR, MIN, MAX) or empty                                                                                                                                                                                
		*              defaults to empty, the default for the executable is used                                                                                                                                                                                           
		*                                                                                                                                                                                                                                                           
		*  Methods:                                                                                                                                                                                                                                                  
		*                                                                                                                                                                                                                                                           
		*  Init          (O) Command Line, (O) Start Dir, (O) Window Start Mode                                                                                                                                                                                           
		*              If sent, the icCommandLine, icLaunchDir and icWindowMode properties are set                                                                                                                                                                         
		*  Destroy                                                                                                                                                                                                                                                   
		*  LaunchApp        // Launches .icComandLine from .icLaunchDir in .icWindowMode                                                                                                                                                                                 
		*              // NB - at least .icCommandLine must be set to not fail                                                                                                                                                                                             
		*              RETURNS: BOOL, check icErrorMessage on .F.                                                                                                                                                                                                          
		*  LaunchAppAndWait    // Call LaunchApp() and wait on either user termination or process termination                                                                                                                                                          
		*              RETURNS: BOOL, check icErrorMessage on .F.                                                                                                                                                                                                          
		*  CheckProcessExitCode  (O) Process handle to check, defaults to .inProcessHandle                                                                                                                                                                            
		*              // Get Process named by Process Handle's Exit Code (259 = still running)                                                                                                                                                                            
		*              RETURNS:  Integer, check on NULL, if NULL, check icErrorMessage                                                                                                                                                                                     
		*  ExtractDWORD      (R) String to convert                                                                                                                                                                                                                      
		*              //Converts a 4 byte or longer string to a DWORD integer                                                                                                                                                                                             
		*              RETURNS:  Integer, check on NULL, if NULL arg was invalid                                                                                                                                                                                           
		*  KillProc        (O) Process handle to Terminate, defaults to .inProcessHandle                                                                                                                                                                                 
		*              // Kills specified process using TerminateProcess()                                                                                                                                                                                                 
		*              RETURNS:  BOOL, check icErrorMessage on .F.                                                                                                                                                                                                         
		*  GetProcHandle      //  Returns the Process Handle for the current Process                                                                                                                                                                                    
		*              // NB - only useful for KillProc(), since Destroy will close the handle                                                                                                                                                                             
		*              RETURNS:  Integer, check for NULL, if NULL no process was started yet                                                                                                                                                                               
		*  ParsePROCESSINFOStruc  // Pulls the Process Handle and Thread Handle from the PROCESSINFO structure                                                                                                                                                        
		*              // Only used internally                                                                                                                                                                                                                             
		*  ReleaseHandle      (R)  Handle to Close                                                                                                                                                                                                                      
		*              //  Invokes CloseHandle() to explicitly release process/thread handles                                                                                                                                                                              
		*              //  Only used internally, but can be externalized                                                                                                                                                                                                   
		*              RETURNS:  BOOL, check .icErrorMessage on .F.                                                                                                                                                                                                        
		*                                                                                                                                                                                                                                                           
		Lparameters tcCommandLine, tcLaunchDir, tcWindowMode
		*  Set up the environment for the object                                                                                                                                                                                                                     
		Local Array aDirTest[1, 5]
		
		With This
		  .icErrorMessage = []
		  .icCommandLine = []
		  .icLaunchDir = []
		  .icWindowMode = []
		  .inProcessHandle = Null
		  .inThreadHandle = Null
		  * store parameters if passed                                                                                                                                                                                                                               
		  If Type([tcCommandLine]) = [C]
		    .icCommandLine = Alltrim(m.tcCommandLine)
		  Endif
		  Do Case
		    Case Type([tcLaunchDir]) # [C]
		      *  Not a character expression - ignore                                                                                                                                                                                                                     
		    Case Adir(aDirTest, m.tcLaunchDir, [D]) # 1
		      *  Either directory doesn't exist, or there's a wildcard in the expression                                                                                                                                                                                 
		      .icErrorMessage = [Invalid directory for startup passed to Init method]
		    Otherwise
		      *  Valid directory - save it                                                                                                                                                                                                                               
		      .icLaunchDir = Alltrim(m.tcLaunchDir)
		  Endcase
		  Do Case
		    Case Type([tcWindowMode]) # [C]
		      *  Not passed in or not valid type                                                                                                                                                                                                                         
		    Case Inlist(Padr(Upper(Alltrim(m.tcWindowMode)), 3), [NOR], [MIN], [MAX], [HID])
		      *  Valid mode - set it                                                                                                                                                                                                                                     
		      .icWindowMode = Padr(Upper(Alltrim(m.tcWindowMode)), 3)
		    Otherwise
		      *  No a valid character string                                                                                                                                                                                                                             
		      If ! Empty(.icErrorMessage)
		        .icErrorMessage = .icErrorMessage + [ &] + Chr(13) + Chr(10)
		      Endif
		      .icErrorMessage = .icErrorMessage + [Invalid WindowMode passed to Init Method]
		  Endcase
		Endwith
		Return .T.
		
		
	ENDPROC

	PROCEDURE killproc
		*  A wrapper on TerminateProcess(), it will terminate the process owned by                                                                                                                                                                                  
		*  the object unless you pass it another Process Handle.  If it's already dead,                                                                                                                                                                             
		*  nothing interesting happens                                                                                                                                                                                                                              
		*                                                                                                                                                                                                                                                           
		*  TerminateProcess() does not shut down in an orderly fashion;  this is for emergencies!                                                                                                                                                                   
		Lparameter nProcessToKill
		Local nResult
		
		If Type([nProcessToKill]) # [N]
		  nProcessToKill = This.inProcessHandle
		Endif
		Declare SHORT TerminateProcess In WIN32API As KillProc ;
		  Integer hProcess, ;
		  Integer uExitCode
		If ! Isnull(m.nProcessToKill)
		  nResult = KillProc(m.nProcessToKill, 0)
		  This.icErrorMessage = Iif(m.nResult = 0, [TerminateProcess() could not kill process handle ] + Str(m.nProcessToKill), [])
		Else
		  This.icErrorMessage = [NULL handle passed to KillProc()]
		  nResult = 0
		Endif
		Return (m.nResult = 1)
		
		
	ENDPROC

	PROCEDURE launchapp
		*  Launch executable by CreateProcess() and return immediately                                                                                                                                                                                              
		Local cCommandLine, cProcessInfo, cStartUpInfo, cWindowMode, lResult, uFromDir
		
		this.icErrorMessage = []
		  If Type([ this.icCommandLine]) # [C]
		    *  Command line must be a character string                                                                                                                                                                                                                 
		    this.icErrorMessage = [icCommandLine must be set, and a string value]
		  Return .F.
		Else
		  cCommandLine = Alltrim(this.icCommandLine)
		Endif
		If Type([this.icLaunchDir]) # [C] Or Empty(this.icLaunchDir)
		  *  If not a character string, pass a null pointer, defaulting to Current Working Dir                                                                                                                                                                       
		  uFromDir = 0
		Else
		  *  Otherwise, null pad the string                                                                                                                                                                                                                          
		  uFromDir = this.icLaunchDir + Chr(0)
		Endif
		If Type([this.icWindowMode]) # [C]
		  *  If not passed, set to null string                                                                                                                                                                                                                       
		  cWindowMode = []
		Else
		  *  Translate the passed window mode to uppercase                                                                                                                                                                                                           
		  cWindowMode = Upper(this.icWindowMode)
		Endif
		*  This API call does the work.  The parameters are as follows:                                                                                                                                                                                             
		*    lpszModuleName - ptr-> file name of module to execute.                                                                                                                                                                                                  
		*      Since we aren't launching .CPLs, do not use                                                                                                                                                                                                           
		*    lpszCommandLine - ptr-> command to execute, as passed in method                                                                                                                                                                                         
		*    lpSecurityAttributesProcess - ptr-> SECURITY_ATTRIBUTES structure for Process.                                                                                                                                                                          
		*      Pass a null pointer                                                                                                                                                                                                                                   
		*    lpSecurityAttributesThread - ptr-> SECURITY_ATTRIBUTES structure for first thread.                                                                                                                                                                      
		*      Pass a null pointer                                                                                                                                                                                                                                   
		*    bInheritHandles - whether or not chlid inherits parent handles.                                                                                                                                                                                         
		*      Since no SECURITY_ATTRIBUTES passed, default to FALSE                                                                                                                                                                                                 
		*    dwCreateFlags - Process Creation Mode flag set.                                                                                                                                                                                                         
		*      We use the default mode at normal priority, ie 0                                                                                                                                                                                                      
		*    lpvEnvironment  - ptr-> a set of environment strings as if a MULTI_SZ.                                                                                                                                                                                   
		*      We don't set, so pass a null pointer                                                                                                                                                                                                                  
		*    lpszStartupDir - ptr-> the starting directory.                                                                                                                                                                                                          
		*      If none provided to method, pass a null pointer                                                                                                                                                                                                       
		*    lpStartInfo - ptr-> a STARTUPINFO structure.                                                                                                                                                                                                            
		*      We use one structure member at times.                                                                                                                                                                                                                 
		*    lpProcessInfo - ptr-> a PROCESS_INFORMATION structure, used to return PID/PHANDLE detail.                                                                                                                                                               
		*      We use one member to retain the Process handle, and destroy the thread handle                                                                                                                                                                         
		Declare SHORT CreateProcess In WIN32API As CrPr ;
		  String lpszModuleName, ;
		  String @lpszCommandLine, ;
		  String lpSecurityAttributesProcess, ;
		  String lpSecurityAttributesThread, ;
		  SHORT bInheritHandles, ;
		  Integer dwCreateFlags, ;
		  String lpvEnvironment, ;
		  String lpszStartupDir, ;
		  String @lpStartInfo, ;
		  String @lpProcessInfo
		*  Make default Structures for the CreateProcess call                                                                                                                                                                                                       
		*                                                                                                                                                                                                                                                          
		*  ProcessInfo -  struc, 4 DWORDs, a Process Handle, a Thread Handle, a ProcessID and a ThreadID                                                                                                                                                             
		*          we save the Process and Thread Handles in member properties to ensure that                                                                                                                                                                           
		*          they are properly disposed at Destroy by CloseHandle().  We dispose of the                                                                                                                                                                           
		*          thread handle immediately                                                                                                                                                                                                                            
		cProcessInfo = Repl(Chr(0), 16)
		*  StartUpInfo is a 68 byte long complex structure;  we either have 68 bytes with a cb member (byte 1) 68                                                                                                                                                   
		*  or with cb of 68, dwFlag low order byte (byte 45) of 1, and low order byte wShowWindow (byte 49) set to                                                                                                                                                  
		*  the SW_ value appropriate for the Window Mode desired.                                                                                                                                                                                                   
		Do Case
		  Case m.cWindowMode = [HID]
		    *  Hide - use STARTF_USESHOWFLAG and value of 0                                                                                                                                                                                                            
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) + ;
		      Repl(Chr(0), 23)
		  Case m.cWindowMode = [NOR]
		    *  Normal - use STARTF_USESHOWFLAG and value of 1                                                                                                                                                                                                          
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) + ;
		      Repl(Chr(0), 3) + ;
		      Chr(1) + ;
		      Repl(Chr(0), 19)
		  Case m.cWindowMode = [MIN]
		    *  Minimize - use STARTF_USESHOWFLAG and value of 2                                                                                                                                                                                                        
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) +  ;
		      Repl(Chr(0), 3) + ;
		      Chr(2) + ;
		      Repl(Chr(0), 19)
		  Case m.cWindowMode = [MAX]
		    *  Maximize - use STARTF_USESHOWFLAG and value of 3                                                                                                                                                                                                        
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) +  ;
		      Repl(Chr(0), 3) + ;
		      Chr(3) + ;
		      Repl(Chr(0), 19)
		  Otherwise
		    *  Use default of application                                                                                                                                                                                                                              
		    cStartUpInfo = Chr(68) + Repl(Chr(0), 67)
		Endcase
		*  Do it!                                                                                                                                                                                                                                                   
		lResult = CrPr(  0, ;
		    m.cCommandLine, ;
		    0, 0, 0, 0, 0, ;
		    m.uFromDir, ;
		    @m.cStartUpInfo, ;
		    @m.cProcessInfo)
		*  Strip the handles from the PROCESS_INFORMATION structure and save in private properties                                                                                                                                                                  
		If m.lResult = 1
		  this.ParseProcessInfoStruc(m.cProcessInfo)
		  Return .T.
		Else
		  this.icErrorMessage = [Process Specified by icCommandLine could not be started]
		  Return .F.
		Endif
		
		
		
	ENDPROC

	PROCEDURE launchappandwait
		*  Invoke LaunchApp(), and then wait on the process to terminate before returning control                                                                                                                                                                    
		#Define cnINFINITE     0xFFFFFFFF
		#Define cnHalfASecond  500  && milliseconds
		#Define cnTimedOut    258  && 0x0102
		*  We need some API calls, declare here                                                                                                                                                                                                                      
		*  GetCurrentProcess returns the pseudohandle of the current process (ie VFP instance)                                                                                                                                                                       
		Local uResult
		
		Declare Integer GetCurrentProcess In WIN32API As GetCurrProc
		*  WaitForIdleInput waits until the application is instantiated and at it's event loop                                                                                                                                                                       
		Declare Integer WaitForInputIdle In WIN32API As WaitInpIdle ;
		  Integer nProcessHandle, ;
		  Integer nWaitForDuration
		*  WaitForSingleObject waits until the handle in parm 1 is signalled or the timeout period expires                                                                                                                                                           
		Declare Integer WaitForSingleObject In WIN32API As WaitOnAppExit ;
		  Integer hProcessHandle, ;
		  Integer dwTimeOut
		*  Save the Process handle if any and the result of LaunchApp                                                                                                                                                                                                
		*  Fire the app and save the process handle                                                                                                                                                                                                                  
		uResult = 0
		With This
		  .icErrorMessage = []
		  If .LaunchApp()
		    uResult = 1
		    *  It's been launched;  wait until we're idling along                                                                                                                                                                                                      
		    = WaitInpIdle(GetCurrProc(), cnINFINITE)
		    *  As long as the other process exists, wait for it                                                                                                                                                                                                        
		    Do While WaitOnAppExit(.inProcessHandle, cnHalfASecond) = cnTimedOut
		      *  Give us an out in case the other app hangs - let <Esc> terminate waits                                                                                                                                                                                 
		      Try
		        If Inkey() = 27
		          *  Still running but we aren't waiting - return a -1 as a warning                                                                                                                                                                                       
		          .icErrorMessage = [Process started but user did not wait on termination]
		          uResult = 0
		          Exit
		        Endif
		      Catch
		      Endtry
		    Enddo
		  Else
		    *  Return 0 to indicate failure                                                                                                                                                                                                                            
		    uResult = 0
		  Endif
		Endwith
		Return (m.uResult = 1)
		
		
	ENDPROC

	PROTECTED PROCEDURE parseprocessinfostruc
		*  Pull the Process and thread handles out of the PROCESSINFO structure
		Lparameter cProcessInfoStructure
		With This
		  .inProcessHandle = .ExtractDWORD(m.cProcessInfoStructure)
		  .inThreadHandle = .ExtractDWORD(Subst(m.cProcessInfoStructure, 5))
		Endwith
	ENDPROC

	PROTECTED PROCEDURE releasehandle
		*  This uses CloseHandle to release a handle of any type.  I didn't expose it,
		*  mostly so that people wouldn't accidentally mash up things they shouldn't when
		*  experimenting
		Lparameter nHandleToRelease
		Local nResult
		
		*  Use CloseHandle(), returns a BOOL;  0 = False
		Declare SHORT CloseHandle In Win32API As CloseHand Integer nHandleToClose
		If Type([nHandleToRelease]) = [N] And ! Isnull(m.nHandleToRelease)
		  nResult = CloseHand(m.nHandleToRelease)
		  This.icErrorMessage = Iif(m.nResult = 0, [CloseHandle() failed to close handle ] + Str(m.nHandleToRelease), [])
		Else
		  This.icErrorMessage = [Invalid handle passed to ReleaseHandle() invocation]
		  nResult = 0
		Endif
		Return (m.nResult = 1)
	ENDPROC

ENDDEFINE

DEFINE CLASS ozip AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: executecommand
		*m: getproperfilecase
		*m: unzip
		*m: zip
		*p: cerrormessage
		*p: cwindowmode
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cerrormessage = 
		cwindowmode = HID                                                            
		Height = 70
		Name = "ozip"
		Width = 202
		_memberdata = <VFPData>
			<memberdata name="unzip" display="UnZip"/>
			<memberdata name="zip" display="Zip"/>
			<memberdata name="getproperfilecase" display="GetProperFileCase"/>
			<memberdata name="executecommand" display="ExecuteCommand"/>
			<memberdata name="cerrormessage" display="cErrorMessage"/>
			<memberdata name="cwindowmode" display="cWindowMode"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE executecommand
		lparameters tcCommand, ;
		  tcFolder, ;
		  tcWindowMode, ;
		  tlNoWait
		local lcFolder, ;
		  lcCommand, ;
		  lnPos, ;
		  lcBatFile, ;
		  loAPI, ;
		  lcMessage, ;
		  lnResult, ;
		  llResult
		* Get default values for missing parameters.
		if vartype(tcFolder) <> 'C' or empty(tcFolder)
		  lcFolder = fullpath('')
		else
		  lcFolder = tcFolder
		endif vartype(tcFolder) <> 'C' or empty(tcFolder)
		if right(lcFolder, 1) = '\'
		  lcFolder = left(lcFolder, len(lcFolder) - 1)
		endif right(lcFolder, 1) = '\'
		* If the command contains a redirected output, which isn't supported by
		* API_AppRun, we'll put the command into a BAT file and execute that.
		lcCommand = tcCommand
		lnPos     = at('>', tcCommand)
		if lnPos > 0
		  lcBatFile = addbs(sys(2023)) + 'Execute.bat'
		  strtofile(tcCommand, lcBatFile)
		  lcCommand = '"' + fullpath(lcBatFile) + '"'
		endif lnPos > 0
		* Use API_AppRun to execute the command.
		*!*  loAPI = newobject('API_AppRun', 'API_AppRun.prg', '', lcCommand, lcFolder, ;
		*!*    evl(tcWindowMode, 'HID'))
		Local loAPI as oapi_apprun of mylib.vcx
		loAPI = NewObject('oapi_apprun', 'mylib.vcx', '', lcCommand, lcFolder, evl(tcWindowMode, 'HID'))
		do case
		  case not empty(loAPI.icErrorMessage)
		    lcMessage = loAPI.icErrorMessage
		  case tlNoWait and loAPI.LaunchApp()
		    lcMessage = ''
		  case tlNoWait
		    lcMessage = loAPI.icErrorMessage
		  case loAPI.LaunchAppAndWait()
		    lnResult  = nvl(loAPI.CheckProcessExitCode(), -1)
		    llResult  = lnResult = 0
		    lcMessage = iif(llResult, '', ;
		      evl(loAPI.icErrorMessage, 'The error code is ' + transform(lnResult)))
		  otherwise
		    lcMessage = loAPI.icErrorMessage
		endcase
		* Erase the BAT file.
		if lnPos > 0
		  erase (lcBatFile)
		endif lnPos > 0
		return lcMessage
		
		
	ENDPROC

	PROCEDURE getproperfilecase
		*==============================================================================
		* Function:      GetProperFileCase
		* Purpose:      Returns the specified file or folder name in the case as it
		*            exists on disk
		* Author:      Doug Hennig
		* Last revision:  06/26/2018
		* Parameters:    tcName   - the name of the file or folder
		*          tlFolder - .T. if the name is a folder
		* Returns:      the file or folder name in the correct case
		* Environment in:  Scripting.FileSystemObject can be instantiated
		*          if a public variable named __FSO exists, it may contain a
		*            reference to Scripting.FileSystemObject
		* Environment out:  a public variable named __FSO exist contains a reference to
		*            Scripting.FileSystemObject
		*==============================================================================
		lparameters tcName, tlFolder
		local loFSO, ;
		  llExists, ;
		  loFile, ;
		  lcName, ;
		  lcFolder, ;
		  loFolder
		try
		  if type('__FSO') = 'O'
		    loFSO = __FSO
		  else
		    loFSO = createobject('Scripting.FileSystemObject')
		    public __FSO
		    __FSO = loFSO
		  endif type('__FSO') = 'O'
		  if tlFolder
		    llExists = directory(tcName)
		  else
		    llExists = file(tcName)
		  endif tlFolder
		  do case
		    case llExists and tlFolder
		      loFile = loFSO.GetFolder(tcName)
		      lcName = addbs(loFile.Path)
		    case llExists
		      loFile = loFSO.GetFile(tcName)
		      lcName = loFile.Path
		    case '\' $ tcName
		      lcFolder = justpath(tcName)
		      loFolder = loFSO.GetFolder(lcFolder)
		      lcName   = addbs(loFolder.Path) + lower(justfname(tcName))
		    otherwise
		      lcName = lower(tcName)
		  endcase
		catch
		  lcName = lower(tcName)
		endtry
		return lcName
		
		
	ENDPROC

	PROCEDURE Init
		Declare Sleep In Win32API Integer nMilliseconds
	ENDPROC

	PROCEDURE unzip
		Lparameters tcZipFile, tcFolder
		Local loException As Exception
		Local lcCommand, lcFolder, lcMessage, lcZipFile, llResult, loFiles, loShell
		
		* Ensure we have valid parameters.
		Do Case
		  Case Vartype(tcZipFile) <> [C] Or Empty(tcZipFile)
		    This.cErrorMessage = [The zip file was not specified]
		  Case Vartype(tcFolder) <> [C] Or Empty(tcFolder)
		    This.cErrorMessage = [The folder was not specified]
		    * Ensure the file exists.
		  Case Not File(tcZipFile)
		    This.cErrorMessage = tcZipFile + [ does not exist]
		    * Create the extraction folder if necessary.
		  Otherwise
		    lcFolder = this.GetProperFileCase(Fullpath(tcFolder))
		    If Not Directory(m.lcFolder)
		      Try
		        Md (m.lcFolder)
		        llResult = .T.
		      Catch To m.loException
		        This.cErrorMessage = [Error creating ] + m.lcFolder + [: ] + ;
		          m.loException.Message
		      Endtry
		      If Not m.llResult
		        Return .F.
		      Endif Not m.llResult
		    Endif Not Directory(m.lcFolder)
		    * Try to use Shell.Application to extract files.
		    llResult  = .F.
		    lcZipFile = Fullpath(tcZipFile)
		    Try
		      loShell = Createobject([Shell.Application])
		      loFiles = m.loShell.NameSpace(m.lcZipFile).Items
		      If m.loFiles.Count > 0
		        m.loShell.NameSpace(m.lcFolder).CopyHere(m.loFiles, cnSHELL_YES_TO_ALL)
		        llResult = .T.
		      Endif m.loFiles.Count > 0
		    Catch To m.loException
		    Endtry
		    * If that failed, use PowerShell.
		    If Not m.llResult
		      lcCommand = [cmd /c %SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe ] + ;
		        [Microsoft.Powershell.Archive\Expand-Archive -Force ] + ;
		        [-Path '] + m.lcZipFile + [' ] + ;
		        [-DestinationPath '] + m.lcFolder + [']
		      lcMessage = this.ExecuteCommand(m.lcCommand, m.lcFolder, This.cWindowMode)
		      llResult  = Empty(m.lcMessage)
		      If Not m.llResult
		        This.cErrorMessage = m.lcMessage
		      Endif Not m.llResult
		    Endif Not m.llResult
		Endcase
		Return m.llResult
		
	ENDPROC

	PROCEDURE zip
		Lparameters tcFiles, tcZipFile, tlOverwrite
		Local loException As Exception
		Local loShell As [Shell.Application]
		Local lcCommand, lcFile, lcFiles, lcMessage, lcTarget, llOK, llResult, lnFiles, lnHandle, lnI
		Local loZipFile
		
		Local Array laFiles[1]
		
		#Define ccCRLF    Chr(13) + Chr(10)
		#Define ccCR    Chr(13)
		#Define ccLF    Chr(10)
		* Ensure we have valid parameters.
		Do Case
		  Case Vartype(tcFiles) <> [C] Or Empty(tcFiles)
		    This.cErrorMessage = [The files were not specified]
		  Case Vartype(tcZipFile) <> [C] Or Empty(tcZipFile)
		    This.cErrorMessage = [The zip file was not specified]
		    * Create an empty Zip file if we're supposed to, then try to use Shell.Application
		    * to add files to it.
		  Otherwise
		    lnFiles = Alines(laFiles, tcFiles, 1 + 4, ccCR, ccLF, [,])
		    lcFiles = []
		    For lnI = 1 To m.lnFiles
		      lcFile  = this.GetProperFileCase(Fullpath(m.laFiles[m.lnI]))
		      lcFiles = m.lcFiles + Iif(Empty(m.lcFiles), [], [,]) + ['] + m.lcFile + [']
		      If Not File(m.lcFile)
		        This.cErrorMessage = m.lcFile + [ does not exist]
		        Return .F.
		      Endif Not File(m.lcFile)
		    Next m.lnI
		    Try
		      lcTarget = this.GetProperFileCase(Fullpath(tcZipFile))
		      llOK     = .T.
		      If Not File(m.lcTarget) Or tlOverwrite
		        lnHandle = Fcreate(m.lcTarget)
		        If m.lnHandle > 0
		          Fclose(m.lnHandle)
		        Else
		          llOK = .F.
		        Endif m.lnHandle > 0
		      Endif Not File(m.lcTarget) ...
		      If m.llOK
		        loShell   = Createobject([Shell.Application])
		        loZipFile = m.loShell.NameSpace(m.lcTarget)
		        For lnI = 1 To m.lnFiles
		          lcFile = this.GetProperFileCase(Fullpath(m.laFiles[m.lnI]))
		          m.loZipFile.CopyHere(m.lcFile)
		          Do While m.loZipFile.Items.Count < m.lnI
		            Sleep(1000)
		          Enddo While m.loZipFile.Items.Count < m.lnI
		        Next m.lnI
		        llResult = .T.
		      Endif m.llOK
		    Catch To m.loException
		    Endtry
		    If Not m.llOK
		      This.cErrorMessage = [Cannot create ] + m.lcTarget + [.]
		      Return .F.
		    Endif Not m.llOK
		    * If that failed, use PowerShell.
		    If Not m.llResult
		      lcCommand = [cmd /c %SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe ] + ;
		        [Microsoft.Powershell.Archive\Compress-Archive ] + ;
		        [-Path @(] + m.lcFiles + [) ] + ;
		        [-DestinationPath '] + m.lcTarget + ['] + ;
		        Iif(tlOverwrite, [], [ -Update])
		      lcMessage = this.ExecuteCommand(m.lcCommand, Justpath(m.lcTarget), This.cWindowMode)
		      llResult  = Empty(m.lcMessage)
		      If Not m.llResult
		        This.cErrorMessage = m.lcMessage
		      Endif Not m.llResult
		    Endif Not m.llResult
		Endcase
		Return m.llResult
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pg AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseIndex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkInc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFind" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: crecordsource_assign
		*m: dofiltergrid
		*m: editmemo
		*m: fontsize_assign
		*m: getgridwidth
		*m: getinputmask
		*m: getsortedstring		&& Sorts a string so that the longest words come first
		*m: hidecolumn
		*m: iscursor
		*m: istag
		*m: lcenter_assign
		*m: linputmask_assign
		*m: lreadonly_assign
		*m: lshowzero_assign
		*m: lzebra_assign
		*m: makecontrols
		*m: makeinputmask
		*m: makezebra
		*m: ngridwidth_access
		*m: nhighlightbackcolor_assign
		*m: nhighlightforecolor_assign
		*m: nzebracolor1_assign
		*m: nzebracolor2_assign
		*m: resolvemouse
		*m: setcaption
		*m: setdefaults
		*m: setgriddefaults
		*m: setproperties
		*m: sortgrid
		*m: visible_assign
		*p: calias
		*p: cback
		*p: ccursor
		*p: cmask
		*p: cmemo
		*p: cnosearchtext
		*p: cnulldisplay		&& Character(s) to show for null values
		*p: cnulldisplayold
		*p: crecordsource
		*p: csortfield
		*p: ctable
		*p: ctext
		*p: laskfortable
		*p: lautofit
		*p: lcenter
		*p: lcheckboxes
		*p: lenter
		*p: lfind
		*p: lfirst
		*p: lincinprocess
		*p: lincrementalseek
		*p: linputmask
		*p: llocate
		*p: lmax
		*p: lnofind
		*p: lreadonly
		*p: lshownulls
		*p: lshowzero
		*p: lzebra
		*p: ncolmemobackcolor
		*p: ncolmemodisabledbackcolor
		*p: ngridcorrection
		*p: ngridwidth
		*p: nheaderbackcolor
		*p: nheadersortablebackcolor
		*p: nheadersortedbackcolor
		*p: nhidelast
		*p: nhighlightbackcolor
		*p: nhighlightforecolor
		*p: nincstart
		*p: nselect
		*p: nzebracolor1
		*p: nzebracolor2
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		calias = 
		Caption = "ProGrid"
		cback = 
		ccursor = 
		cmask = !
		cmemo = <Memo>
		cnosearchtext = No text entered! All records are shown.
		cnulldisplay = 
		cnulldisplayold = 
		crecordsource = 
		csortfield = 
		ctable = 
		ctext = 
		DoCreate = .T.
		FontSize = 10
		Height = 1117
		laskfortable = .F.
		lcenter = .F.
		lcheckboxes = .F.
		Left = 0
		lenter = .F.
		lfind = .F.
		lfirst = .T.
		lincinprocess = .F.
		lincrementalseek = .F.
		linputmask = .F.
		llocate = .T.
		lmax = .F.
		lnofind = .F.
		lreadonly = .F.
		lshownulls = .F.
		lshowzero = .F.
		lzebra = .T.
		MinWidth = 300
		Name = "pg"
		ncolmemobackcolor = 0
		ncolmemodisabledbackcolor = 0
		ngridcorrection = 0
		ngridwidth = 0
		nheaderbackcolor = 0
		nheadersortablebackcolor = 0
		nheadersortedbackcolor = 0
		nhidelast = 0
		nhighlightbackcolor = (rgb(210,210,210))
		nhighlightforecolor = 0
		nincstart = 2
		nselect = 0
		nzebracolor1 = 16777215
		nzebracolor2 = 16777158
		ScrollBars = 2
		ShowTips = .T.
		Top = 0
		Visible = .T.
		Width = 1600
		_memberdata = <VFPData>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="ccursor" display="cCursor"/>
			<memberdata name="cnosearchtext" display="cNoSearchText"/>
			<memberdata name="dofiltergrid" display="doFilterGrid"/>
			<memberdata name="getsortedstring" display="getSortedString"/>
			<memberdata name="lmax" display="lMax"/>
			<memberdata name="nselect" display="nSelect"/>
			<memberdata name="setproperties" display="setProperties"/>
			<memberdata name="calias" display="cAlias"/>
			<memberdata name="csortfield" display="cSortField"/>
			<memberdata name="ctable" display="cTable"/>
			<memberdata name="ctext" display="cText"/>
			<memberdata name="lcenter" display="lCenter"/>
			<memberdata name="lcenter_assign" display="lCenter_Assign"/>
			<memberdata name="lreadonly" display="lReadOnly"/>
			<memberdata name="lreadonly_assign" display="lReadOnly_Assign"/>
			<memberdata name="lshowzero" display="lShowZero"/>
			<memberdata name="lshowzero_assign" display="lShowZero_Assign"/>
			<memberdata name="lzebra" display="lZebra"/>
			<memberdata name="lzebra_assign" display="lZebra_Assign"/>
			<memberdata name="makeinputmask" display="makeInputMask"/>
			<memberdata name="nheaderbackcolor" display="nHeaderBackColor"/>
			<memberdata name="nheadersortablebackcolor" display="nHeaderSortableBackColor"/>
			<memberdata name="nheadersortedbackcolor" display="nHeaderSortedBackColor"/>
			<memberdata name="nzebracolor1" display="nZebraColor1"/>
			<memberdata name="nzebracolor1_assign" display="nZebraColor1_Assign"/>
			<memberdata name="nzebracolor2" display="nZebraColor2"/>
			<memberdata name="nzebracolor2_assign" display="nZebraColor2_Assign"/>
			<memberdata name="setcaption" display="setCaption"/>
			<memberdata name="sortgrid" display="sortGrid"/>
			<memberdata name="makezebra" display="makeZebra"/>
			<memberdata name="crecordsource" display="cRecordSource"/>
			<memberdata name="crecordsource_assign" display="cRecordSource_Assign"/>
			<memberdata name="visible" display="Visible"/>
			<memberdata name="visible_assign" display="Visible_Assign"/>
			<memberdata name="fontsize" display="FontSize"/>
			<memberdata name="fontsize_assign" display="FontSize_Assign"/>
			<memberdata name="getinputmask" display="getInputMask"/>
			<memberdata name="iscursor" display="isCursor"/>
			<memberdata name="istag" display="isTag"/>
			<memberdata name="linputmask" display="lInputMask"/>
			<memberdata name="linputmask_assign" display="lInputMask_Assign"/>
			<memberdata name="name" display="Name"/>
			<memberdata name="lautofit" display="lAutofit"/>
			<memberdata name="editmemo" display="editMemo"/>
			<memberdata name="makecontrols" display="makeControls"/>
			<memberdata name="cmemo" display="cMemo"/>
			<memberdata name="getgridwidth" display="getGridWidth"/>
			<memberdata name="ngridwidth" display="nGridWidth"/>
			<memberdata name="ngridwidth_access" display="nGridWidth_Access"/>
			<memberdata name="cmask" display="cMask"/>
			<memberdata name="nhighlightbackcolor" display="nHighlightBackColor"/>
			<memberdata name="nhighlightbackcolor_assign" display="nHighlightBackColor_Assign"/>
			<memberdata name="nhighlightforecolor" display="nHighlightForeColor"/>
			<memberdata name="nhighlightforecolor_assign" display="nHighlightForeColor_Assign"/>
			<memberdata name="minwidth" display="MinWidth"/>
			<memberdata name="hidecolumn" display="hideColumn"/>
			<memberdata name="resolvemouse" display="resolveMouse"/>
			<memberdata name="lshownulls" display="lShowNulls"/>
			<memberdata name="cnulldisplay" display="cNullDisplay"/>
			<memberdata name="cnulldisplayold" display="cNullDisplayOld"/>
			<memberdata name="lnofind" display="lNoFind"/>
			<memberdata name="lfind" display="lFind"/>
			<memberdata name="setdefaults" display="SetDefaults"/>
			<memberdata name="ncolmemobackcolor" display="nColMemoBackColor"/>
			<memberdata name="ncolmemodisabledbackcolor" display="nColMemoDisabledBackColor"/>
			<memberdata name="setgriddefaults" display="setGridDefaults"/>
			<memberdata name="lincrementalseek" display="lIncrementalSeek"/>
			<memberdata name="lincinprocess" display="lIncInProcess"/>
			<memberdata name="laskfortable" display="lAskForTable"/>
			<memberdata name="lenter" display="lEnter"/>
			<memberdata name="nhidelast" display="nHideLast"/>
			<memberdata name="llocate" display="lLocate"/>
			<memberdata name="nincstart" display="nIncStart"/>
			<memberdata name="lcheckboxes" display="lCheckboxes"/>
			<memberdata name="width" display="Width"/>
			<memberdata name="ngridcorrection" display="nGridCorrection"/>
			<memberdata name="showwindow" display="ShowWindow"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkInc' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 9, ;
		AutoSize = .F., ;
		Caption = "\<Inc. seek (*)", ;
		ControlSource = "thisform.lIncrementalSeek", ;
		Height = 17, ;
		Left = 1500, ;
		Name = "chkInc", ;
		Top = 24, ;
		Value = .F., ;
		Width = 83
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkUseIndex' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 9, ;
		AutoSize = .F., ;
		Caption = "\<Use index (!)", ;
		Height = 17, ;
		Left = 1500, ;
		Name = "chkUseIndex", ;
		Top = 7, ;
		Value = .F., ;
		Width = 87
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'grd' AS grid WITH ;
		Anchor = 15, ;
		Height = 876, ;
		HighlightBackColor = 192,192,255, ;
		HighlightForeColor = 0,0,0, ;
		HighlightStyle = 2, ;
		Left = 0, ;
		Name = "grd", ;
		TabIndex = 1, ;
		Themes = .F., ;
		Top = 46, ;
		Width = 1164
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'lblFind' AS label WITH ;
		Alignment = 1, ;
		Anchor = 3, ;
		Caption = "\<Find", ;
		Height = 21, ;
		Left = 2, ;
		Name = "lblFind", ;
		TabIndex = 8, ;
		Top = 17, ;
		Width = 45, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'txtFind' AS textbox WITH ;
		Anchor = 11, ;
		Height = 35, ;
		Left = 60, ;
		Name = "txtFind", ;
		TabIndex = 9, ;
		Top = 8, ;
		Width = 1428, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Activate
		this.lZebra = this.lZebra 
		
	ENDPROC

	PROCEDURE crecordsource_assign
		lparameters tcRecordSource
		If !Empty(Justext(tcRecordSource)) && Alias
		   This.Grd.RecordSourceType = 0
		Else 
			this.Grd.RecordSourceType = 1    
		Endif
		This.cRecordSource = tcRecordSource
		this.cTable = JustStem(this.cRecordSource)
		ThisForm.setCaption()
	ENDPROC

	PROCEDURE Destroy
		Use in (Select(this.cCursor))
		Set Filter To 
		On Key Label ESC
	ENDPROC

	PROCEDURE dofiltergrid
		Lparameters tcText
		Local laFields[1], laFtypes[1], lcText, lcValue, lcWord, llFound, lnFields, lnRecord, lnWord, lnX
		lcText = Upper(Alltrim(m.tcText))
		If Len(m.lcText ) = 0 && or m.lcText == this.cMask
			this.txtFind.Value = ''
		*!*	   Wait Window Thisform.cNoSearchText
		   Select (this.cTable)
		   Set Filter To 
		   this.lZebra = .T.
		   this.Grd.SetFocus()
		   Return
		EndIf
		If !thisform.lIncrementalSeek 
			Wait Window 'Search in process...' nowait
		Endif
		lcCrlf = Chr(13)+Chr(10)
		Thisform.nSelect = Select()
		lnRec = Recno()
		Select 0
		Create Cursor (Thisform.cCursor ) (Record i)
		Index On Record Tag Record
		Select (Thisform.nSelect )
		Set Filter To
		lcPoint = Set("Point")
		Set Point To '.'
		lnFields = Afields(laFields)
		Dimension m.laFtypes(m.lnFields)
		For lnX = 1 To m.lnFields
		   laFtypes(m.lnX) = Vartype(Evaluate(Field(m.lnX)))
		EndFor
		For lnWord = 1 To Getwordcount(m.lcText)
		   lcWord = Getwordnum(m.lcText, m.lnWord)
		   If m.lnWord > 1
		      Set Relation To Recno() Into (Thisform.cCursor)
		      Set Filter To !Eof(Thisform.cCursor )
		   EndIf
		   If m.lnWord = 1 and ((Left(m.lcWord,1) = thisform.cMask and Len(m.lcWord) > 1) or !Empty(this.chkUseIndex.Value))
		   	If Left(m.lcWord,1) = thisform.cMask
			   	m.lcWord = Substr(m.lcWord ,2)
		   	Endif
		   	lnWordVal = Val(m.lcWord)
		   	lcCurDummy = 'cur_'+Sys(2015)
		   	lcSql = Textmerge('Select Cast(Recno() as i) as record from <<Alias()>> where ')
		   	lnTags = ATagInfo(laTags)
		   	For lnX = 1 to Tagcount()
		   		lcExpression = m.laTags(m.lnX,3)
		   		If '+'$m.lcExpression or '"'$m.lcExpression or !Empty(m.laTags(lnX,4))
		   			Loop
		   		EndIf
		   		m.lcType = Type('Evaluate(laTags(m.lnX,3))')
		    		Do Case
		   			Case InList(m.lcType ,'L','D','T','G','M','Q','W','Y')
		   				Loop
		   		   Case m.lcType = 'N' 
		   		   	If m.lnWordVal > 0
			   		   	m.lcSql = Textmerge( '<<m.lcSql>>; <<lcCrlf>> <<laTags(m.lnX,3)>> = <<m.lnWordVal>>')
			   		   Else
			   		   	loop
		   		   	Endif
		   		   Otherwise
		   		   	m.lcSql = Textmerge( '<<m.lcSql>>; <<lcCrlf>> <<laTags(m.lnX,3)>> = [<<m.lcWord>>]')
		   		EndCase
		   		If m.lnX < m.lnTags
		   			m.lcSql = m.lcSql + ' or '
		   		EndIf
		   	EndFor
		   	If Right(m.lcSql,4) = ' or '
		   		m.lcSql = Left(m.lcSql ,Len(m.lcSql)-4)
		   	Endif
		   	m.lcSql = Textmerge('<<m.lcSql>> into cursor <<m.lcCurDummy>> readwrite')
		   	_screen.AddProperty('sql',m.lcSql) 
		   	ExecScript(lcSql)
		   	If _tally>0
		   		Select (thisform.cCursor)
		   		Append from dbf(lcCurDummy)
		   		Use in (m.lcCurDummy)
		   	Endif
		   else
			   Scan
			      llFound = .F.
			      For lnX = 1 To m.lnFields
			         lcValue = Evaluate(Field(m.lnX))
			         Do Case
			            Case Inlist(Vartype(m.lcValue), [G], [L], [Q])
			               Loop
			            Case Vartype(m.lcValue) # [C]
			               lcValue = Transform(m.lcValue)
			            Otherwise
			         Endcase
			         lcValue = Upper(m.lcValue)
			         lnRecord = Recno()
			         If m.lcWord $ m.lcValue
			            If m.lnWord = 1
			               Insert Into (Thisform.cCursor) (Record) Values (m.lnRecord)
			            Endif
			            llFound = .T.
			            Exit
			         Endif
			      Endfor
			      If !m.llFound And m.lnWord > 1
			         Delete In (Thisform.cCursor)
			      Endif
			   EndScan
		   Endif
		   Select * From (Thisform.cCursor) Into Cursor (Thisform.cCursor) Readwrite Where !Deleted()
		   Index On Record Tag Record
		   Select (Thisform.nSelect)
		EndFor
		If !thisform.lIncrementalSeek 
			Wait clear
		Endif
		Set Point To m.lcPoint 
		Set Relation To Recno() Into (Thisform.cCursor )
		Set Filter To !Eof(Thisform.cCursor )
		Thisform.lZebra = .F.
		*Go Top
		If thisform.lLocate
			Locate
		Else
			Go m.lnRec 
		Endif
		
		this.grd.Refresh()
		
		
	ENDPROC

	PROCEDURE editmemo
		Local lcField
		Local laEvents[1], loHeader
		Local laDummy[1], lnHeight, lnWidth, lnX
		
		Aevents( laEvents, 0 )
		m.loHeader = m.laEvents[ 1 ]
		m.lcField = m.loHeader.Parent.ControlSource
		m.lnHeight = Alines(laDummy, Evaluate(m.lcField))
		m.lnWidth = 1
		For m.lnX = 1 To m.lnHeight
		  If Len(m.laDummy(m.lnX)) > m.lnWidth
		    m.lnWidth = Len(m.laDummy(m.lnX))
		  Endif
		Endfor
		m.lnWidth = Min(m.lnWidth, 200)
		m.lnHeight = Min(m.lnHeight + 5, 25)
		lcText = Evaluate( m.lcField)
		Define Window loWindow From 1, 1 Size m.lnHeight, m.lnWidth Font This.FontName, This.FontSize;
		  Title Justext(m.lcField) Close Float Grow
		Move Window loWindow Center
		If Thisform.lReadOnly
		  If !Empty(m.lcText)
		    Modify Memo (m.lcField) Window loWindow Noedit
		  Endif
		Else
		  Modify Memo (m.lcField) Window loWindow Nowait
		Endif
		
	ENDPROC

	PROCEDURE fontsize_assign
		lparameters tFontSize
		If m.tFontSize < 6
		  m.tFontSize = _screen.FontSize 
		Endif
		This.FontSize = tFontSize
		this.SetAll('fontsize',m.tFontSize)
		this.Grd.AutoFit()
		this.AutoCenter = .T.
		this.Width = this.nGridWidth 
		this.AutoCenter = .T.
		
	ENDPROC

	PROCEDURE getgridwidth
		lnWidth = this.Grd.GridLineWidth 
		lnLineWidth = this.Grd.GridLineWidth
		For lnX = 1 to this.Grd.ColumnCount
			If this.Grd.Columns(lnX).visible 
				m.lnWidth = m.lnWidth + this.Grd.Columns(m.lnX).width
				If this.Grd.GridLines>1
					m.lnWidth = m.lnWidth + m.lnLineWidth 
				Endif
			Endif
		EndFor
		If this.Grd.DeleteMark 
			m.lnWidth = m.lnWidth + 10
		EndIf
		If this.Grd.RecordMark
			m.lnWidth = m.lnWidth + 8
		EndIf
		If this.Grd.ScrollBars>1
			m.lnWidth = m.lnWidth + Sysmetric(5) + 2*m.lnLineWidth 
		EndIf
		Return m.lnWidth + 2 	
	ENDPROC

	PROCEDURE getinputmask
		Lparameters taDummy, tnElement
		Local lcMask, lcMaster, lcType, lnDecimals, lnInteger, lnWidth
		lcType = m.taDummy(m.tnElement, 2)
		lcMask = []
		Do Case
		   Case m.lcType = [I] && Integer
		      lcMask = [99 999 999 999]
		   Case m.lcType = [Y] && Currency
		      lcMask = [999 999 999 999 999.999]
		   Case m.lcType = [N] && Numeric
		      lnWidth = m.taDummy(m.tnElement, 3)
		      lnDecimals = m.taDummy(m.tnElement, 4)
		      If m.lnDecimals > 0
		         lnInteger = m.lnWidth - m.lnDecimals - 1
		      Else
		         lnInteger = m.lnWidth
		      Endif
		      lcMaster = [999 999 999 999]
		      Do Case
		         Case m.lnInteger >= 10
		            lcMask = Right(m.lcMaster, m.lnInteger + 3)
		         Case m.lnInteger >= 7
		            lcMask = Right(m.lcMaster, m.lnInteger + 2)
		         Case m.lnInteger >= 4
		            lcMask = Right(m.lcMaster, m.lnInteger + 1)
		         Otherwise
		            lcMask = Right(m.lcMaster, m.lnInteger)
		      Endcase
		      If m.lnDecimals > 0
		         lcMask = m.lcMask + [.] + Replicate([9], m.lnDecimals)
		      Endif
		Endcase
		lcMask = chrtran(lcMask,' ,',Set("Separator")+Set("Point"))
		Return m.lcMask
		
	ENDPROC

	PROCEDURE getsortedstring		&& Sorts a string so that the longest words come first
		Parameters tcText
		Local laDummy[1], lcReturn, lnWord, lnX
		lnWord = Getwordcount(m.tcText )
		Dimension m.laDummy(m.lnWord, 2)
		For lnX = 1 To m.lnWord
		   laDummy(m.lnX, 1) = Getwordnum(m.tcText, m.lnX )
		   laDummy(m.lnX, 2) = Len(m.laDummy(m.lnX, 1))
		Endfor
		Asort(m.laDummy, 2, 0, 1)
		lcReturn = []
		For lnX = 1 To m.lnWord
		   lcReturn = m.lcReturn + [ ] + m.laDummy(m.lnX, 1)
		Endfor
		Return Alltrim(m.lcReturn )
	ENDPROC

	PROCEDURE hidecolumn
		Local laEvents[1], loHeader As Header
		Local lnWidth
		lnWidth = 15
		Aevents( laEvents, 0 )
		If laEvents(1).Baseclass = 'Header'
			loHeader = laEvents[ 1 ]
			If loHeader.Parent.Width = m.lnWidth
			   loHeader.Parent.AutoFit()
			   this.grd.LockColumns = 0
			Else
			   loHeader.Parent.Width = m.lnWidth
			EndIf
			This.Resize()
		Endif
		
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcParameter
		*A: Ask for table if none selected
		*C: Show checkboxes incseek and index
		*D: AUtomatically cahnge width and height
		*E: Exit with Enter
		*F: Activate Find on startup
		*I: Incremental seek
		*M: "nice" numbers
		*N: Hide Find option (same as f)
		*S: Incremental seek starts after x=number of S's characters
		*U: Autofit
		*W: ReadWrite
		*Z: Hide zero values
		*0: (numeric): Incremental seek starts at first character
		*1: Standard modal
		
		Local lcTable, llSuccess, lnParCount
		
		If Pcount() = 0 And Vartype(_Screen.Lparameters) = [L] And _Screen.Lparameters && For interactive testing
		  If Empty(Alias())
		    Use kundtest In Select([kundtest])
		    Select kundtest
		  Endif Empty(Alias())
		  lnParCount = 1
		  tcParameter = [FI]
		Else
		  lnParCount = Pcount()
		Endif
		Thisform.SetDefaults()
		
		If m.lnParCount > 0
		  This.lAskForTable = [A] $ Upper(m.tcParameter)
		  This.lCheckboxes = [C] $ Upper(m.tcParameter)
		  This.lCenter = [D] $ Upper(m.tcParameter)
		  This.lEnter  = [E] $ Upper(m.tcParameter)
		  This.lFind = [F] $ Upper(m.tcParameter)
		  This.lIncrementalSeek = [I] $ Upper(m.tcParameter)
		  This.lNoFind = [N] $ Upper(m.tcParameter)
		  This.lReadOnly = ![W] $ Upper(m.tcParameter)
		  This.lShowZero = ![Z] $ Upper(m.tcParameter)
		  This.nHideLast = Occurs([L], Upper(m.tcParameter))
		  This.lInputMask = [M] $ Upper(m.tcParameter)
		  This.lAutofit = [U] $ Upper(m.tcParameter)
		  If [0] $ m.tcParameter && Number
		    This.nIncStart = 0
		  Endif
		  If [S] $ Upper(m.tcParameter)
		    This.nIncStart = Occurs([S], Upper(m.tcParameter))
		  Endif
		Endif
		Do Case
		  Case m.lnParCount = 0
		  Case [1] $ m.tcParameter && Standard modal
		    This.lIncrementalSeek = .T.
		    This.lEnter = .T.
		    This.lInputMask = .T.
		    This.lAutofit = .T.
		EndCase
		If This.lNoFind   && Hide Find option
		  This.Grd.Top = 0
		  This.txtFind.Visible = .F.
		  This.lblFind.Visible = .F.
		Endif
		If This.lEnter && Enter exits
		  This.lIncrementalSeek = .T.
		  This.chkInc.Visible = .F.
		  This.chkUseIndex.Visible = .F.
		  This.lFind = .T.
		Endif
		
		If _vfp.StartMode = 0 && Design mode
		Else
		  This.Width = Sysmetric(1) / 2
		  This.Height = Sysmetric(2) / 2
		Endif
		This.AutoCenter = .T.
		llSuccess = .T.
		If Empty(Alias())
		  If This.lAskForTable
		    lcTable = Getfile([dbf])
		    If Empty(m.lcTable)
		      llSuccess = .F.
		    Else
		      Select Select(Juststem(m.lcTable))
		      Use (m.lcTable)
		      *!*        Return .f. && TBFix 
		    Endif
		  Else
		    llSuccess = .F.
		  Endif
		  If !m.llSuccess
		    Messagebox( [No table is selected!], 0 + 16)
		    Return .F.
		  Endif
		Endif
		This.cRecordSource = Alias()
		Go Top In (This.cRecordSource)
		This.Grd.RecordSource = This.cRecordSource
		If Isreadonly()
		  This.lReadOnly = .T.
		  This.Grd.DeleteMark = .F.
		Endif
		
		If This.lAutofit
		  This.Grd.AutoFit()
		Endif
		This.makeControls()
		
		This.cNullDisplayOld = Set([Nulldisplay])
		On Key Label ESC Keyboard [{CTRL+F4}] Plain
		This.cCursor = [Cur_] + Sys(2015)
		
		This.Resize()
		This.AutoCenter = This.AutoCenter
	ENDPROC

	PROCEDURE iscursor
		Return (justpath(dbf(alias())) = sys(2023)) and JustExt(Dbf(Alias())) = 'TMP'
	ENDPROC

	PROCEDURE istag
		Lparameters tcTagName, tcTable 
		*-- Passed the name of an index tag returns true if it is a tag for the specified table. Uses table in the current work area if no table name is passed.
		  LOCAL ARRAY laTags[1]
		  LOCAL llRetVal
		  *** Did we get a tag name?
		  IF TYPE( 'tcTagName' ) # 'C'
		    *** Error - must pass a Tag Name
		    ERROR '9000: Must Pass a Tag Name when calling ISTAG()'
		    RETURN .F.
		  ENDIF
		  *** How about a table alias?
		  IF TYPE( 'tcTable' ) = 'C' AND ! EMPTY( tcTable )
		      *** Get all open indexes for the specified table
		      ATagInfo( laTags, "", tcTable )
		  ELSE
		      *** Get all open indexes for the current table
		      ATagInfo( laTags, "" )
		  ENDIF
		
		  *** Do a Case Insensitive, Exact=ON, Scan of the first column of array
		  *** Return Whether the Tag is Found or not
		  RETURN ( ASCAN( laTags, tcTagName, -1, -1, 1, 7 ) > 0 )
	ENDPROC

	PROCEDURE lcenter_assign
		lparameters tlCenter
		If m.tlCenter 
			this.Left = (Sysmetric(1) - this.Width)/2
			this.Top = (Sysmetric(2) - this.Height)/2
		Endif
		This.lCenter = tlCenter
		
	ENDPROC

	PROCEDURE linputmask_assign
		lparameters tlInputMask
		This.lInputMask = tlInputMask
		this.setProperties()
		
	ENDPROC

	PROCEDURE Load
		thisform.setGridDefaults() 
		
	ENDPROC

	PROCEDURE lreadonly_assign
		lparameters tlReadOnly
		This.lReadOnly = tlReadOnly
		this.setProperties()
	ENDPROC

	PROCEDURE lshowzero_assign
		lparameters tlShowZero
		This.lShowZero = tlShowZero
		this.setProperties()
	ENDPROC

	PROCEDURE lzebra_assign
		lparameters tlZebra
		This.lZebra = tlZebra
		this.setProperties()
	ENDPROC

	PROCEDURE makecontrols
		Local laDummy[1], lnFields, lnX
		Local loCol As Column, loChk As Checkbox
		Local lcCol as column, lcField, lcName
		Local loControl as CheckBox 
		m.lnFields = Afields(laDummy)
		For m.lnX = 1 To m.lnFields
		  m.lcField = Field(m.lnX)
		  m.lcCol = Textmerge([thisform.Grd.Columns(<<m.lnX >>)])
		  If Inlist(Type(m.lcField), [L], [M])
		    m.loCol = Evaluate(m.lcCol)
		    Do Case
		      Case Type(m.lcField) = [L]
		        m.lcName = [chk]
		        m.loCol.AddObject(m.lcName, [CheckBox])
		        m.loControl = Evaluate(m.lcCol + [.] + m.lcName)
		        m.loControl.Caption = []
		        m.loCol.CurrentControl = m.lcName
		        m.loCol.Alignment = 2
		      Case Type(m.lcField) = [M] 
		        m.loCol.Alignment = 2
		        thisform.cback = Textmerge('iif(Empty(Evaluate("<<this.Grd.RecordSource>>.<<m.lcField>>")),<<thisform.nColMemoDisabledBackColor>>,<<thisform.nColMemoBackColor>>)')
		        m.loCol.DynamicBackColor = this.cback
						BindEvent(m.loCol.text1 ,"Click",thisform,"editMemo",1)  
		      Otherwise && Won't happen, just in case...
		    Endcase
		    m.loCol.Sparse = .F.
		  EndIf
		EndFor
		thisform.grd.ColumnCount = Max(thisform.grd.ColumnCount - thisform.nHideLast, 1)
		
	ENDPROC

	PROCEDURE makeinputmask
		Local laDummy[1], lcMask, lnFields, lnX
		lnFields = Afields(laDummy)
		For lnX = 1 To this.Grd.ColumnCount && m.lnFields
			   lcMask = This.Getinputmask(@m.laDummy, m.lnX)
			   If !Empty( m.lcMask )
			   	this.Grd.Columns(lnX).InputMask = m.lcMask
			   Endif
			Endfor
		
	ENDPROC

	PROCEDURE makezebra
		If this.lZebra and Empty(Set("Order"))
			lcText = Textmerge([IIF(Recno()%2 = 0, <<thisform.nZebraColor1>>, <<thisform.Nzebracolor2>> )]) 
		Else
			lcText = ''
		EndIf
		For lnX = 1 to thisform.Grd.ColumnCount 
			With this.Grd.Columns(lnX)
				If Empty(.DynamicBackColor)
					.DynamicBackColor = m.lcText 
				Endif
			Endwith
		Endfor
		
	ENDPROC

	PROCEDURE ngridwidth_access
		Local lnWidth
		Return this.getGridWidth()
	ENDPROC

	PROCEDURE nhighlightbackcolor_assign
		lparameters tnHighlightBackColor
		This.nHighlightBackColor = tnHighlightBackColor
		this.setProperties()
	ENDPROC

	PROCEDURE nhighlightforecolor_assign
		lparameters tnHighlightForeColor
		This.nHighlightForeColor = tnHighlightForeColor
		this.setProperties ()
	ENDPROC

	PROCEDURE nzebracolor1_assign
		lparameters tnZebraColor1
		This.nZebraColor1 = tnZebraColor1
		this.setProperties()
	ENDPROC

	PROCEDURE nzebracolor2_assign
		lparameters tnZebraColor2
		This.nZebraColor2 = tnZebraColor2
		this.setProperties()
	ENDPROC

	PROCEDURE Release
		Set Nulldisplay To this.cNullDisplayOld
		Select (this.cRecordSource)
		Set Filter To 
		On Key Label ESC 
		
	ENDPROC

	PROCEDURE Resize
		Local lnGridWidth
		lnGridWidth = This.nGridWidth
		If This.Width > lnGridWidth 
		   This.Width = lnGridWidth
		EndIf
		
	ENDPROC

	PROCEDURE resolvemouse
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		Do Case
		   Case nButton = 1 && LeftClick
				thisform.sortGrid()
		   Case nButton = 2 and nShift = 0 && RightClick
				thisform.hideColumn()
		   Case nButton = 2 and nShift = 1 &&RightClick + shift
		   Otherwise
		EndCase
		
	ENDPROC

	PROCEDURE setcaption
		If this.isCursor()
		  lcAlias = Proper(Alias())
		Else
		  m.lcAlias = Proper(Juststem(This.cRecordSource))
		EndIf
		this.cAlias = m.lcAlias 
		this.Caption = Textmerge('<<m.lcAlias>> (<<Transform(Reccount())>> records)')
	ENDPROC

	PROCEDURE setdefaults
		this.lAskForTable = .F.
		this.lNoFind = .F.
		this.lReadOnly = .F.
		this.lShowZero = .F.
		this.lFind = .F.
		this.lIncrementalSeek = .F.
		this.lEnter = .F.
		
	ENDPROC

	PROCEDURE setgriddefaults
		this.nHighlightBackColor = Rgb(210,210,210) 
		this.nHighlightForeColor = 0
		this.nColMemoBackColor = Rgb(127,255,127)
		this.nColMemoDisabledBackColor = Rgb(240,240,240)
		this.nHeaderSortableBackColor = Rgb(255,255,220)
		this.nHeaderSortedBackColor = Rgb(220,255,220) 
		this.nHeaderBackColor =  RGB(255,220,220) 
	ENDPROC

	PROCEDURE setproperties
		*!*	ThisForm.MakeZebra()
		If thisform.lShowNulls
			Set Nulldisplay To 
		Else
			Set Nulldisplay To thisform.cNullDisplay
		Endif
		If PemStatus(this,'grd',5) and PemStatus(this.Grd,'column1',5)
			* Vartype(this.grd) = 'O' and Lower(this.Grd.BaseClass) = 'grid'
			If PemStatus(this,'grd',5)
				If this.lShowZero 
					this.Grd.SetAll('format','','column')
				Else
					this.Grd.SetAll('format','Z','column')
				EndIf
				this.Grd.readOnly = Nvl(this.lReadOnly,.F.)
				this.Grd.DeleteMark = !this.lReadOnly and !IsReadonly()
				If this.lInputMask
					this.makeInputMask()
				Else 
					this.Grd.SetAll('InputMask','','column')	
				EndIf
				this.grd.HighlightBackColor = this.nHighlightBackColor 
				this.grd.HighlightForeColor = this.nHighlightForeColor 
			Endif
			ThisForm.MakeZebra()
		Endif
		
		
	ENDPROC

	PROCEDURE Show
		Lparameters nStyle
		If Thisform.lFind and !thisform.lNoFind 
		  Keyboard [{ALT+F}{UPARROW}] Plain
		Endif
		
	ENDPROC

	PROCEDURE sortgrid
		Local laEvents[ 1 ], loHeader, lcField, loColumn, lcSortOrder, loControl as Header 
		Local llFoundColumn, llAllowCellSelection, lnRecNo
		Local lcTable
		
		*** First of all, see which column fired off this event
		Aevents( laEvents, 0 )
		loHeader = laEvents[ 1 ]
		If Vartype( loHeader ) = [O]
		   *** First See if a ControlsSource was set for the column
		   With loHeader.Parent
		      lcField = []
		      If Not Empty( .ControlSource )
		         *** Cool. Use it to decide how to sort the grid
		         If Not Empty( .ControlSource ) And ( [.] $ .ControlSource ) And Not( [(] $ .ControlSource )
		            lcField = Justext( .ControlSource )
		         Endif
		      Endif
		   Endwith
		   *** we have a field - let's see if it already has a sort order set
		   *** if it does, it will have the appropriate picture in the header
		   lcSortOrder = []
		   If Not Empty( loHeader.Picture )
		      lcSortOrder = Iif( Lower( Justfname( loHeader.Picture ) ) == [up.bmp], [], [DESC] )
		   Else
		      *** See if there is a visual cue on any of the other grid
		      *** column headers and remove it if there is
		      For Each loColumn In This.Grd.Columns
		         For Each loControl In loColumn.Controls
		            If Lower( loControl.BaseClass ) == [header]
		               If Not Empty( loControl.Picture )
		                  llFoundColumn = .T.
		                  loControl.Picture = []
		                  loControl.FontBold = .F.
		                  If loControl.BackColor = this.nHeaderSortedBackColor 
		                  	loControl.BackColor = this.nHeaderSortableBackColor 
		                  Endif
		               Endif
		            Endif
		         Endfor
		         If llFoundColumn
		            Exit
		         Endif
		      Endfor
		   Endif
		
		   *** if we have a field - let's sort
		   If Not Empty( lcField )
		      *** There seems to be a refresh issue here
		      *** because even though the data is in the cursor
		      *** it is not showing up in the grid after the sort
		      *** and it looks like it is related to AllowCellSelection being .F.
		      llAllowCellSelection = This.Grd.AllowCellSelection
		      This.Grd.AllowCellSelection = .F.
		      This.Grd.Refresh()
		      Keyboard [{CTRL+TAB}]
		
		      *** Check to see if the tag exists assume
		      *** that if there is a tag on this field, it has the same name as the field
		      lcTable = Juststem(This.Grd.RecordSource)
		      If This.IsTag( lcField, m.lcTable  )
		         lnRecNo = Recno( m.lcTable )
		         *** Go ahead and set the order for the table
		         Select ( lcTable)
		         If Empty(m.lcSortOrder) 
			         Set Order To ( lcField ) 
			      Else
			         Set Order To ( lcField ) DESCENDING 
		         Endif
		*!*	         This.Grd.SetFocus()
		         If lnRecNo # 0
		            Go lnRecNo In ( lcTable )
		         Endif
		         *** And set the visual cues on the header
		         loHeader.Picture = Iif( !Empty( lcSortOrder ), [..\images\up.bmp], [..\images\down.bmp] )
		         loHeader.FontBold = .T.
		         loHeader.BackColor = this.nHeaderSortedBackColor 
		         This.Grd.AllowCellSelection = llAllowCellSelection
		*!*	         Endif
				Else
					Set Order to 
		      EndIf
		   Endif
		Endif 
		*!*	If this.lAutofit
		*!*		this.grd.AutoFit()
		*!*	Endif
		this.makeZebra()
		this.Grd.Refresh()
	ENDPROC

	PROCEDURE Unload
		If this.WindowType = 1 and !Empty(thisform.cRecordSource)
			Return Recno(Alias())
		Endif
		
	ENDPROC

	PROCEDURE visible_assign
		lparameters tVisible
		This.Visible = tVisible
		this.Grd.SetFocus()
	ENDPROC

	PROCEDURE chkInc.InteractiveChange
		this.Parent.txtFind.SetFocus()
	ENDPROC

	PROCEDURE chkInc.LostFocus
		this.Parent.txtFind.Refresh()
	ENDPROC

	PROCEDURE chkInc.Refresh
		this.Visible = thisform.lCheckboxes
	ENDPROC

	PROCEDURE chkUseIndex.InteractiveChange
		this.Parent.txtFind.SetFocus()
	ENDPROC

	PROCEDURE chkUseIndex.Refresh
		this.Visible = thisform.lCheckboxes 
	ENDPROC

	PROCEDURE grd.Init
		With this.Parent 
		*!*		this.Top = 0
			this.Left = 0
			this.Width = .Width
			this.Height = .Height - 45
		EndWith
		*!*	ThisForm.setGridDefaults()
		For lnX = 1 to this.ColumnCount
			If thisform.isTag(Justext(this.Columns(lnX).controlsource), thisform.cAlias )
				this.Columns(lnX).header1.backcolor = thisform.nHeaderSortableBackColor 
			Else
				this.Columns(lnX).header1.backcolor = thisform.nHeaderBackColor
			Endif
			BindEvent(this.Columns(lnX).header1,'mousedown',thisform,'resolveMouse')	
		EndFor
		this.Refresh()
		thisform.nGridCorrection = thisform.Width - this.Width 
		
	ENDPROC

	PROCEDURE grd.Refresh
		If Thisform.lNoFind
		  This.Top = 0
		  This.Height = Thisform.Height
		Else
		  This.Top = 45
		Endif
		This.AutoFit()
		This.Width  = Thisform.nGridWidth
		Thisform.Width = This.Width 
		this.Width = this.Width 
		If Type([thisform.txtFind]) = [O] and Type([thisform.txtFind.width]) = [N] 
		  Thisform.txtFind.Width = Thisform.Width - Thisform.txtFind.Left - 10
		Endif
		If Thisform.lCenter
		  Thisform.lCenter = .T.
		EndIf
		
		
		
		
	ENDPROC

	PROCEDURE grd.Resize
		if thisform.lNoFind 
			this.Top = 0
			this.Height = thisform.Height 
		Else
			this.Top = 45
		endif		
		
	ENDPROC

	PROCEDURE lblFind.Refresh
		this.Enabled = !thisform.lMax 
	ENDPROC

	PROCEDURE txtFind.KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		Local llGrid, lnSelStart
		
		*!*  Wait Window  at 10,25 Transform(m.nshiftaltctrl) + ' ' + Transform(m.nKeyCode) + ' ' + Chr(m.nKeyCode) time 2
		lnSelStart = This.SelStart
		
		llGrid = .F.
		Nodefault
		Do Case
		*!*    Case m.nKeyCode = 1 And m.nShiftAltCtrl = 0 and this.SelStart = 0 && Home
		*!*      Set Order To
		*!*      For lnX = 1 to thisform.Grd.ColumnCount
		*!*        If thisform.isTag(Justext(thisform.Grd.Columns(lnX).controlsource), thisform.cAlias )
		*!*          thisform.Grd.Columns(lnX).header1.backcolor = thisform.nHeaderSortableBackColor 
		*!*        Else
		*!*          thisform.Grd.Columns(lnX).header1.backcolor = thisform.nHeaderBackColor
		*!*        Endif
		*!*      EndFor 
		*!*      m.llGrid = .T.
		  Case m.nKeyCode = 5 And m.nShiftAltCtrl = 0 && Up
		    Try
		      Skip - 1
		    Catch
		
		    Endtry
		    llGrid = .T.
		  Case m.nKeyCode = 24 And m.nShiftAltCtrl = 0 && Down
		    Try
		      Skip 1
		    Catch
		    Endtry
		
		    llGrid = .T.
		  Case m.nKeyCode = 18 And m.nShiftAltCtrl = 0 && PgUp
		    Try
		      Skip - 50
		    Catch
		      Go Top
		    Endtry
		    llGrid = .T.
		  Case m.nKeyCode = 3 And m.nShiftAltCtrl = 0 && PgDn
		    Try
		      Skip 50
		    Catch
		      Go Bott
		    Endtry
		    llGrid = .T.
		  Case m.nKeyCode = 29 And m.nShiftAltCtrl = 2 && CtrlHome
		    Go Top
		    llGrid = .T.
		  Case m.nKeyCode = 23 And m.nShiftAltCtrl = 2 && CtrlEnd
		    Go Bott
		    llGrid = .T.
		
		  Case m.nKeyCode = 13 And m.nShiftAltCtrl = 0 && Enter
		    If Thisform.lEnter
		      Thisform.Release
		    Else
		      Thisform.lIncInProcess = .F.
		      Thisform.doFilterGrid(This.Value)
		      *!*        thisform.Grd.SetFocus()
		      This.SetFocus()
		    Endif
		*!*    Case Chr(m.nKeyCode) = [*] and m.nShiftAltCtrl = 1 && Shift-*
		*!*      Thisform.lIncrementalSeek = !Thisform.lIncrementalSeek
		*!*      Thisform.chkInc.Refresh()
		*!*      This.Refresh()
		*!*    Case Chr(m.nKeyCode) = [!]
		*!*      Thisform.chkUseIndex.Value = !Thisform.chkUseIndex.Value
		  Case Thisform.lIncrementalSeek
		    DoDefault(m.nKeyCode, m.nShiftAltCtrl )
		    lnSelStart = This.SelStart
		    If Len(Trim(This.Value)) > Thisform.nIncStart
		      Thisform.lIncInProcess = .T.
		    Endif
		    If Thisform.lIncInProcess
		      Thisform.doFilterGrid(This.Value)
		    Endif
		    This.SelStart = m.lnSelStart
		    This.SetFocus()
		  Otherwise
		    DoDefault(m.nKeyCode, m.nShiftAltCtrl)
		Endcase
		
		If m.llGrid
		  Thisform.Grd.Refresh()
		  This.SetFocus()
		Endif
		
	ENDPROC

	PROCEDURE txtFind.Refresh
		this.Enabled = !thisform.lMax 
		If thisform.lIncrementalSeek 
			this.BackColor = RGB(255,255,128)
		Else
			this.BackColor = RGB(255,255,255)
		Endif thisform.lIncrementalSeek
	ENDPROC

ENDDEFINE

DEFINE CLASS sidekick AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblSidekick" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addextension
		*m: addfield
		*m: addlinesandtext
		*m: addoption
		*m: addskextensions
		*m: changesidekickfile
		*m: checkorcreatesidekickfile
		*m: closeopenedtables
		*m: createcommentline
		*m: cutandgivemessage
		*m: cutcurrentline
		*m: decodetimestamp
		*m: dir2dt
		*m: dobrowmodal
		*m: dropfieldifempty
		*m: executehighlight
		*m: findcommand
		*m: findfile
		*m: findfunction
		*m: findparameters
		*m: findskoptions
		*m: findswitch
		*m: findvalueinstring
		*m: fixpath
		*m: getadditionalfiles
		*m: getallfiles
		*m: getdatafromgrid
		*m: getdatafromurl
		*m: getdescript
		*m: geteditsourcecode
		*m: getextensioncursor
		*m: getfieldcount
		*m: getfilelisttoprocess		&& Pass a comma delimited file list, return list with corresponding files added. Pass .T: to include secondary files (.bak, .err e.t.c.)
		*m: getfilesandsubfolders
		*m: getfilesinfolder
		*m: getfilesinpath
		*m: gethelptopics
		*m: getlastcharacter
		*m: getlastfile
		*m: getlastword
		*m: getlineno
		*m: getlinestoprocess
		*m: getmemosize
		*m: getmethdosfromclasslib
		*m: getmethodfromprg
		*m: getnextfile
		*m: getnextproject
		*m: getnumberedline
		*m: getrandomtext
		*m: getrecordsindbf
		*m: getsortabledate		&& Returns YYMMDD format from date
		*m: getthorfiles
		*m: givemessage
		*m: handlemrutable
		*m: highlightcurrentline
		*m: indexfields
		*m: indexiffield
		*m: iscursor
		*m: isinteger
		*m: istag
		*m: lefttrimcode
		*m: listdescript
		*m: listfiles
		*m: listusedtables
		*m: log
		*m: notes
		*m: oeditorwininit
		*m: openiffile
		*m: ozipinit
		*m: readclasslibs
		*m: readoptions
		*m: readregistryoption
		*m: removedoublecharacter
		*m: removeprocendproc
		*m: replacecurrentline
		*m: restoreselection
		*m: returnunknowncommand
		*m: runed
		*m: runprogram
		*m: runsidekickline
		*m: scanallwindows
		*m: setupgrid
		*m: setupregistry
		*m: shellx
		*m: showcase
		*m: skfactory
		*m: sk_be
		*m: sk_br
		*m: sk_db
		*m: sk_dd
		*m: sk_def
		*m: sk_desc
		*m: sk_dr
		*m: sk_ec
		*m: sk_ed
		*m: sk_equ
		*m: sk_err
		*m: sk_es
		*m: sk_ff		&& Utility to fine file in folder and subfolders
		*m: sk_fl
		*m: sk_fp
		*m: sk_grp
		*m: sk_hei
		*m: sk_help
		*m: sk_hk
		*m: sk_inc
		*m: sk_ins
		*m: sk_lor
		*m: sk_ltry
		*m: sk_menu
		*m: sk_mf_remove
		*m: sk_no
		*m: sk_op
		*m: sk_ot
		*m: sk_pa
		*m: sk_rt
		*m: sk_sb
		*m: sk_sk
		*m: sk_sked
		*m: sk_sx
		*m: sk_ta
		*m: sk_tools
		*m: sk_unzip
		*m: sk_us
		*m: sk_ver
		*m: sk_zero
		*m: sk_zip
		*m: splitcommand
		*m: tryexecute
		*m: writecurrentline
		*p: calias
		*p: cbackupfolder		&& Name of folder for "deleted" files
		*p: ccaption		&& Caption for pg
		*p: cclip
		*p: ccommand
		*p: ccommandoriginal
		*p: ccommentstring
		*p: ccursor
		*p: cdefaultcommand
		*p: cdescriptionmask1
		*p: cdescriptionmask2
		*p: cdisplaycase
		*p: cerrormessage
		*p: cexact
		*p: cextensionlist
		*p: cfilter
		*p: clowercommand
		*p: clowerparameter
		*p: cmrutable
		*p: coption
		*p: cparameter
		*p: cparameteroriginal
		*p: cparcedtext
		*p: cpathreturned
		*p: cpoint
		*p: cprogram
		*p: crun
		*p: csearchtext
		*p: csidekickfile
		*p: csidekickhelp
		*p: cskfile		&& Prefix for Sidekick extensions
		*p: ctableselected
		*p: ctabletokeepopen		&& Table NOT to close on exit
		*p: ctestarea
		*p: ctitle
		*p: cunzipfolder		&& Default folder to unzip into
		*p: cversion
		*p: cziptarget		&& Default name for zip target, if none is specified
		*p: laddextraextensions
		*p: lclosetables
		*p: lcomment
		*p: ldelete
		*p: linputbox		&& Date comes from editbox activated by SK hotkey
		*p: lnobrowse
		*p: lnointerface
		*p: lnomessage		&& If true, no message is given if Esc is pressed from grid
		*p: lnoselectonexit
		*p: lskcomment		&& True for commented lines, so that the line is not deleted
		*p: lsuccess
		*p: lthorfolders
		*p: ltidy		&& Try for moving selected files to backup folder
		*p: nfilesize
		*p: nfontsize
		*p: nhandle
		*p: nlastwindow		&& WIndow handle for last used window
		*p: nlineno
		*p: nmaxdescriptline
		*p: nnextlength		&& Length of numeric extension for automatically incremented file names, like panzip_00001 where value is 5
		*p: nselect
		*p: nselend
		*p: nselstart
		*p: ntimeout		&& Timeout in milliseconds, used for messageboxes
		*p: nvalcommand
		*p: nwindowtype
		*p: nzipdelay		&& Delay necessary so that oZip has time to create file
		*p: oeditor
		*p: oeditorwin
		*p: oeditorwin_def
		*p: oeditor_def
		*p: ogrid
		*p: oregistry
		*p: ozip
		*a: ainerror[1,0]
		*a: ainuse[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		calias = 
		ccaption = 
		cclip = 
		ccommand = 
		ccommandoriginal = 
		ccommentstring = 
		ccursor = curSKTemp
		cdefaultcommand = 
		cdescriptionmask1 = * Description:
		cdescriptionmask2 = *
		cdisplaycase = Lower                                                          
		cerrormessage = 
		cexact = 
		cextensionlist = 
		cfilter = 
		clowercommand = 
		clowerparameter = 
		cmrutable = 
		coption = 
		cparameter = 
		cparameteroriginal = 
		cparcedtext = 
		cpathreturned = 
		cpoint = .                                                              
		cprogram = Sidekick
		crun = 
		csearchtext = 
		csidekickfile = 
		csidekickhelp = 
		cskfile = sk_                                                            
		ctableselected = 
		ctabletokeepopen = 
		ctestarea = 
		ctitle = 
		cunzipfolder = PanUnzip                                                       
		cversion = 
		cziptarget = Panzip_                                                        
		Height = 330
		laddextraextensions = .F.
		lclosetables = .T.
		lcomment = .F.
		ldelete = .F.
		linputbox = .F.
		lnobrowse = .F.
		lnointerface = .F.
		lnomessage = .F.
		lnoselectonexit = .F.
		lskcomment = .F.
		lsuccess = .F.
		lthorfolders = .F.
		ltidy = .F.
		Name = "sidekick"
		nfilesize = 0
		nfontsize = 10
		nhandle = 0
		nlastwindow = 0
		nlineno = 0
		nmaxdescriptline = 15
		nnextlength = 4
		nselect = 0
		nselend = 0
		nselstart = 0
		ntimeout = 3000
		nvalcommand = 0
		nwindowtype = 0
		nzipdelay =          0.1
		oeditor = .NULL.
		oeditorwin = .NULL.
		oeditorwin_def = execscript (_Screen.cThorDispatcher, 'class= editorwin from pemeditor')
		oeditor_def = Execscript(_Screen.cThorDispatcher, [class= HighlightedText from Thor_Proc_HighlightedText.PRG])
		ogrid = 
		oregistry = 
		ozip = 
		Width = 675
		_memberdata = <VFPData>
			<memberdata name="oeditorwin_def" display="oEditorWin_Def"/>
			<memberdata name="oeditor_def" display="oEditor_Def"/>
			<memberdata name="findvalueinstring" display="FindValueInString"/>
			<memberdata name="findfunction" display="FindFunction"/>
			<memberdata name="findparameters" display="FindParameters"/>
			<memberdata name="findfile" display="FindFile"/>
			<memberdata name="findcommand" display="FindCommand"/>
			<memberdata name="ogrid" display="oGrid"/>
			<memberdata name="setupgrid" display="SetupGrid"/>
			<memberdata name="setupregistry" display="SetupRegistry"/>
			<memberdata name="restoreselection" display="RestoreSelection"/>
			<memberdata name="getdatafromgrid" display="GetDataFromGrid"/>
			<memberdata name="shellx" display="ShellX"/>
			<memberdata name="addlinesandtext" display="AddLinesAndText"/>
			<memberdata name="createcommentline" display="CreateCommentLine"/>
			<memberdata name="cutcurrentline" display="CutCurrentLine"/>
			<memberdata name="getallfiles" display="GetAllFiles"/>
			<memberdata name="getdatafromurl" display="GetDataFromURL"/>
			<memberdata name="getdescript" display="GetDescript"/>
			<memberdata name="geteditsourcecode" display="GetEditSourceCode"/>
			<memberdata name="getfilesinpath" display="GetFilesInPath"/>
			<memberdata name="getlastword" display="GetLastWord"/>
			<memberdata name="getlineno" display="GetLineNo"/>
			<memberdata name="getlinestoprocess" display="GetLinesToProcess"/>
			<memberdata name="getmemosize" display="GetMemoSize"/>
			<memberdata name="getnextproject" display="GetNextProject"/>
			<memberdata name="getnumberedline" display="GetNumberedLine"/>
			<memberdata name="getrandomtext" display="GetRandomText"/>
			<memberdata name="getrecordsindbf" display="GetRecordsInDBF"/>
			<memberdata name="getthorfiles" display="GetThorFiles"/>
			<memberdata name="highlightcurrentline" display="HighlightCurrentLine"/>
			<memberdata name="listdescript" display="ListDescript"/>
			<memberdata name="listfiles" display="ListFiles"/>
			<memberdata name="readclasslibs" display="ReadClassLibs"/>
			<memberdata name="removeprocendproc" display="RemoveProcEndproc"/>
			<memberdata name="replacecurrentline" display="ReplaceCurrentLine"/>
			<memberdata name="returnunknowncommand" display="ReturnUnknownCommand"/>
			<memberdata name="runed" display="RunEd"/>
			<memberdata name="runprogram" display="RunProgram"/>
			<memberdata name="scanallwindows" display="ScanAllWindows"/>
			<memberdata name="showcase" display="ShowCase"/>
			<memberdata name="tryexecute" display="TryExecute"/>
			<memberdata name="writecurrentline" display="WriteCurrentLine"/>
			<memberdata name="cdescriptionmask1" display="cDescriptionMask1"/>
			<memberdata name="cdescriptionmask2" display="cDescriptionMask2"/>
			<memberdata name="coption" display="cOption"/>
			<memberdata name="removedoublecharacter" display="RemoveDoubleCharacter"/>
			<memberdata name="cfilter" display="cFilter" favorites="True"/>
			<memberdata name="gethelptopics" display="GetHelpTopics"/>
			<memberdata name="getlastfile" display="GetLastFile"/>
			<memberdata name="getnextfile" display="GetNextFile"/>
			<memberdata name="getadditionalfiles" display="GetAdditionalFiles"/>
			<memberdata name="ozipinit" display="oZipInit"/>
			<memberdata name="getfilelisttoprocess" display="GetFilelistToProcess"/>
			<memberdata name="getextensioncursor" display="GetExtensionCursor"/>
			<memberdata name="dir2dt" display="Dir2dt"/>
			<memberdata name="getlastcharacter" display="GetLastCharacter"/>
			<memberdata name="oeditorwininit" display="oEditorWinInit"/>
			<memberdata name="addextension" display="AddExtension"/>
			<memberdata name="givemessage" display="GiveMessage"/>
			<memberdata name="getsortabledate" display="GetSortableDate"/>
			<memberdata name="readregistryoption" display="ReadRegistryOption"/>
			<memberdata name="cutandgivemessage" display="CutAndGiveMessage"/>
			<memberdata name="changesidekickfile" display="ChangeSidekickFile"/>
			<memberdata name="checkorcreatesidekickfile" display="CheckOrCreateSidekickFile"/>
			<memberdata name="findskoptions" display="FindSKOptions"/>
			<memberdata name="runsidekickline" display="RunSidekickLine"/>
			<memberdata name="findswitch" display="FindSwitch"/>
			<memberdata name="notes" display="Notes"/>
			<memberdata name="addoption" display="AddOption"/>
			<memberdata name="listusedtables" display="ListUsedTables"/>
			<memberdata name="dropfieldifempty" display="DropFieldIfEmpty"/>
			<memberdata name="decodetimestamp" display="DecodeTimeStamp"/>
			<memberdata name="closeopenedtables" display="CloseOpenedTables"/>
			<memberdata name="cmrutable" display="cMRUTable"/>
			<memberdata name="handlemrutable" display="HandleMRUTable"/>
			<memberdata name="cdefaultcommand" display="cDefaultCommand"/>
			<memberdata name="fixpath" display="FixPath"/>
			<memberdata name="lnomessage" display="lNoMessage"/>
			<memberdata name="cskfile" display="cSKFile"/>
			<memberdata name="ctabletokeepopen" display="cTableToKeepOpen"/>
			<memberdata name="getfieldcount" display="GetFieldCount"/>
			<memberdata name="readoptions" display="ReadOptions"/>
			<memberdata name="indexiffield" display="IndexIfField"/>
			<memberdata name="dobrowmodal" display="DoBrowModal"/>
			<memberdata name="skfactory" display="SKFactory"/>
			<memberdata name="ctestarea" display="cTestArea"/>
			<memberdata name="splitcommand" display="SplitCommand"/>
			<memberdata name="nlastwindow" display="nLastWindow"/>
			<memberdata name="linputbox" display="lInputBox"/>
			<memberdata name="ainerror" display="aInError"/>
			<memberdata name="calias" display="cAlias"/>
			<memberdata name="getmethodfromprg" display="GetMethodFromPrg"/>
			<memberdata name="lefttrimcode" display="LeftTrimCode"/>
			<memberdata name="ldelete" display="lDelete"/>
			<memberdata name="addfield" display="AddField"/>
			<memberdata name="getfilesinfolder" display="GetFilesInFolder"/>
			<memberdata name="lclosetables" display="lCloseTables"/>
			<memberdata name="executehighlight" display="ExecuteHighlight"/>
			<memberdata name="openiffile" display="OpenIfFile"/>
			<memberdata name="getmethdosfromclasslib" display="getMethdosFromClasslib"/>
			<memberdata name="getfilesandsubfolders" display="GetFilesAndSubfolders"/>
			<memberdata name="indexfields" display="IndexFields"/>
			<memberdata name="iscursor" display="isCursor"/>
			<memberdata name="istag" display="isTag"/>
			<memberdata name="addskextensions" display="addSKExtensions"/>
			<memberdata name="ccaption" display="cCaption"/>
			<memberdata name="isinteger" display="isInteger"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'lblSidekick' AS label WITH ;
		Caption = "Sidekick", ;
		FontSize = 12, ;
		ForeColor = 255,0,0, ;
		Height = 37, ;
		Left = 12, ;
		Name = "lblSidekick", ;
		Top = 12, ;
		Width = 169
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE addextension
		Lparameters tcString, tcItem, tcSource
		
		Local lcNewFile, lcString
		
		lcString = m.tcString
		lcNewFile = Forceext(m.tcSource, m.tcItem)
		Do Case
		  Case m.tcItem + [,] $ m.tcString
		  Case [,] + m.tcItem $ m.tcString
		  Case !File(m.lcNewFile)
		  Case Empty(m.tcString)
		    lcString = m.tcItem
		  Otherwise
		    lcString = Rtrim(m.tcString, 0, [,]) + [,] + m.tcItem
		Endcase
		Return m.lcString
	ENDPROC

	PROCEDURE addfield
		Lparameters tcTable, tcFieldname, tcType
		Local lcCode, lcCursor, lxDummy
		
		#Define crlf Chr(13)+Chr(10)
		tcType = Evl(m.tcType, [l])
		tcType = Lower(m.tcType)
		lcCursor = [cur] + Sys(2015)
		Do Case
		  Case m.tcType = [l]
		    lxDummy = [.F.]
		  Case Inlist(Left(m.tcType, 1), [m], [c])
		    lxDummy = ['']
		  Case Inlist(Left(m.tcType, 1), [i], [n], [y])
		    lxDummy = 0
		  Otherwise
		    lxDummy = ['']
		Endcase
		Text To m.lcCode Noshow Textmerge Pretext 1 + 2 + 4
		  select *, Cast(<<m.lxDummy>> As <<m.tcType>>) As <<m.tcFieldname>> From <<m.tcTable>> Into Cursor <<m.lcCursor>> Readwrite
		  Use In <<m.tcTable>>
		  Select * From <<m.lcCursor>> Into Cursor <<m.tcTable>> Readwrite
		  Use In <<m.lcCursor>>
		Endtext
		Execscript(m.lcCode)
		
		
	ENDPROC

	PROCEDURE addlinesandtext
		Local lnMemo
		
		lnMemo = Set([Memowidth])
		Set Memowidth To 8192
		Scan For Inlist(Lower(Justext(Filename)), [prg], [txt], [h], [sk])
		  Try
		    Replace Text With Filetostr(Alltrim(FullName))
		    Replace LineS With Memlines(Text)
		  Catch
		  Endtry
		Endscan
		Set Memowidth To m.lnMemo
		
		
	ENDPROC

	PROCEDURE addoption
		Lparameters tcCharacter
		tcCharacter = Evl(m.tcCharacter, [])
		Do Case
		  Case Left(m.tcCharacter, 1) == [-] And Len(m.tcCharacter) = 2
		    tcCharacter = Substr(m.tcCharacter, 2)
		    This.cOption = Chrtran(This.cOption, m.tcCharacter, [])
		  Case !m.tcCharacter $ This.cOption
		    This.cOption = This.cOption + m.tcCharacter
		Endcase
		
	ENDPROC

	PROCEDURE addskextensions
		Local lcAlias, lcCommand, lcCursor, lcDescript, lnSelect
		
		lcAlias = Alias()
		lnSelect = Select()
		lcCursor = [curSkExt]
		This.GetFilesInPath([sk_*.prg], m.lcCursor, .T. )
		Select Cast(Juststem(Strextract(Filename, [sk_], [], 1, 1)) As c(20)) As Command, Cast(This.GetDescript(Filename) As c(50)) As Descript From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite
		Scan
		  lcCommand = Upper(Command)
		  lcDescript = Descript
		  lcDescript = Evl(m.lcDescript, [* Missing description in .prg *])
		  Update (m.lcAlias) Set Descript = m.lcDescript, url = [Override] Where Upper(Command) == m.lcCommand
		  If _Tally = 0
		    Insert Into (m.lcAlias) (Command, Descript, url) Values (m.lcCommand, m.lcDescript, [Private])
		  Endif
		Endscan
		Select (m.lnSelect)
		
	ENDPROC

	PROCEDURE changesidekickfile
		Local lcContent, lcCurrent, lcDescript, lcFile, lcFilename, lcFolder, lcParameter, lcText, lnFiles
		Local lnLines, lnX
		
		Local Array laDummy[1]
		Local Array laFiles[1]
		
		lcFile =  This.cSidekickFile
		
		lcParameter = This.cParameter
		If Directory([text])
		  lcFolder = [text]
		Else
		  lcFolder = []
		Endif
		
		If Inlist(m.lcParameter, [*], [-], [+], [/] )
		  lnFiles = Adir(laFiles, Forcepath([*.sk], m.lcFolder), [], 1)
		  Do Case
		    Case m.lnFiles = 0
		      lcFile = [sidekick.sk]
		    Case m.lnFiles = 1
		      lcFile = ForcePath(m.laFiles(1, 1),m.lcFolder)
		    Otherwise
		      Select 0
		      Create Cursor curSKFiles (Current c(6), Filename c(25), Date T, Size i, LineS i, Descript c(50), Content m)
		      For lnX = 1 To m.lnFiles
		        lcFilename = ForcePath( Trim(Lower(m.laFiles(m.lnX, 1))),m.lcFolder)
		        If JustFname(m.lcFilename) == Lower(This.cSidekickFile)
		          lcCurrent = [Now ->]
		        Else
		          lcCurrent = []
		        Endif
		        lcContent = Filetostr(m.laFiles(m.lnX, 1))
		        lnLines = Alines(laDummy, m.lcContent)
		        lcDescript = This.GetDescript(m.lcFilename)
		        Insert Into curSKFiles (Current, Filename, Date, Size, LineS, Descript, Content) ;
		          Values (m.lcCurrent, ForcePath(Lower(m.laFiles(m.lnX, 1)),m.lcFolder), dir2dt(m.laFiles(m.lnX, 4), m.laFiles(m.lnX, 3)), m.laFiles(m.lnX, 2), m.lnLines, m.lcDescript, m.lcContent )
		      Endfor
		      This.IndexFields()
		      Set Order To Date Descending
		      lcFile = ForcePath(This.GetDataFromGrid(Textmerge([New <<this.cProgram>> file (current is <<this.cSidekickFile >>):]), [Filename]),m.lcFolder)
		  Endcase
		Else
		  If !Empty(This.cParameter)
		    lcFile = ForcePath(Forceext(This.cParameter, [sk]),m.lcFolder)
		  Endif
		  If !File(m.lcFile)
		    If This.GiveMessage([Specified file "] + m.lcFile + [" doesn't exist, create empty file?], 4, [File not found!]) = 6
		      Text To m.lcText Noshow Textmerge Pretext 7
		          Default group: 0
		          *************************
		      Endtext
		      Strtofile(m.lcText, m.lcFile )
		      Modify Command (m.lcFile) Nowait
		    Else
		      lcFile = []
		    Endif
		  Endif
		Endif
		If !Empty(m.lcFile)
		  This.cSidekickFile = JustFname(m.lcFile)
		  Execscript(_Screen.cThorDispatcher, [Set Option=], [Project], [SideKick], JustFname(m.lcFile)  )
		  _Screen.oSKOptions.cProject = JustFname( m.lcFile)
		Endif
		This.CutAndGiveMessage(Textmerge([Active "<<this.cProgram>>" project file is <<This.cSidekickFile>>]), 64, This.cProgram, This.nTimeOut )
		
		
	ENDPROC

	PROCEDURE checkorcreatesidekickfile
		Local lcText
		
		If File(This.cSidekickFile )
		  Return .T.
		Else
		  lcFile = This.cSidekickFile
		  If Directory('text')
		    m.lcFile = ForcePath(m.lcFile, 'text')
		  Endif
		  If This.GiveMessage(Textmerge([Specified file "<<this.cSidekickFile>>" doesn't exist, create empty file?]), 4, [File not found!]) = 6
		    Text To m.lcText Noshow Textmerge Pretext 7
		        Default group: 0
		        *************************
		    Endtext
		    Strtofile(m.lcText, m.lcFile)
		    Modify Command (m.lcFile ) Nowait
		  Endif
		  Return .F.
		Endif
		
		
	ENDPROC

	PROCEDURE closeopenedtables
		Local lcTable, lnTables, lnX
		
		Local Array laTablesOpen[1]
		
		If Vartype(This.aInUse(1)) = [L]
		  Return
		Endif
		Use In (Select(This.cCursor))
		
		lnTables = Aused(laTablesOpen)
		For lnX = 1 To m.lnTables
		  lcTable = m.laTablesOpen(m.lnX, 1)
		  If !Empty(m.lcTable);
		      And !(m.lcTable == Upper(This.cTableSelected));
		      And Ascan(This.aInUse,  m.lcTable, -1, -1, 1, 7) = 0;
		      And ! Lower(m.lcTable) == This.cTableToKeepOpen
		    Use In (m.lcTable)
		  Endif
		Endfor
		
		
	ENDPROC

	PROCEDURE createcommentline
		Local lcReturn, lcString, lcX, lnMax, lnX
		
		lnX = This.FindValueInString(This.cCommand )
		lnMax = 250
		lcX = Transform(m.lnX)
		lcString = Left(This.cCommand, At(Transform(m.lnX), This.cCommand ) - 1)
		lnX = Min(m.lnX, m.lnMax )
		Do Case
		  Case Len(m.lcString) > 2 And Right(m.lcString, 1) = [*]
		    lcString = Substr(This.cCommand, 2, Len(m.lcString) - 2)
		    lcReturn = [*] + Replicate(m.lcString, Int( (m.lnX - 2) / Len(m.lcString))) + [*]
		  Case Len(m.lcString) = 2 And [:] $ m.lcString
		    lcReturn = Replicate([her], m.lnX)
		  Otherwise
		    lcReturn = Replicate(m.lcString, Min(m.lnX / Len(m.lcString), m.lnMax ))
		Endcase
		This.ReplaceCurrentLine(m.lcReturn)
		
		
	ENDPROC

	PROCEDURE cutandgivemessage
		Lparameters tcMessage, tnDialog, tcTitle, tnTimeOut
		If This.nWindowType = 0
		  This.CutCurrentLine()
		Endif
		This.GiveMessage(m.tcMessage, m.tnDialog, m.tcTitle, m.tnTimeOut)
	ENDPROC

	PROCEDURE cutcurrentline
		Local lcClip, lcText
		
		If !This.lNoInterface And !This.lInputBox
		  If Vartype(This.oEditorWin) # [O]
		    This.oEditorWinInit()
		  Endif
		  lcClip = _Cliptext
		  This.HighlightCurrentLine()
		  If This.nWindowType < 0
		    Return []
		  Endif
		  This.oEditorWin.Copy()
		  lcText = _Cliptext
		  _Cliptext = m.lcClip
		  This.oEditorWin.Cut()
		  Return m.lcText
		Endif
		
		
		
	ENDPROC

	PROCEDURE decodetimestamp
		Parameter tnStamp
		
		#Define SecondsMask 15  && 00001111
		#Define MinutesMask 63  && 00111111
		#Define HoursMask   31  && 00011111
		#Define DaysMask    31  && 00011111
		#Define MonthsMask  15  && 00001111
		#Define YearsMask   63  && 00111111
		
		#Define SecondsOffset 1  && Note this is a LEFT shift, not RIGHT
		#Define MinutesOffset 5
		#Define HoursOffset   11
		#Define DaysOffset    16
		#Define MonthsOffset  21
		#Define YearsOffset   25
		
		#Define fMonth       Bitand(Bitrshift(tnStamp,MonthsOffset ),MonthsMask)
		#Define fDay         Bitand(Bitrshift(tnStamp,DaysOffset   ),DaysMask)
		#Define fYear   1980+Bitand(Bitrshift(tnStamp,YearsOffset  ),YearsMask)
		#Define fHour        Bitand(Bitrshift(tnStamp,HoursOffset  ),HoursMask)
		#Define fMinute      Bitand(Bitrshift(tnStamp,MinutesOffset),MinutesMask)
		#Define fSecond      Bitand(Bitlshift(tnStamp,SecondsOffset),SecondsMask)
		Local ltReturn
		
		ltReturn = Iif(m.tnStamp = 0, {//::}, ;
		    Datetime(fYear, fMonth, fDay, fHour, fMinute, fSecond))
		Return m.ltReturn
	ENDPROC

	PROCEDURE Destroy
		If This.lCloseTables
		  This.CloseOpenedTables()
		Endif
		Do Case
		  Case !This.lCloseTables
		    Select (This.nSelect)
		  Case !Empty(This.cTableToKeepOpen)
		    Select (This.cTableToKeepOpen)
		  Case !This.lNoSelectOnExit
		    Select (This.nSelect)
		Endcase
		Clear Error
		If This.cExact = [ON]
		  Set Exact On
		Endif
		_Cliptext = This.cClip
		Set Point To This.Cpoint
		
	ENDPROC

	PROCEDURE dir2dt
		Lparameters tcTime, ttDate
		Local lnDay, lnHour, lnMin, lnMonth, lnSec, lnYear
		
		lnSec = Val(Strextract(m.tcTime, [:], [], 2))
		lnMin = Val(Strextract(m.tcTime, [:], [:], 1))
		lnHour = Val(Strextract(m.tcTime, [], [:]))
		lnDay = Day(m.ttDate)
		lnMonth = Month(m.ttDate)
		lnYear = Year(m.ttDate)
		Return Datetime(m.lnYear, m.lnMonth, m.lnDay, m.lnHour, m.lnMin, m.lnSec)
	ENDPROC

	PROCEDURE dobrowmodal
		Lparameters tcValues
		Local loPg As pg Of THOR_PROC_Sidekick.vcx
		Local lcParameter, lcProcess
		
		If !Empty(Dbf())
		  If Reccount() > 0
		    tcValues = Evl(m.tcValues, [])
		    If [w] $ This.cOption
		      tcValues = m.tcValues + [W]
		    Endif
		    lcParameter = [10UZF] + m.tcValues
		    lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		    loPg = Newobject([pg], m.lcProcess, [], m.lcParameter)
		    loPg.FontSize = This.nFontSize
		    If Empty(this.cCaption)
		      If [w] $ This.cOption
		        loPg.Caption = Alltrim(m.loPg.Caption) + [ (R/W)] && + Transform(Reccount()) + [ records)]
		      Else
		        loPg.Caption = Alltrim(m.loPg.Caption) + [ (R/O)] &&+ Transform(Reccount()) + [ records)]
		      EndIf
		    Else 
		      lopg.Caption = this.cCaption 
		    Endif
		    m.loPg.Show(1)
		  Else
		    this.GiveMessage('This table have no records!')
		  Endif
		    
		Endif
		
		
	ENDPROC

	PROCEDURE dropfieldifempty
		Lparameters tcField, tcCursor
		
		Local lcCurTemp, lcField, lcFields, llDrop, lnWord, lnX
		
		tcCursor = Evl(m.tcCursor, This.cCursor)
		
		lcCurTemp = m.tcCursor + [tmp]
		
		For lnWord = 1 To Getwordcount(m.tcField, [,])
		  lcField = Getwordnum(m.tcField, m.lnWord, [, ])
		
		  If !Empty(Field(m.lcField, m.tcCursor))
		    Select (m.tcCursor)
		    llDrop = .T.
		    Scan
		      If !Empty(Evaluate(m.lcField))
		        llDrop = .F.
		        Exit
		      Endif
		    Endscan
		    If m.llDrop
		      lcFields = []
		      For lnX = 1 To Fcount()
		        If Lower(Field(m.lnX)) # Lower(m.lcField)
		          lcFields = m.lcFields + Field(m.lnX) + [,]
		        Endif
		      Endfor
		      lcFields = Trim(m.lcFields, 0, [,], Chr(32))
		      Select &lcFields From (m.tcCursor) Into Cursor (m.lcCurTemp ) Readwrite
		      Use In (Select(m.tcCursor))
		      Select * From (m.lcCurTemp) Into Cursor (m.tcCursor) Readwrite
		      Use In (Select(m.lcCurTemp))
		    Endif
		  Endif
		Endfor
		
	ENDPROC

	PROCEDURE executehighlight
		Local llSuccess
		
		llSuccess = .F.
		If Memlines(This.cParcedText) > 1
		  Try
		    llSuccess  = Execscript(_Screen.cThorDispatcher, [thor_tool_repository_executehighlighted], [] )
		    *!*      llSuccess = ExecScript(this.cParcedText)
		  Catch
		  Endtry
		Endif
		Return m.llSuccess
		
	ENDPROC

	PROCEDURE findcommand
		Local lcParced
		
		If Inlist(This.nWindowType, 0, 1)
		  This.cParcedText = Trim(This.cParcedText, 0, Chr(10), Chr(13))
		  If Getwordnum(This.cParcedText, 1) == This.cCommentString
		    This.cParcedText = Ltrim(Substr(This.cParcedText, Len(This.cCommentString) + 1))
		  Endif
		
		  If Getwordcount(This.cParcedText) = 1 And This.FindValueInString(Getwordnum(This.cParcedText, 1)) = 0
		    Do While Left(This.cParcedText, 1) == [*] And This.nWindowType = 1 And ![:] $ Getwordnum(This.cParcedText, 1)
		      This.cParcedText = Ltrim(Substr(This.cParcedText, 2))
		    Enddo
		  Endif
		  If This.cTitle = This.cSidekickFile
		    Do Case
		      Case Empty(Chrtran(Getwordnum(This.cParcedText, 1), [*], []))  And This.FindValueInString(Getwordnum(This.cParcedText, 2)) > 0
		        This.cParcedText = Strextract(This.cParcedText, [ ], [], 2)
		      Case Getwordcount(This.cParcedText) > 1 And This.FindValueInString(Getwordnum(This.cParcedText, 1)) > 0
		        This.cParcedText = Strextract(This.cParcedText, [ ], [], 1)
		      Otherwise
		    Endcase
		  Endif
		  If Isdigit(Getwordnum(This.cParcedText, 1)) And This.cTitle = This.cSidekickFile
		    This.cParcedText = Ltrim(Substr(This.cParcedText, Len(Getwordnum(This.cParcedText, 1)) + 1))
		  Endif
		Endif
		lcParced = Lower(This.cParcedText)
		If [no] $ m.lcParced And Getwordnum(m.lcParced, 1) # [no] And ([=no ] $ m.lcParced Or [ = no] $ m.lcParced)
		  This.cParcedText = [no ] + Getwordnum(m.lcParced, 1, [= ]) + [=] + Getwordnum(m.lcParced, 3, [= ])
		Endif
		
		This.cCommand = Getwordnum(This.cParcedText, 1)
		This.nValCommand = This.FindValueInString(This.cCommand )
		This.cCommand = Trim(This.cCommand, 0, Chr(13), Chr(10))
		
		This.cCommandOriginal = This.cCommand
		This.cCommand = Lower(This.cCommand)
		
		
	ENDPROC

	PROCEDURE findfile
		Lparameters tcFile, tcFilter
		Local lcFile, lcPath, lcReturn, lnFiles, lnX
		
		Local Array laFiles[1]
		
		If Empty(m.tcFilter)
		  tcFilter = ['dbf','vcx','scx','prg','txt','sk']
		Endif
		lcPath = Justpath(m.tcFile)
		lcFile = []
		lcReturn = []
		Do Case
		  Case Adir(laFiles, m.tcFile) = 1
		    lcFile = m.tcFile
		  Case !Empty(m.lcPath)
		    If Empty(Justext(m.tcFile))
		      lnFiles = Adir(laFiles, Forceext(m.tcFile, [*]), [], 1)
		      If m.lnFiles > 1
		        For lnX = 1 To m.lnFiles
		          If Inlist(Lower(Justext(m.laFiles(m.lnX, 1))),&tcFilter)
		            lcFile = m.laFiles(m.lnX, 1)
		            Exit
		          Endif
		        Endfor
		      Endif
		    Else
		    Endif
		  Otherwise
		    Wait Window [some other case... Must be handled]
		Endcase
		If !Empty(m.lcFile)
		  lcReturn = This.FixPath(m.lcFile)
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE findfunction
		Local lcParameter, llSuccess
		
		Local Array laDummy[1]
		
		If Pemstatus(_Screen, [lTest], 5) And _Screen.lTest
		  Set Step On
		Endif
		llSuccess = .F.
		Do Case
		  Case Inlist(This.cCommand, [*], [#])
		  Case This.cCommand == [?]
		  Case This.cCommand == [??]
		  Case Left(This.cCommand,1) == [!] and File(ForceExt('sk_' + GetWordNum(this.cCommand,1,'!')  ,'prg'))
		  Case Left(This.cCommand,2) == [!!]
		  Case Left(This.cCommand, 1) = [=] And This.nWindowType > 0
		  Case this.isInteger(this.cCommand)
		  Case File(Forceext( [sk_] + This.cCommand, [prg]))
		    _screen.AddProperty('oSidekick',this)
		    If Empty(This.cParameter)
		      Do (Forceext( [sk_] + This.cCommand, [prg]))
		    Else
		      Do (Forceext( [sk_] + This.cCommand, [prg])) With (This.cParameter)
		    EndIf
		    _screen.oSidekick = .null.
		    Return
		  Otherwise
		    Try
		      Execscript(This.cParcedText)
		      llSuccess = .T.
		      This.lCloseTables = .F.
		    Catch
		    Endtry
		    If m.llSuccess
		      Return
		    Endif
		EndCase
		
		_screen.AddProperty('lLog',.T.)
		
		Do Case
		  Case Len(Trim(This.cParcedText)) > 3 And Left(This.cParcedText, 3) = [???]
		  Case Len(Trim(This.cParcedText)) > 2 And Left(This.cParcedText, 2) = [??]
		  Case Len(Trim(This.cParcedText)) > 1 And Left(This.cParcedText, 1) = [?] And Left(This.cParcedText, 2) # [?=] And Left(This.cParcedText, 2) # [??]
		  Case Alines(laDummy, This.cParcedText) > 1
		  Case Left(This.cCommand, 1) = [*] And This.nWindowType = 1
		  Case Left(This.cCommand ,1) == '-' And This.cCommand = Transform(Val(This.cCommand ))
		  Otherwise
		    This.SplitCommand()
		Endcase
		
		If This.lInputBox And Inlist(This.cCommand, [es]) And This.nWindowType = 2
		  This.ReturnUnknownCommand(1)
		  Return
		Endif
		Do Case
		  Case This.OpenIfFile()
		  Case This.SKFactory()
		  Case This.FindSKOptions()
		  Case Left(This.cCommand, 1) = [*] And This.nValCommand > 0 And Empty(This.cParameter)
		    This.CreateCommentLine()
		  Case Left(This.cCommand, 1) = [*] And Val(This.cParameter) > 0 And This.cParameter == Transform(This.cParameter)
		    This.cCommand = This.cCommand + This.cParameter
		    This.cParameter = []
		    This.CreateCommentLine()
		  Case Left(This.cCommand, 4) = [http]
		    This.RunEd(This.cParcedText)
		  Case Left(This.cParameter, 4) = [http]
		    This.RunEd(This.cParameterOriginal )
		
		  Case Val(This.cCommand) # 0 And (Isdigit(This.cCommand) or left(this.cCommand,1) == '-') And This.cCommand = Transform(Val(This.cCommand )) And Empty(This.cParameter ) 
		    This.GetLinesToProcess(Val(This.cCommand))
		  Case this.isInteger(This.cCommand ) And !Empty(This.cParameter ) And Inlist(This.nWindowType, 1, 2)
		    This.RunEd(This.cParameter)
		  Case this.isInteger(This.cCommand ) And !Empty( This.cParameter) ;
		      And Inlist(Getwordnum( This.cParameter, 1), [do], This.cRun ) And  Inlist(This.nWindowType, 1, 2, -1)
		    If Getwordnum(This.cParameter, 1) = This.cRun
		      lcParameter = Strextract(This.cParameter, This.cRun, [])
		    Else
		      lcParameter = This.cParameter
		    Endif
		    If This.TryExecute( )
		      Return
		    Endif
		  Case Left(This.cCommand, 1) = [*] And Isdigit(Substr(This.cCommand, 2, 1)) And Getwordnum(This.cParameter, 1) = This.cRun
		    Try
		      Execscript(Substr(This.cParameter, 4))
		    Catch
		      This.ReturnUnknownCommand()
		    Endtry
		  Case Left(This.cParcedText, 1) = [*] And Isdigit(Getwordnum(This.cParameter, 1)) And Getwordnum(This.cParameter, 2) = This.cRun
		    Try
		      Execscript(Substr(This.cParameter, Len(Getwordnum( This.cParameter, 1)) + 6))
		    Catch
		      This.ReturnUnknownCommand()
		    Endtry
		  Otherwise
		    Try
		      Execscript(This.cParcedText)
		    Catch
		      This.GiveMessage([Unknown instruction!])
		    Endtry
		Endcase
	ENDPROC

	PROCEDURE findparameters
		If Inlist(This.cCommand, [eval], [=]) And .F. && Why this line?
		  Return
		Endif
		This.cParameter = Ltrim(Strextract(This.cParcedText, This.cCommand, [], 1, 1))
		If At([&] + [&], This.cParameter) > 0
		  This.cParameter = Trim(Strextract(This.cParameter, [], [&] + [&]))
		Endif
		If Left(This.cParameter, 1) = [(]
		  This.cParameter = Lower(This.FindFile(Evaluate(This.cParameter)))
		Endif
		This.cParameterOriginal = Trim(This.cParameter, 0, Chr(13), Chr(0))
		This.cParameterOriginal = Chrtran(This.cParameterOriginal, [|], [ ])
		This.cParameter = Lower(This.cParameterOriginal)
		
		
	ENDPROC

	PROCEDURE findskoptions
		* Procession of project files, single lines
		If Inlist(This.nWindowType, 1, 2) And Lower(Justext(This.cTitle)) = [sk]
		  Do Case
		    Case Isdigit(This.cCommand ) And This.cCommand = Transform(Val(This.cCommand )) And !Empty(This.cParameter )
		      This.RunEd(This.cParameter)
		    Case This.cCommand = This.cCommentString And Isdigit(This.cParameter ) And This.cParameter = Transform(Val(This.cParameter)) And Getwordcount(This.cParameter ) > 1
		      This.RunEd(Strextract( This.cParameter, [ ], [], 1))
		    Case .F.
		    Otherwise
		      Return .F.
		  Endcase
		Else
		  Return .F.
		Endif
		
	ENDPROC

	PROCEDURE findswitch
		#Define ccDummy ''
		Local lcCharacter, lnPos, lnX
		
		This.cParcedText = Strtran(This.cParcedText, [//], ccDummy)
		lnX = 1
		Do While .T.
		  lnPos = At([/], This.cParcedText, m.lnX )
		  If m.lnPos > 0
		    lcCharacter = Substr(This.cParcedText, m.lnPos + 1, 1 )
		    Do Case
		      Case Empty(m.lcCharacter)
		        Exit
		      Case Isalpha(m.lcCharacter)
		        If Inlist(Substr(This.cParcedText, m.lnPos + 2, 1), [ ], [/]) Or Len(This.cParcedText) = m.lnPos + 1
		          This.AddOption(m.lcCharacter)
		          This.cParcedText = Strtran(This.cParcedText, [/] + m.lcCharacter, [])
		        Else
		          lnX = m.lnX + 1
		        Endif
		      Case m.lcCharacter == [-]
		        If Inlist(Substr(This.cParcedText, m.lnPos + 3, 1), [ ], [/]) Or Len(This.cParcedText) = m.lnPos + 2
		          lcCharacter = Substr(This.cParcedText, m.lnPos + 2, 1 )
		          This.AddOption([-] + m.lcCharacter)
		          This.cParcedText = Strtran(This.cParcedText, [/-] + m.lcCharacter, [])
		        Else
		          lnX = m.lnX + 1
		        Endif
		    Endcase
		  Else
		    Exit
		  Endif
		Enddo
		This.cParcedText = Strtran(This.cParcedText, ccDummy, [//])
		
		
	ENDPROC

	PROCEDURE findvalueinstring
		Lparameters tcText
		Local lnReturn, lnX
		
		lnReturn = 0
		For lnX = 1 To Len(Trim(m.tcText))
		  If Val(Substr(m.tcText, m.lnX, 1)) > 0
		    lnReturn = Val(Substr(m.tcText, m.lnX))
		    Exit
		  Endif
		Endfor
		Return Int(m.lnReturn)
		
		
	ENDPROC

	PROCEDURE fixpath
		Lparameters tcFile, tcPath
		tcPath = Evl(m.tcPath, Curdir())
		Do Case
		  Case [f] $ This.cOption
		    tcFile = Fullpath(m.tcFile)
		  Case [j] $ This.cOption
		    tcFile = Justfname( m.tcFile)
		  Case [r] $ This.cOption Or This.cPathReturned = [r] && relative
		    tcFile = Sys(2014, m.tcFile, m.tcPath )
		  Case This.cPathReturned = [f] && full
		    tcFile = Fullpath(m.tcFile)
		  Otherwise && no path
		    tcFile = Justfname(m.tcFile)
		Endcase
		Return m.tcFile
	ENDPROC

	PROCEDURE getadditionalfiles
		Lparameters tcSource
		Local lcExtension, lnX
		
		Local Array laDummy[1]
		
		This.GetExtensionCursor()
		lcExtension = Lower(Justext(m.tcSource))
		This.cExtensionList = m.lcExtension
		
		If  !This.lAddExtraExtensions
		  Select ext1, extra From curExtensions Where ext2 = m.lcExtension And !extra Into Array laDummy
		Else
		  Select ext1, extra From curExtensions Where ext2 = m.lcExtension Into Array laDummy
		Endif
		If _Tally > 0
		  lcExtension = m.laDummy
		  This.cExtensionList = This.AddExtension(This.cExtensionList, m.lcExtension, m.tcSource  )
		Endif
		Select ext2 From curExtensions Where ext1 = m.lcExtension And !extra Into Array laDummy
		If _Tally > 0
		  For lnX = 1 To Alen(m.laDummy, 1)
		    This.cExtensionList = This.AddExtension(This.cExtensionList, m.laDummy(m.lnX), m.tcSource )
		  Endfor
		Endif
		Select ext2 From curExtensions Where ext1 = m.lcExtension And extra = This.lAddExtraExtensions Into Array laDummy
		If _Tally > 0
		  For lnX = 1 To Alen(m.laDummy, 1)
		    This.cExtensionList = This.AddExtension(This.cExtensionList, m.laDummy(m.lnX), m.tcSource )
		  Endfor
		Endif
		
		Return This.cExtensionList
		
	ENDPROC

	PROCEDURE getallfiles
		Lparameters tcDirectory, laFiles, tcMask
		
		Local lcFile, lcOldDir, lnCount, lnLen, lnMax
		
		Local Array laTemp[1, 5]
		
		tcMask = Evl(m.tcMask, [*.*])
		lcOldDir = Fullpath(Curdir())
		
		If Empty(m.tcDirectory)
		  tcDirectory = m.lcOldDir
		Endif
		Set Default To (m.tcDirectory)
		= Adir(laTemp, [*.*], [AHRSD], 1)
		lnMax = Alen(m.laTemp, 1)
		For lnCount = 1 To m.lnMax
		  lcFile = Alltrim(m.laTemp(m.lnCount, 1))
		  If !(m.lcFile == [.]) And !(m.lcFile == [..])
		    If [D] $ m.laTemp(m.lnCount, 5)
		      This.GetAllFiles(Addbs(m.tcDirectory + m.lcFile), @m.laFiles)
		    Else
		      lnLen = Alen(m.laFiles)
		      If !Empty(m.laFiles(m.lnLen))
		        Dimension m.laFiles(m.lnLen + 1)
		        lnLen = m.lnLen + 1
		      Endif
		      laFiles(m.lnLen) = m.tcDirectory + m.lcFile
		    Endif
		  Endif
		Endfor
		Set Default To (m.lcOldDir)
		Return Alen(m.laFiles, 1)
		
		
	ENDPROC

	PROCEDURE getdatafromgrid
		Lparameters tcCaption, tcReturnField, tnHideColumns, tlModeless, tcPGParameter
		Local loPg As pg Of THOR_PROC_Sidekick.vcx
		Local lcCurrent, lcF3, lcF4, lcF5, lcFilter, lcHideColumns, lcParameter, lcProcess, lcReturn
		Local lnLastKey, lnModeless
		
		tcCaption = Evl(m.tcCaption, [Testing])
		tcReturnField = Evl(m.tcReturnField, Field(1))
		tnHideColumns = Evl(m.tnHideColumns, 0)
		lnModeless = 1
		tcPGParameter = Evl(m.tcPGParameter, [])
		lcReturn = []
		Wait Clear
		If !Empty(Dbf())
		  If Reccount() = 1
		    If Vartype(Evaluate(m.tcReturnField)) = [N]
		      lcReturn = Trans(Evaluate(m.tcReturnField))
		    Else
		      lcReturn = Alltrim(Evaluate(m.tcReturnField))
		    Endif
		    Return m.lcReturn
		  Else
		
		    lcHideColumns = Replicate([L], Evl(m.tnHideColumns, 0))
		    lcParameter = [1U] + m.lcHideColumns + m.tcPGParameter
		    lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		    loPg = Newobject([pg], m.lcProcess, [], m.lcParameter)
		    If Reccount() < 10
		      lopg.Height = 300
		    Endif
		    loPg.FontSize = This.nFontSize
		    loPg.Caption = Alltrim(m.tcCaption) + [ (] + Transform(Reccount()) + [ records)]
		    loPg.nIncStart = 0
		    loPg.lShowZero = .F.
		    loPg.Icon = Home(4) + [icons\misc\face02.ico]
		    Push Key
		    If !Empty(Field([url]))
		      Declare Integer ShellExecute In shell32.Dll ;
		        Integer hndWin, String cAction, String cFileName, ;
		        String cParams, String cDir, Integer nShowWin
		      On Key Label CTRL+Enter ShellExecute(0, [open], url, [], [], 1)
		    Endif
		    Do Case
		      Case !Empty(This.cFilter) And Lower(This.cFilter) = [include]
		        loPg.Caption = [Select File(s) for processing. Ctrl+Space = select, F3 = select all, F4 = undo all, F5 = reverse]
		        lcFilter = Trim(This.cFilter)
		        Text To m.lcF3 Noshow Textmerge Pretext 1 + 2 + 4
		          lnRecno = Recno()
		          Try
		              Replace all <<m.lcFilter>> with .t.
		          Catch to laDummy
		          endtry
		          Go lnRecno
		        Endtext
		        Text To m.lcF4 Noshow Textmerge Pretext 1 + 2 + 4
		          lnRecno = Recno()
		          try
		            Replace all <<m.lcFilter>> with .f.
		          Catch
		          endtry
		          Go lnRecno
		        Endtext
		        Text To m.lcF5 Noshow Textmerge Pretext 1 + 2 + 4
		          lnRecno = Recno()
		          try
		            Replace all <<m.lcFilter>> with !<<m.lcFilter >>
		          Catch
		          endtry
		          Go lnRecno
		        Endtext
		        On Key Label F2 Replace (m.lcFilter) With !(Evaluate(m.lcFilter))
		        On Key Label CTRL+Spacebar Replace (m.lcFilter) With !(Evaluate(m.lcFilter))
		        On Key Label F3 Execscript(m.lcF3)
		        On Key Label F4 Execscript(m.lcF4)
		        On Key Label F5 Execscript(m.lcF5)
		    Endcase
		    m.loPg.Show(m.lnModeless )
		    If m.lnModeless = 2
		      Read Events
		    Endif
		    Pop Key
		    lnLastKey = Lastkey()
		    If m.lnLastKey = 27 And ! This.lNoMessage  && Escape
		      lcReturn = []
		      If !Inlist(This.cCommand, [ot])
		        This.GiveMessage([Nothing selected!], , , This.nTimeOut)
		      Endif
		    Else
		      If !Inlist(Lastkey(), 97, 33) And !Empty(m.tcReturnField)
		        If !Empty(This.cFilter)
		          lcCurrent = Trim(Evaluate(m.tcReturnField))
		          Scan For Evaluate(This.cFilter)
		            lcReturn = m.lcReturn + Trim(Evaluate(m.tcReturnField)) + [,]
		          Endscan
		          If !Empty(m.lcReturn)
		            lcReturn = Trim(m.lcReturn, [,])
		          Else
		            lcReturn = m.lcCurrent
		          Endif
		        Endif
		        If Empty(m.lcReturn)
		          If Vartype(Evaluate(m.tcReturnField)) = [N]
		            lcReturn = Trans(Evaluate(m.tcReturnField))
		          Else
		            lcReturn = Alltrim(Evaluate(m.tcReturnField))
		          Endif
		        Endif
		      Endif
		    Endif
		  Endif
		Else
		  This.GiveMessage( [No table or cursor is selected], 0 + 48, [Sidekick grid])
		Endif
		Return Alltrim( m.lcReturn)
		
		
	ENDPROC

	PROCEDURE getdatafromurl
		Lparameters tcUrlName
		Local lcRetVal, lhInternetSession, lhUrlFile, llOk, lnBytesRead, lnOK, lsAgent, lsReadBuffer
		
		Declare Integer InternetOpen In wininet.Dll String sAgent, ;
		  Integer lAccessType, String sProxyName, ;
		  String sProxyBypass, Integer lFlags
		Declare Integer InternetOpenUrl In wininet.Dll ;
		  Integer hInternetSession, String sUrl, String sHeaders,;
		  Integer lHeadersLength, Integer lFlags, Integer lContext
		Declare Integer InternetReadFile In wininet.Dll Integer hfile, ;
		  String @sBuffer, Integer lNumberofBytesToRead, Integer @lBytesRead
		Declare short InternetCloseHandle In wininet.Dll Integer hInst
		#Define INTERNET_OPEN_TYPE_PRECONFIG 0
		#Define INTERNET_OPEN_TYPE_DIRECT 1
		#Define INTERNET_OPEN_TYPE_PROXY 3
		#Define SYNCHRONOUS 0
		#Define INTERNET_FLAG_RELOAD 2147483648
		#Define CR Chr(13)
		* what application is using Internet services?
		lsAgent = [VPF 5.0]
		lhInternetSession = InternetOpen( m.lsAgent, INTERNET_OPEN_TYPE_PRECONFIG, ;
		    [], [], SYNCHRONOUS)
		* debugging line - uncomment to see session handle
		* WAIT WINDOW "Internet session handle: " + LTRIM(STR(hInternetSession)) 
		If m.lhInternetSession = 0
		  Wait Window [Internet session cannot be established] Time 2
		  Return .Null.
		Endif
		lhUrlFile = InternetOpenUrl( m.lhInternetSession, m.tcUrlName, [], 0, ;
		    INTERNET_FLAG_RELOAD, 0)
		* debugging line - uncomment to see URL handle 
		* WAIT WINDOW "URL Handle: " + LTRIM(STR(hUrlFile))
		If m.lhUrlFile = 0
		  Wait Window [URL cannot be opened] Timeout 5
		  Return .Null.
		Endif
		lcRetVal = []
		llOk = .T.
		Do While m.llOk
		  * set aside a big buffer
		  lsReadBuffer = Space(32767)
		  lnBytesRead = 0
		  lnOK = InternetReadFile( m.lhUrlFile, @m.lsReadBuffer, Len(m.lsReadBuffer), @m.lnBytesRead)
		  If ( m.lnBytesRead > 0 )
		    lcRetVal = m.lcRetVal + Left( m.lsReadBuffer, m.lnBytesRead )
		  Endif
		  * error trap - either a read failure or read past eof()
		  llOk = ( m.lnOK = 1 ) And ( m.lnBytesRead > 0 )
		Enddo
		* close all the handles we opened
		InternetCloseHandle( m.lhUrlFile )
		InternetCloseHandle( m.lhInternetSession )
		* return the URL contents
		Return m.lcRetVal
		
		
	ENDPROC

	PROCEDURE getdescript
		Lparameters tcFile
		Local lcContents, lcDeleted, lcDescript, lcExt, lnHandle, lnX1
		
		Local Array laDummy[1]
		
		lcDescript = []
		lcExt = Lower(Justext(m.tcFile))
		lcDeleted = Set([Deleted])
		Set Deleted On
		Do Case
		  Case Inlist(m.lcExt, [prg], [sk])
		    lnHandle = Fopen(m.tcFile )
		    For lnX1 = 1 To This.nMaxDescriptLine
		      lcContents = Fgets(m.lnHandle)
		      If Occurs(This.cDescriptionMask1, m.lcContents) > 0
		        lcDescript = Alltrim(Strextract(m.lcContents, This.cDescriptionMask1, This.cDescriptionMask2 ))
		        Exit
		      Endif
		    Endfor
		    Fclose(m.lnHandle)
		Endcase
		If m.lcDeleted = [OFF]
		  Set Deleted Off
		Endif
		Return m.lcDescript
	ENDPROC

	PROCEDURE geteditsourcecode
		Lparameters tnHandle, tnEdType, tcPrefix
		Local lcClassName, lcFilename, lcMethod, lcName, lcObject, lcObjectPath, lcReturn, lcType, lnHandle
		Local lnLineNo, lnVersion, lnWindowType, loE, loFile, loObject, loTools
		
		#Define crlf Chr(13)+Chr(10)
		tcPrefix = Evl(m.tcPrefix, [])
		tnHandle = Evl(m.tnHandle, Val(_Cliptext))
		Store [] To m.lcMethod, m.lcObjectPath, m.lcClassName
		Store 0 To m.lnLineNo, m.lnHandle
		loE = Execscript(_Screen.cThorDispatcher, [Thor_Proc_EditorWin])
		m.loE.SelectWindow(m.tnHandle)
		lnWindowType = m.loE.FindWindow()
		loTools = Execscript (_Screen.cThorDispatcher, [class= tools from pemeditor])
		loObject = m.loTools.GetCurrentObject(.F.)
		If m.lnWindowType > 0
		  lnLineNo = m.loE.GetLineNumber() + 1
		Endif
		loFile = m.loTools.GetCurrentFileName()
		If Vartype(m.loFile) = [L] And .F. && Now, what was this for? :-)
		  Wait Window At 10, 25 [warning]
		  Return []
		Endif
		lnHandle = m.loE.nHandle
		lnVersion = 0
		Do Case
		  Case m.lnWindowType = 0
		    Wait Window [Illegal command!] Timeout 2
		    Return
		  Case Inlist(m.lnWindowType, 1, 2) && Program or file
		    lcFilename = Fullpath(m.loE.GetTitle())
		    If  Left(m.lcFilename, 7) = [PROGRAM] And Empty(Justext(m.lcFilename)) && Modi Comm, not saved
		      Return
		    Endif
		    lcFilename = This.FixPath(m.lcFilename)
		  Otherwise && Method
		    loObject = m.loTools.GetThis()
		    lcObject = [loObject]
		    lcFilename = This.FixPath(m.loFile.Filename)
		    If m.lnHandle > 0
		      lcMethod = m.loE.GetTitle()
		    Endif
		    Do While .T.
		      If Inlist(Type(m.lcObject), [U], [L])
		        Exit
		      Endif
		      If Lower(Justext(m.lcFilename)) = [vcx] And Evaluate(m.lcObject + [.parent.baseclass]) = [Form] And Evaluate(m.lcObject + [.parent.parent.baseclass]) = [Formset]
		        If Pemstatus(Evaluate(m.lcObject + [.parent]), [buffermode], 5) && vcx form
		          lnVersion = 1
		          lcClassName = Evaluate(m.lcObject + [.parent.name])
		        Else && vcx container
		          lnVersion = 2
		          lcClassName = Evaluate(m.lcObject + [.name])
		        Endif
		        Exit
		      Endif
		      lcName = Evaluate(m.lcObject + [.name])
		      If Empty(m.lcMethod)
		        lcMethod = m.lcName
		      Endif
		      If Empty(m.lcObjectPath)
		        lcObjectPath = m.lcName
		      Else
		        lcObjectPath = m.lcName + [.] + m.lcObjectPath
		      Endif
		      lcObject = m.lcObject + [.parent]
		      If Type(m.lcObject + [.parent]) = [U]
		        Exit
		      Endif
		    Enddo
		    If Empty(m.lcClassName)
		      lcClassName = Strextract(m.lcObjectPath, [], [.])
		      lcClassName = Evl(m.lcClassName, m.lcObjectPath)
		    Endif
		    If [.] $ m.lcObjectPath And m.lnVersion # 2
		      lcObjectPath = Strextract(m.lcObjectPath, [.]) && remove first element which is the classname
		    Endif
		Endcase
		Do Case
		  Case Empty(m.lcMethod) And !Inlist(m.lnWindowType, 1, 2)
		    lcReturn = []
		  Case Inlist(Lower(Justext(m.lcFilename)), [txt], [h])
		    lcReturn = Textmerge([<<m.tcPrefix >><<m.lcFilename >>])
		  Case Inlist(m.tnEdType, 2, 4) && Ed or no Ed
		    If m.tnEdType = 4
		      lcType = []
		      If [ ] $ m.lcFilename
		        lcFilename = ['] + m.lcFilename + [']
		      Endif
		    Else
		      lcType = [Ed ]
		    Endif
		    If Occurs([.], m.lcObjectPath) = 0 && Object directly on form
		      lcObjectPath = Juststem(m.lcObjectPath)
		    Endif
		    If !Empty(m.lcObjectPath)
		      If m.lcClassName # m.lcObjectPath
		        lcObjectPath = m.lcClassName + [.] + m.lcObjectPath
		      Endif
		      If [.] $ m.lcMethod && and m.loObject.baseclass = 'Form'
		        lcMethod = Justext(m.lcMethod)
		      Endif
		      Text To m.lcReturn Noshow Textmerge Pretext 1 + 2 + 4
		      <<m.tcPrefix>><<m.lcType >><<m.lcFilename >>.<<m.lcObjectPath >>.<<m.lcMethod>>
		      Endtext
		    Else
		      lcReturn = m.tcPrefix + m.lcType + m.lcFilename
		      If !Empty(m.lcMethod)
		        lcReturn = m.lcReturn + [.] + m.lcMethod
		      Endif
		    Endif
		    If m.lnLineNo > 0
		      lcReturn = m.lcReturn + [:] + Transform(m.lnLineNo)
		    Endif
		  Case m.tnEdType = 1 && EditSource
		    If !Empty(m.lcMethod) And !Empty(m.lcObjectPath ) And m.lcClassName # m.lcObjectPath
		      lcMethod = m.lcObjectPath + [.] + Justext(m.lcMethod )
		    Endif
		    Text To m.lcReturn Noshow Textmerge Pretext 1 + 2 + 4
		      EditSource('<<m.lcFilename>>', <<m.lnLineNo >>,'<<m.lcClassName>>','<<m.lcMethod>>')
		    Endtext
		  Case m.tnEdType = 3 && EditSourceX
		    If !Empty(m.lcMethod) And !Empty(m.lcObjectPath )
		      lcMethod = m.lcObjectPath + [.] + Justext(m.lcMethod )
		    Endif
		    Text To m.lcReturn Noshow Textmerge Pretext 1 + 2 + 4
		      EditSourceX('<<m.lcFilename>>', '<<m.lcClassName>>','<<m.lcMethod>>',<<m.lnLineNo >>)
		    Endtext
		  Otherwise && File|class|method|lineno
		    If Lower(Justext(m.lcFilename)) = [prg]
		      Text To m.lcReturn  Noshow Textmerge Pretext 1 + 2 + 4
		        <<m.lcFilename >> <<m.lnLineNo >>
		      Endtext
		    Else
		      If Empty(m.lcObjectPath)
		        Text To m.lcReturn  Noshow Textmerge Pretext 1 + 2 + 4
		        <<m.lcFilename >> <<m.lcClassName >> <<JustExt(m.lcMethod)>> <<m.lnLineNo >>
		        Endtext
		      Else
		        Text To m.lcReturn  Noshow Textmerge Pretext 1 + 2 + 4
		        <<m.lcFilename >> <<m.lcClassName >> <<m.lcObjectPath>>.<<JustExt(m.lcMethod)>> <<m.lnLineNo >>
		        Endtext
		      Endif
		
		    Endif
		
		Endcase
		Return Alltrim(m.lcReturn)
		
		
	ENDPROC

	PROCEDURE getextensioncursor
		Local lcExtensions, lnLines, lnSelect, lnX
		
		Local Array laDummy[1]
		
		If Select([curextensions]) = 0
		  Text To m.lcExtensions Noshow Textmerge Pretext 1 + 2 + 4
		  dbf | cdx |
		  dbf | fpt |
		  scx | sct |
		  vcx | vct |
		  pjx | pjt |
		  lbx | lbt |
		  frx | frt |
		  dbc | dct |
		  dbc | dcx |
		  mnx | mnt |
		  qpr | qpx | *
		  spr | spx | *
		  mpr | mpx | *
		  dbf | db2 | *
		  vcx | vc2 | *
		  scx | sc2 | *
		  lbx | lb2 | *
		  frx | fr2 | *
		  pjx | pj2 | *
		  dbc | dc2 | *
		  mnx | mn2 | *
		  prg | fxp | *
		  prg | err | *
		  prg | bak | *
		  Endtext
		  lnSelect = Select()
		  Select 0
		  Create Cursor curExtensions (ext1 c(3), ext2 c(3), extra l)
		  lnLines = Alines(laDummy, m.lcExtensions, 1 + 4)
		  For lnX = 1 To m.lnLines
		    Insert Into curExtensions (ext1, ext2, extra) Values (;
		        Alltrim(Lower(Getwordnum(m.laDummy(m.lnX), 1, [|]))),;
		        Alltrim(Lower(Getwordnum(m.laDummy(m.lnX), 2, [|]))),;
		        !Empty(Alltrim(Getwordnum(m.laDummy(m.lnX), 3, [|]))))
		  Endfor
		  Select (m.lnSelect)
		Endif
		
	ENDPROC

	PROCEDURE getfieldcount
		Lparameters tcFileDBF
		If Lower(Justext(m.tcFileDBF)) = [dbf]
		  lnArea = Select(1)
		  Use (m.tcFileDBF) Again In (m.lnArea ) 
		  lnFields = Fcount(m.lnArea)
		  Use in (m.lnArea)
		Else 
		  m.lnFields = 0
		EndIf
		Return m.lnFields 
		
	ENDPROC

	PROCEDURE getfilelisttoprocess		&& Pass a comma delimited file list, return list with corresponding files added. Pass .T: to include secondary files (.bak, .err e.t.c.)
		Lparameters tcFiles
		
		Local lcFile, lcFileList, lcMoreExtensions, lcNew, lnX, lnY
		
		Local Array lDummy[1]
		
		lcFileList = []
		
		For lnX = 1 To Getwordcount(m.tcFiles, [,])
		  lcMoreExtensions = []
		  lcFile = Getwordnum(m.tcFiles, m.lnX, [,])
		  If Adir(lDummy, m.lcFile ) = 0
		    This.GiveMessage( m.lcFile + [ is not found!], 48, [Wrong name?])
		    Loop
		  Else
		    lcMoreExtensions = This.GetAdditionalFiles(m.lcFile)
		  Endif
		  If !Getwordnum(m.tcFiles, m.lnX, [,]) $ m.lcFileList
		    lcFileList = m.lcFileList + Getwordnum(m.tcFiles, m.lnX, [,]) + [,]
		  Endif
		  If !Empty(m.lcMoreExtensions)
		    For lnY = 1 To Getwordcount(m.lcMoreExtensions, [,])
		      lcNew = Forceext(m.lcFile, Getwordnum(m.lcMoreExtensions, m.lnY, [,]))
		      If !m.lcNew $ m.lcFileList
		        lcFileList = m.lcFileList + m.lcNew  + [,]
		      Endif
		    Endfor
		    lcFileList = Rtrim(m.lcFileList, 0, [,])
		  Endif
		  If Right(m.lcFileList, 1) # [,]
		    lcFileList = m.lcFileList + [,]
		  Endif
		Endfor
		lcFileList = Trim(m.lcFileList, 0, [,])
		Return m.lcFileList
		
	ENDPROC

	PROCEDURE getfilesandsubfolders
		Lparameters tcRoot, tcMask, tcCursor
		Local lcAlias, lcFile, lcMask, lcOldDir, lnFiles, lnSelect, lnX
		
		Local Array laDummy[1, 5]
		
		lcOldDir = Fullpath(Curdir())
		tcRoot = Addbs(Evl(m.tcRoot, m.lcOldDir ))
		tcCursor = Evl(m.tcCursor, This.cCursor)
		lcMask = Lower(Evl(m.tcMask, [*.*]))
		If Empty(Justext(m.lcMask))
		  lcMask = Forceext(m.lcMask, [*])
		Endif
		If Empty(Juststem(m.lcMask))
		  lcMask =  [*.] + Justext(m.lcMask)
		Endif
		lcAlias = Alias()
		If !Used(m.tcCursor)
		  lnSelect = Select()
		  Create Cursor (m.tcCursor) (Filename c(254), FileSize i, Filedate T)
		  Select (m.lnSelect)
		Endif
		Set Default To (m.tcRoot)
		lnFiles = Adir(m.laDummy, [*.*], [AHRSD], 1)
		For lnX = 1 To m.lnFiles
		  lcFile = Alltrim(m.laDummy(m.lnX, 1))
		  If Left(m.lcFile, 1) = [$] Or m.lcFile = [System Volume Information]
		    Loop
		  Endif
		  If !Left(m.lcFile, 1) == [.] 
		    If [D] $ m.laDummy(m.lnX, 5)
		      This.GetFilesAndSubfolders(Addbs(m.tcRoot + m.lcFile), m.tcMask, m.tcCursor )
		    Else
		      If !Like( m.lcMask, Lower(m.lcFile))
		        Loop
		      Endif
		      lcFile = Forcepath( m.laDummy(m.lnX, 1), m.tcRoot)
		      lcFile = This.FixPath(m.lcFile, m.lcOldDir )
		      Insert Into (m.tcCursor) (Filename, FileSize, Filedate) Values;
		        (m.lcFile,;
		          m.laDummy(m.lnX, 2),;
		          This.dir2dt(m.laDummy( m.lnX, 4), m.laDummy( m.lnX, 3)))
		    Endif
		  Endif
		Endfor
		If Empty(m.lcAlias)
		  Select (m.tcCursor)
		Endif
		Set Default To (m.lcOldDir)
		Return Reccount(m.tcCursor)
	ENDPROC

	PROCEDURE getfilesinfolder
		Local lcNewFolder, lcOldFolder
		
		lcOldFolder = Fullpath(Curdir())
		lcNewFolder = Justpath(This.cParameter)
		If Directory(m.lcNewFolder)
		  Cd (m.lcNewFolder)
		  This.GetFilesInPath([*])
		  Update (This.cCursor) Set Filename = Forcepath(Filename, m.lcNewFolder)
		  Cd (m.lcOldFolder)
		Endif
		
		
	ENDPROC

	PROCEDURE getfilesinpath
		Lparameters tcMask, tcCursor, tlSelectOnFinish
		Local lcFilemask, lcFileSkel, lcFilter, ldDate, lnFiles, lnFolders, lnRecords, lnSelect, lnSize, lnX
		Local lnX2
		
		Local Array laDummy[1]
		Local Array laFolders[1]
		
		lnSelect = Select()
		tcCursor = Evl(m.tcCursor, This.cCursor) && [curFiles])
		Select 0
		Create Cursor (m.tcCursor) (Filename c(240), Filedate D, FileSize i)
		tcMask = Evl(m.tcMask, [prg])
		If Empty(Justext(m.tcMask))
		  lcFilter = [*]
		Else
		  lcFilter = Juststem(m.tcMask)
		  tcMask = Justext(m.tcMask)
		Endif
		lcFilter = m.lcFilter + [.]
		
		lnFolders = Alines(laFolders, Set([Path]), 1 + 4, [;], [,])
		lcFilemask = m.lcFilter  + m.tcMask
		
		For lnX = 0 To m.lnFolders
		  If m.lnX = 0
		    lcFileSkel = m.lcFilemask
		  Else
		    lcFileSkel =  Forcepath(m.lcFilemask, Alltrim(m.laFolders(m.lnX)))
		  Endif
		  lnFiles = Adir(laDummy, m.lcFileSkel,'',1)
		  If m.lnFiles > 0
		    For lnX2 = 1 To m.lnFiles
		      lnSize = m.laDummy(m.lnX2, 2)
		      ldDate = m.laDummy(m.lnX2, 3)
		      If m.lnX = 0
		        Insert Into (m.tcCursor) (Filename, Filedate, FileSize) Values (m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Else
		        Insert Into (m.tcCursor) (Filename, Filedate, FileSize) Values (Trim(m.laFolders(m.lnX)) + [\] + m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Endif
		    Endfor
		  Endif
		Endfor
		lnRecords = Reccount()
		If !Empty(m.tlSelectOnFinish)
		  Select (m.tcCursor) 
		Else 
		  Select (m.lnSelect)
		Endif
		Return m.lnRecords
		
		
	ENDPROC

	PROCEDURE gethelptopics
		* a = all windows
		* c = command window
		* e = prg
		* f = vcx/scx
		* m = menu / blank parameter
		* - = Show in meu after inputbox, but not "run"
		
		
		Local lcSidekickOptions
		
		Text To m.lcSidekickOptions Noshow Textmerge Pretext 7
		 a   | <blank>     | Menu                                                   | skorg
		 ef  | # <file>    |-Insert #Include statement from Picklist of .h files    | skinc   | na
		 a   | !           | Create and run Sidekick extensions                     | skext
		 a   | !!          | Edit Sidekick extensions                               | skext
		 mc  | *           | Picklist of groups in active .sk file                  | skorg
		 a   | **          | Picklist of Sidekick "project" files in the path       | skorg
		 ef  | * <number>  |-Repeat * characters to split code into segments        | skorg
		 c   | +           | Picklist of all VFP files in the path, edit            | skdir
		 ef  | + <file>    |-Inserts contents from prg                              | skins
		 a   | ++          | Picklist of VFP files with more information, edit      | skdir#dirc
		 a   | +++         | Picklist of VFP files with more information, run       | skdir#dirrun
		 a   | -           | Opens default files listed in active .sk               | skorg
		 ce  | --          | To selectively move files to another folder            | sktidy
		 a   | .           | (dot) Opens Sidekick "test area"                       | skta
		 a   | .?          | List of Sidekick "test areas"                          | skta
		 a   | .+          | Next Sidekick "test area"                              | skta
		 a   | .-          | Lowest available Sidekick "test area"                  | skta
		 ef  | = <func>    |-Inserts return value from function                     | skeval
		 a   | ?           | Menu                                                   | skmnu
		 a   | ??          | Menu, private extensions excluded                      | skmnu
		 cef | ?= <var>    |-Returns ?'memvar',mvar                                 | skdb
		 cef | //          | List of stored items                                   | skop    
		 ef  | //+         |-Adds or updates the active window                      | skop    
		 ef  | //-         |-Inactivates the active window                          | skop    
		 cef | ///m        | Opens current MRU table for editing                    | skop    
		 a   | 0           | Opens active .sk file for editing                      | skorg
		 a   | 0 *         | Picklist of Sidekick files in the path                 | skorg
		 a   | 0 <file>    | Makes filename.sk the active Sidekick file             | skorg | .sk file to become active:
		 a   | 1           | Items in group 1 are opened or run                     | skorg
		 a   | 2-9999      | Items in specified group opened or run                 | skorg | Group number to process:
		 f   | Be          | BindEvent syntax builder                               | skbe
		 a   | Br          | Browse the currently selected table or cursor          | skbr
		 ef  | Db <var>    |-Returns DebugOut 'memvar',mvar                         | skdb  
		 f   | DD          |-DoDefault() syntax builder                             | skdd  
		 c   | De          | Picklist of prg files with a description               | skdesc
		 ef  | De          |-Adds "* Description *" template to the active file     | skdesc
		 a   | Dr          | Picklist of all VFP files in the path, edit            | skdir
		 cef | Ec          | The content of the clipboard is executed               | skec
		 a   | Ed          | List all files in the current path                     | sked
		 a   | Ed 0        | Opens current Sidekick Project File                    | sked
		 a   | Ed <number> | Runs given group no in current Sidekick Project File   | sked
		 a   | Ed -        | Runs default group in current Sidekick Project File    | sked
		 a   | Ed <file>   | Opens specified file or gives list                     | sked    | Filename, method or class:
		 cef | Es          | Creates EditSource command for the opened window(s)    | skes
		 ef  | Equ <func>  |-Inserts return value from function                     | skeval
		 a   | FF          | File finder for current folder and subfolders          | skff
		 a   | FL <ext>    | Quick File lister for current folder and path          | skfl    | Extension (optional)?
		 cef | Fp <table>  | Opens SuperBrowse as a Field Picker                    | skfp    | Table name:
		 mc  | Gr          | Picklist of groups in active .sk file                  | skorg | Group number to process:
		 cef | Help        | Opens Sidekick page in the default Browser             | <default> 
		 a   | Hk          | Picklist of all assigned hot keys                      | skhk
		 ef  | Inc <file>  |-Insert #Include statement from Picklist of .h files    | skinc
		 ef  | Ins         |-Inserts contents from prg                              | skins
		 cef | Lorem       |-Random "Lorem Ipsum" text generator                    | skrt 
		 ef  | Menu        | Menu                                                   | skmnu
		 a   | MF          | Modify Form with picklist                              | skmf
		 cef | No          |-NewObject syntax builder                               | skno 
		 cef | Op          | List of stored items                                   | skop    
		 ef  | Op+         |-Adds or updates the active window                      | skop    
		 ef  | Op-         |-Inactivates the active window                          | skop    
		 cef | Op/m        | Opens current MRU table for editing                    | skop    
		 a   | Ot          | Shows all open tables and cursors in active datasession| skot  
		 a   | Pa          | Shows the current Set Path setting plus some more      | skpa  
		 cef | Rt          |-Random readable text generator                         | skrt
		 cef | SB          | SuperBrowse                                            | sksf
		 cef | SF          |-Select From syntax helper                              | sksf
		 a   | SHX         | ShellExecute                                           | sksx
		 cef | Sk          | Run or create custom made Sidekick extensions          | skext
		 cef | Sked        | Edit custom made Sidekick extensions                   | skext
		 a   | SX          | ShellExecute                                           | sksx
		 a   | Ta          | Sidekick "Test area"                                   | skta
		 a   | Ta?         | List of Sidekick "test areas"                          | skta
		 a   | Ta+         | Next Sidekick "test area"                              | skta
		 a   | Ta-         | Lowest available Sidekick "test area"                  | skta
		 a   | Th          | Picklist of registered Thor tools                      | skth
		 ce  | Tidy        | To selectively move files to another folder            | sktidy
		 a   | Tool        | Picklist of registered Thor tools                      | skth
		 a   | Ver         | Shows Sidekick version number                          | <ver>
		 ce  | Unzip       | To Unzip files                                         | skzip#unzip
		 ce  | Zip         | To Zip files                                           | skzip
		
		Endtext
		Return m.lcSidekickOptions
		
	ENDPROC

	PROCEDURE getlastcharacter
		Lparameters tcText, tnNumber
		m.tnNumber = Evl(m.tnNumber,1)
		Return Right(Trim(m.tcText),m.tnNumber)
	ENDPROC

	PROCEDURE getlastfile
		Lparameters tcFileName
		Local lcExtension, lcJustName, lcReturn, lnFiles, tlFolder
		
		Local Array laDummy[1]
		
		tcFileName = Evl(m.tcFileName, [])
		tlFolder = .T.
		lcJustName = Addbs(Justpath(m.tcFileName)) + Juststem(m.tcFileName)
		lcExtension = Justext(m.tcFileName)
		If Empty(m.lcExtension)
		  lnFiles = Adir(laDummy, m.lcJustName + [*.], [D])
		Else
		  lnFiles = Adir(laDummy, Forceext(m.lcJustName  + [*], m.lcExtension))
		Endif
		If m.lnFiles > 0
		  Asort(m.laDummy, 1, -1, 1)
		  lcReturn = m.laDummy
		Else
		  lcReturn = m.tcFileName
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getlastword
		  Lparameters tcText, tcDelimiter                                                                                                                                                                                                                             
		  If Pcount() < 2 Or Vartype(m.tcDelimiter) # [C]                                                                                                                                                                                                             
		    tcDelimiter = [ ]                                                                                                                                                                                                                                         
		  Endif                                                                                                                                                                                                                                                       
		Return Trim(Getwordnum(m.tcText, Getwordcount(m.tcText, m.tcDelimiter), m.tcDelimiter))                                                                                                                                                                     
		
		
	ENDPROC

	PROCEDURE getlineno
		Lparameters tcFile, tnLine
		Local lcReturn, lnLines
		
		Local Array laDummy[1]
		
		lnLines = Alines(laDummy, Filetostr(m.tcFile))
		lcReturn = []
		If m.tnLine <= m.lnLines
		  lcReturn = m.laDummy(m.tnLine)
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getlinestoprocess
		Lparameters tnGroup
		
		Local Array laLines[1]
		#Define ccAmp  [&] + [&]
		
		If ! this.CheckOrCreateSidekickFile()
		  Return
		EndIf
		llFound = .F.
		lnLines = Alines(laLines, Filetostr(this.cSidekickFile))
		For lnCounter = 1 To m.lnLines
		  lnLine = Val(Getwordnum(m.laLines(m.lnCounter), 1))
		  If m.lnLine = m.tnGroup Or (m.lnLine = 0 And Getwordnum(m.laLines(m.lnCounter), 1) = [0])
		    llFound = .T.
		    lcCommand = Strextract(m.laLines(m.lnCounter), [ ])
		    If ccAmp $ m.lcCommand
		      lcCommand = Strextract(m.laLines(m.lnCounter), [ ], ccAmp, 1)
		    EndIf
		    this.RunSidekickLine(m.lcCommand)
		  Endif
		Endfor
		If !m.llFound
		  this.GiveMessage( [Group number ] + Transform(m.tnGroup) + [ doesn't exist in ] + this.cSidekickFile , 0, [Nothing to do!])
		Endif
		
		
	ENDPROC

	PROCEDURE getmemosize
		Lparameters tcFileDBF
		Local lcFileMemo, lnFiles, lnReturn
		
		Local Array laDummy[1]
		
		lnReturn = 0
		Do Case
		  Case Lower(Justext(m.tcFileDBF)) = [dbf]
		    lcFileMemo = Forceext(m.tcFileDBF, [fpt])
		  Case Lower(Justext(m.tcFileDBF)) = [dbc]
		    lcFileMemo = Forceext(m.tcFileDBF, [dct])
		  Case Inlist(Lower(Justext(m.tcFileDBF)), [vcx], [scx], [frx], [lbx], [mnx], [pjx])
		    lcFileMemo = Forceext(m.tcFileDBF, Left(Lower(Justext(m.tcFileDBF)), 2) + [t])
		  Otherwise
		    lcFileMemo = []
		Endcase
		If !Empty(m.lcFileMemo)
		  lnFiles = Adir(laDummy, m.lcFileMemo)
		  If m.lnFiles = 1
		    lnReturn = m.laDummy(1, 2)
		  Endif
		Endif
		Return m.lnReturn
		
		
	ENDPROC

	PROCEDURE getmethdosfromclasslib
		Lparameters tcClassFile, tcCursor
		Local lcBaseClass, lcClass, lcCode, lcLine, lcMethod, lcMethods, lcObject, lnLines, lnSelect
		Local lnSelectFile, lnX
		
		Local Array laDummy[1]
		
		tcCursor = Evl(m.tcCursor, [curMethods])
		lnSelect = Select()
		lnSelectFile = Select( Chrtran(Juststem(m.tcClassFile), [-], [_]))
		Select (m.lnSelectFile)
		If m.lnSelectFile = 0
		  Use (m.tcClassFile)
		Endif
		Scan For ! Empty(Methods) And !Deleted()
		  lcMethods = Methods
		  lcCode = []
		  lcMethod = []
		  lcClass = Class
		  lcBaseClass = BaseClass
		  If Empty(Parent)
		    lcObject = Trim(ObjName)
		  Else
		    lcObject = Trim(Parent) + [.] + Trim(ObjName)
		  Endif
		  lnLines = Alines(laDummy, m.lcMethods)
		  For lnX = 1 To m.lnLines
		    lcLine = Trim(m.laDummy(m.lnX))
		    lcMethod = Evl(m.lcMethod, Getwordnum(m.lcLine, 2))
		    lcCode = m.lcCode + m.lcLine + crlf
		    If Lower(Getwordnum(m.lcLine, 1)) = [endproc] Or m.lnX = m.lnLines
		      lcCode = Trim(m.lcCode, 0, crlf)
		      If !Empty(m.lcObject)
		        lcMethod = Trim(m.lcObject) + [.] + m.lcMethod
		      Endif
		      Insert Into  (m.tcCursor) (Filename, Source, Code) Values;
		        (Fullpath(m.tcClassFile), m.lcMethod, m.lcCode )
		      lcMethod = []
		      lcCode = []
		    Else
		    Endif
		  Endfor
		Endscan
		If m.lnSelectFile = 0
		  Use In (Select( Juststem(m.tcClassFile)) )
		Endif
		Select (m.lnSelect)
	ENDPROC

	PROCEDURE getmethodfromprg
		Lparameters tcProcedure, tcFile
		Local lcFile, lcProc, lcReturn, lnEnd, lnSelect, lnStart, lnX
		
		Local Array laDummy[1]
		
		lnSelect = Select()
		lcProc = Lower(Padr(m.tcProcedure, 100))
		lcFile = Forceext(m.tcFile, [prg])
		lnX = Aprocinfo(laDummy, m.lcFile, 0)
		lcReturn = []
		If m.lnX > 0.
		  Select 0
		  Create Cursor curDummy (Name c(100), Line i, Type c(25), ind i)
		  Append From Array m.laDummy
		  Select Name, Line From curDummy Into Cursor curDummy Readwrite Where Type = [Procedure]
		  Locate For Lower(Name) == m.lcProc
		  If Found()
		    lnStart = Line
		    Skip
		    lnX = Alines(laDummy, Filetostr(m.lcFile ))
		    If !Eof([curdummy])
		      lnEnd = Line - 1
		    Else
		      lnEnd = m.lnX
		    Endif
		    If m.lnX > 0
		      lcReturn = []
		      For lnX = m.lnStart To m.lnEnd
		        lcReturn  = m.lcReturn + Trim(m.laDummy(m.lnX )) + crlf
		      Endfor
		    Endif
		  Endif
		  Use In Select([curdummy])
		Endif
		Select (m.lnSelect)
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getnextfile
		Lparameters tcFileName, tnDigits
		Local lcJustName, lnLast, lnLength, lnX
		
		tnDigits = Evl(m.tnDigits, 3)
		lcJustName = Addbs(Justpath(m.tcFileName)) + Juststem(m.tcFileName)
		lnLength = Len(m.lcJustName)
		For lnX = Len(m.lcJustName) To 1 Step - 1
		  If !Isdigit(Substr(m.lcJustName, m.lnX, 1))
		    lnLast = Int(Val(Substr(m.lcJustName, m.lnX + 1, Len(m.lcJustName) - m.lnX)))
		    If m.lnLast > m.lnX And (m.lnLength - m.lnX > m.tnDigits)
		      tnDigits = m.lnLength - m.lnX
		    Endif
		    lcJustName = Left(m.lcJustName, m.lnX)
		    Exit
		  Endif
		Endfor
		Return Forceext(m.lcJustName + Padl(m.lnLast + 1, m.tnDigits, [0]), Justext(m.tcFileName))
		
		
	ENDPROC

	PROCEDURE getnextproject
		Local lcText, lnLength, lnLines, lnNewProject, lnX
		
		Local Array laDummy[1]
		Local Array laProject[1]
		
		lnLines = Alines(laDummy, Filetostr(This.cSidekickFile ))
		Dimension m.laProject(1)
		For lnX = 1 To m.lnLines
		  lcText = Getwordnum(m.laDummy(m.lnX ), 1)
		  If Val(m.lcText) > 0
		    lnLength = Alen(m.laProject)
		    If m.lnLength > 1 Or !Empty(m.laProject(1))
		      lnLength = m.lnLength + 1
		      Dimension m.laProject(m.lnLength)
		    Endif
		    laProject(m.lnLength) = Val(m.lcText)
		  Endif
		Endfor
		If Alen(m.laProject ) = 1 And Empty(m.laProject(1))
		  lnNewProject = 1
		Else
		  lnNewProject = 1
		  Do While .T.
		    If Ascan(m.laProject, m.lnNewProject ) > 0
		      lnNewProject = m.lnNewProject + 1
		    Else
		      Exit
		    Endif
		  Enddo
		Endif
		Return m.lnNewProject
		
		
	ENDPROC

	PROCEDURE getnumberedline
		Lparameters tcFile, tnLine
		Local lcReturn, lnLine, lnLines, lnX
		
		Local Array laDummy[1]
		
		#Define ccAmp  [&] + [&]
		
		lnLines = Alines(laDummy, Filetostr(m.tcFile))
		lcReturn = []
		If m.lnLines > 0
		  For lnX = 1 To m.lnLines
		    lnLine = Val(Getwordnum(m.laDummy(m.lnX), 1))
		    If m.lnLine = m.tnLine
		      lcReturn = Strextract(m.laDummy(m.lnX), [ ])
		      If ccAmp $ m.lcReturn
		        lcReturn = Strextract(m.laDummy(m.lnX), [ ], ccAmp, 1)
		      Endif
		      Exit
		    Endif
		  Endfor
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getrandomtext
		Lparameters tnParagraphs, tnSentences
		tnParagraphs = Evl(m.tnParagraphs, 1)
		tnSentences = Evl(m.tnSentences, 1)
		Return GetDataFromURL(Textmerge([http://metaphorpsum.com/paragraphs/<<Int(m.tnParagraphs)>>/<<Int(m.tnSentences)>>]))
		
	ENDPROC

	PROCEDURE getrecordsindbf
		Lparameters tcFileName
		Local lcContents, lcLen, lnHandle, lnRec
		
		If Empty(m.tcFileName)
		  Return - 1
		Endif
		If Empty(Justext(m.tcFileName))
		  tcFileName = Forceext(m.tcFileName, [dbf])
		Endif
		Try
		  lnHandle = Fopen(m.tcFileName )
		  lcContents = Fread(m.lnHandle, 20)
		  lcLen = Substr(m.lcContents, 5, 4)
		  Fclose(m.lnHandle )
		  lnRec = CToBin(m.lcLen, [4RS])
		Catch
		  Try
		    Use (m.tcFileName) Again In 0 Alias GetRecords
		    lnRec = Reccount([GetRecords])
		    Use In GetRecords
		  Catch
		    lnRec = -2
		  Endtry
		Endtry
		Return m.lnRec
		
		
	ENDPROC

	PROCEDURE getsortabledate		&& Returns YYMMDD format from date
		Lparameters tdDate
		m.tdDate = Evl(m.tdDate,Date())
		Return Substr(Dtoc(m.tdDate,1),3)
	ENDPROC

	PROCEDURE getthorfiles
		Lparameters tcMask, tcCursor
		Local lcFileSkel, ldDate, lnFiles, lnFolders, lnReturn, lnSelect, lnSize, lnX, lnX2
		
		Local Array laDummy[1]
		Local Array laFolders[1]
		
		lnSelect = Select()
		Select 0
		tcCursor = Evl(m.tcCursor, [curFiles])
		Create Cursor (m.tcCursor) (Filename c(240), Filedate D, FileSize i)
		tcMask = Evl(m.tcMask, [prg])
		Dimension m.laFolders(3)
		laFolders(1) = _Screen.Cthorfolder + [Tools]
		laFolders(2) = _Screen.Cthorfolder + [Tools\My tools]
		laFolders(3) = _Screen.Cthorfolder + [procs]
		lnFolders = Alen(m.laFolders)
		For lnX = 1 To m.lnFolders
		  If m.lnX = 0
		    lcFileSkel = [*.] + m.tcMask
		  Else
		    lcFileSkel = Alltrim(m.laFolders(m.lnX)) + [\*.] + m.tcMask
		  Endif
		  lnFiles = Adir(laDummy, m.lcFileSkel, [], 1)
		  If m.lnFiles > 0
		    For lnX2 = 1 To m.lnFiles
		      ldDate = m.laDummy(m.lnX2, 3)
		      lnSize = m.laDummy(m.lnX2, 2)
		      If m.lnX = 0
		        Insert Into (m.tcCursor) (Filename, Filedate, FileSize) Values (m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Else
		        Insert Into (m.tcCursor) (Filename, Filedate, FileSize) Values (Trim(m.laFolders(m.lnX)) + [\] + m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Endif
		    Endfor
		  Endif
		Endfor
		lnReturn = Reccount()
		Select (m.lnSelect)
		Return m.lnReturn
		
		
	ENDPROC

	PROCEDURE givemessage
		Lparameters tcMessage, tnDialog, tcTitle, tnTimeOut
		Local loMsg As Msg Of Tools\Procs\THOR_PROC_Sidekick.vcx
		Local lcProcess
		
		Wait Clear
		tcMessage = Evl(m.tcMessage, [No text given])
		tcTitle = Evl(m.tcTitle, This.cProgram)
		tnTimeOut = Evl(m.tnTimeOut, 0)
		If m.tnTimeOut < 0
		  m.tnTimeOut = this.nTimeOut 
		Endif
		tnDialog = Evl(m.tnDialog, 0 + 64)
		If .F.
		  Return Messagebox( m.tcMessage, m.tnDialog, m.tcTitle, m.tnTimeOut )
		Else
		  lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		  loMsg = Newobject([Msg], m.lcProcess )
		  If m.tnTimeOut = 0
		    Return m.loMsg.ShowMsg(m.tcMessage, m.tnDialog, m.tcTitle)
		  Else
		    Return m.loMsg.ShowMsg(m.tcMessage, m.tnDialog, m.tcTitle, m.tnTimeOut)
		  Endif
		Endif
		
		
	ENDPROC

	PROCEDURE handlemrutable
		Lparameters tcCommand
		Local lcCommand, lcData, lcFile, lcFilter, lcFullName, lcMRU, lcMethod, lcModule, lcSQL, lcSafety
		Local lcSelect, lcTable, lcWord, lnAnswer, lnIgnoreFields, lnLineNo, lnWords, lnX, ltDateTime
		
		Local Array laDummy[1]
		
		lnIgnoreFields = 2
		
		If Inlist(m.tcCommand, [Add], [Delete])
		  lcData = This.GetEditSourceCode(This.nHandle, 0, [])
		  lcFullName = Lower(Getwordnum(m.lcData, 1))
		  lcModule = Lower(Getwordnum(m.lcData, 2))
		  lcMethod = Lower(Getwordnum(m.lcData, 3))
		  lnLineNo = Val(Getwordnum(m.lcData, 4))
		  Do Case
		    Case Lower(Justext(m.lcFullName)) = [prg]
		      lnLineNo = Val(Getwordnum(m.lcData, 2))
		      lcModule = []
		    Case Lower(Justext(m.lcFullName)) = [scx]
		      *!*        lcModule = []
		  Endcase
		Endif
		Do Case
		  Case m.tcCommand = [Add]
		    Update (This.cMRUTable) Set Datetime = Datetime(), Lineno = m.lnLineNo, Active = .T. Where Lower(FullName) = m.lcFullName And Lower(Module) = m.lcModule And Lower(Method) = m.lcMethod
		    If _Tally = 0
		      *!*        Insert Into (This.cMRUTable) (FullName, Module, Method, Lineno, Datetime, Active) Values ;
		      *!*          (Getwordnum(m.lcData, 1), Getwordnum(m.lcData, 2), Getwordnum(m.lcData, 3), Val(Getwordnum(m.lcData, 4)), Datetime(),.T.)
		      Insert Into (This.cMRUTable) (FullName, Module, Method, Lineno, Datetime, Active) Values ;
		        (m.lcFullName, m.lcModule, m.lcMethod, m.lnLineNo, Datetime(),.T.)
		    Endif
		    This.GiveMessage(Textmerge([Table <<this.cMRUTable >> is updated]), , , -1)
		    This.CutCurrentLine()
		  Case m.tcCommand = [Delete]
		    Update (This.cMRUTable) Set Datetime = Datetime(), Active = .F. Where Lower(FullName) = m.lcFullName And Lower(Module) = m.lcModule And Lower(Method) = m.lcMethod
		    This.GiveMessage(Textmerge([Table <<this.cMRUTable >> is updated]), , , -1)
		    This.CutCurrentLine()
		  Case m.tcCommand = [Browse]
		    lnAnswer = This.GiveMessage(Textmerge([Create <<ForceExt(JustStem(this.cMRUTable),"bak")>>?]), 3 + 32, [Safety precaution!])
		    If m.lnAnswer = 2
		      Return
		    Endif
		    Use (This.cMRUTable) In Select(Juststem( This.cMRUTable))
		    Select (Juststem(This.cMRUTable))
		    If m.lnAnswer = 6
		      lcSafety = Set([Safety])
		      Set Safety Off
		      Copy To (Forceext(This.cMRUTable, [bak]))
		      If m.lcSafety = [ON]
		        Set Safety On
		      Endif
		    Endif
		    Browse Last
		    Use
		  Case m.tcCommand = [List]
		    Do Case
		      Case [e] $ This.cOption
		        lcFilter = [Where External]
		      Case [a] $ This.cOption
		        lcFilter = []
		        lnIgnoreFields = 0
		      Case !Empty(Justext(This.cParameter))
		        lcFilter = Textmerge([Where "<<JustExt(this.cParameter)>>" = JustExt(Lower(fullname))])
		      Otherwise
		        lcFilter = [Where Active]
		    Endcase
		    *!*      Select * From (This.cMRUTable) Where Active Into Cursor (This.cCursor) Readwrite Order By Datetime Desc
		    Select * From (This.cMRUTable) Into Cursor (This.cCursor) Readwrite Order By Datetime Desc
		    lnWords = Getwordcount(This.cParameter)
		    For lnX = 1 To m.lnWords
		      lcWord = Getwordnum(This.cParameter, m.lnX)
		      Select * From (This.cCursor) Where m.lcWord $ Lower(FullName + [|] + Module + [|] + Method + [|] + Descript) Into Cursor (This.cCursor) Readwrite
		    Endfor
		    Text To m.lcSQL Noshow Textmerge Pretext 1 + 2 + 4 + 8
		      Select Cast(JustFname(fullname) as c(200)) as filename,
		        Cast(Fullname as c(240)) as fullname,
		        Cast(module as c(40)) as module,
		        Cast(method as c(40)) as method,
		        descript as description,
		        datetime,
		        lineno,
		        external,
		        active
		        from <<this.cCursor>> <<m.lcFilter >>
		        into cursor <<this.cCursor>> readwrite
		    Endtext
		    Execscript(m.lcSQL)
		    If _Tally > 0
		      Scan
		        lcFile = FullName
		        lcModule = Alltrim(Module)
		        lcMethod = Alltrim(Method)
		        If Empty(Description)
		          Replace Description With This.GetDescript(m.lcFile)
		        Endif
		        If Adir(laDummy, m.lcFile) > 0
		          ltDateTime = This.dir2dt(m.laDummy(1, 4), m.laDummy(1, 3))
		          Replace Datetime With m.ltDateTime
		        Endif
		      Endscan
		    Else
		      This.GiveMessage([No matching entry!])
		      Return .T.
		    Endif
		    This.DropFieldIfEmpty([lineno, description])
		
		    lcTable = This.GetDataFromGrid([Select what to edit:], [fullname], m.lnIgnoreFields )
		    If Lastkey() = 97
		      Return .T.
		    Endif
		    If !Empty(m.lcTable) And !External
		      lcFullName = Lower(FullName)
		      lcModule = Lower(Module)
		      lcMethod = Lower(Method)
		      Update (This.cMRUTable) Set Datetime = Datetime() Where Lower(FullName) = m.lcFullName And Lower(Module) = m.lcModule And Lower(Method) = m.lcMethod And Active
		    Endif
		    Do Case
		      Case External And (!Empty(Module) Or !Empty(Method))
		        lcCommand = Alltrim(Module)
		        lcCommand = Evl(m.lcCommand, Alltrim(Method))
		        lcData = Alltrim(FullName)
		        This.ShellX(m.lcCommand, , m.lcData)
		      Case Empty(Module) And Empty(Method) And !External
		        lcData = Alltrim(FullName)
		        lnLineNo = Evl(Lineno, 1)
		        Editsource(m.lcData, m.lnLineNo)
		      Case !Empty(m.lcTable)
		        lcCommand = Alltrim(FullName)
		        If !Empty(Module)
		          lcCommand = m.lcCommand + [.] + Alltrim(Module)
		        Endif
		        If !Empty(Method)
		          lcCommand = m.lcCommand + [.] + Alltrim(Method)
		        Endif
		        If !Empty(Lineno)
		          lcCommand = m.lcCommand + [:] + Transform(Lineno)
		        Endif
		        This.RunEd(m.lcCommand )
		      Otherwise
		        Use In Select(This.cMRUTable)
		    Endcase
		  Case m.tcCommand = [Check]
		    lcMRU = Forceext(This.cMRUTable, [dbf])
		    If !File(m.lcMRU)
		      lcSelect = Select()
		      Select 0
		      If Directory([data]) And [DATA] $ Set([Path])
		        lcMRU = Forcepath(m.lcMRU, [data])
		      Endif
		      Create Table (m.lcMRU) (;
		          FullName c(240),;
		          Module c(100),;
		          Method c(40),;
		          Lineno i,;
		          Descript c(40),;
		          Datetime T,;
		          Active l,;
		          External l)
		      Use
		      Select (m.lcSelect)
		    Endif
		Endcase
		Return .T.
		
	ENDPROC

	PROCEDURE highlightcurrentline
		Local lcProcess, lnEndPos, loEditorWin
		
		*!*  lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		*!*  loEditorWin = Newobject([Editorwin], m.lcProcess )
		loEditorWin  = Execscript(_Screen.cThorDispatcher, [Thor_Proc_EditorWin])
		If m.loEditorWin.FindWindow() < 0
		  Return
		Endif
		lnEndPos = m.loEditorWin.GetLineStart(m.loEditorWin.GetSelStart(), 1)
		If m.loEditorWin.GetLineNumber(m.lnEndPos) < m.loEditorWin.GetLineNumber(1e8)
		  lnEndPos = m.lnEndPos - 1
		Endif
		m.loEditorWin.Select(m.loEditorWin.GetLineStart(m.loEditorWin.GetSelStart(), 0), m.lnEndPos )
		
		
	ENDPROC

	PROCEDURE indexfields
		Lparameters txOrderAfterwards
		Local lcFields, lnX
		
		lcFields = []
		For lnX = 1 To Fcount()
		  lcFields = m.lcFields + Field(m.lnX) + [,]
		Endfor
		lcFields = Ltrim(m.lcFields, 0, [,])
		This.IndexIfField(m.lcFields)
		If !Empty(m.txOrderAfterwards )
		  Do Case
		    Case Vartype(m.txOrderAfterwards) = [C] And This.IsTag(m.txOrderAfterwards)
		      Set Order To (m.txOrderAfterwards)
		      Locate
		    Case Vartype(m.txOrderAfterwards) = [N] And m.txOrderAfterwards < Tagcount()
		      Set Order To (m.txOrderAfterwards)
		      Locate
		    Otherwise
		      ** Do nothing    
		  Endcase
		Else
		  Set Order To
		  Go Top
		Endif
		
	ENDPROC

	PROCEDURE indexiffield
		Lparameters tcField
		Local lcField, lnWord
		If !this.isCursor()
		  Return 
		Endif
		For lnWord = 1 To Getwordcount(m.tcField, [,])
		  lcField = Getwordnum(m.tcField, m.lnWord, [, ])
		  If Empty(Field(m.lcField))
		    Loop
		  Endif
		  lcType = Type(m.lcField)
		  If !Empty(Field(m.lcField))
		    Do Case
		      Case m.lcType = [C] 
		        If Len(Evaluate(m.lcField))>240
		          Execscript(Textmerge([Index on Left(Upper(<<m.lcField>>),240) tag <<m.lcField >>]))
		        else      
		          Execscript(Textmerge([Index on Upper(<<m.lcField>>) tag <<m.lcField >>]))
		        EndIf
		      Case InList(m.lcType,'N','T','Y','D')
		        Execscript(Textmerge([Index on <<m.lcField>> tag <<m.lcField >>]))
		      Otherwise
		        && Do nothing
		    Endcase
		  Endif
		Endfor
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcCommand
		
		Local lcCommand, lnX
		This.cVersion  = [1.36]
		This.cExact = Set([Exact])
		Set Exact Off
		Aerror(This.aInError)
		This.nSelect = Select()
		This.cAlias = Alias()
		This.cClip = _Cliptext
		This.Cpoint = Set([Point])
		Set Point To [.]
		lcCommand = ''
		Do case 
		  Case Vartype(m.tcCommand) = 'L'
		    This.lNoInterface = .T.
		    m.tcCommand = ''
		  Case Left(m.tcCommand ,1) = '-'
		    m.lcCommand = m.tcCommand 
		    m.tcCommand = Substr(m.tcCommand,2)
		    this.lInputBox = .T.
		    this.cParcedText = '' && m.tcCommand 
		Endcase
		This.cCommentString = Evl(This.ReadRegistryOption([EditorCommentString]), [*!*])
		Use In (Select(This.cCursor))
		This.ReadOptions()
		Aused(This.aInUse)
		This.HandleMRUTable([Check])
		If Empty(m.tcCommand) And !This.lNoInterface 
		  This.oEditorWinInit()
		  If !Left(m.lcCommand ,1) == '-'
		    This.oEditor = Execscript(_Screen.cThorDispatcher, [class= HighlightedText from Thor_Proc_HighlightedText.PRG])
		    For lnX = 1 To 2
		      This.oEditor.GetHighlightedText([Statement], .T.)
		      This.cParcedText = This.oEditor.cHighlightedText
		      If Empty(This.cParcedText)
		        Wait Window [] Timeout 0.001
		      Else
		        Exit
		      Endif
		    EndFor
		  Endif
		Else
		  If This.lNoInterface
		    This.cCommand = []
		  Else
		    This.cCommand = m.tcCommand
		  Endif
		
		  This.cParcedText = Evl(m.tcCommand, [])
		Endif
		If Empty(This.cParcedText) And !This.lNoInterface
		  This.lInputBox = .T.
		  If !Left(m.lcCommand ,1) == '-'
		    This.nLastWindow = This.oEditorWin.Findlastwindow()
		    If This.nLastWindow > 1
		      This.oEditorWin.SetHandle(This.nLastWindow)
		    EndIf
		  Endif
		  lcCommand = Inputbox([Type command:], [Sidekick Command Box], This.cDefaultCommand, 0, [], [<>])
		  If m.lcCommand = [<>] && Cancel
		    Return
		  Else
		    This.cParcedText = Alltrim(Lower(m.lcCommand))
		  Endif
		Endif
		This.cParcedText = Trim(This.cParcedText, [], Chr(13), Chr(10), Chr(0))
		This.cParcedText = Chrtran(This.cParcedText, [|], [ ])
		tcCommand = This.cParcedText
		This.cParameterOriginal = This.cParcedText
		*!*  If Pemstatus(_Screen, [lTest], 5) And _Screen.lTest
		*!*    Set Step On
		*!*  Endif
		
		If .T. && and !this.ExecuteHighlight()
		  If !Empty(This.cParcedText) Or !This.lNoInterface Or This.lInputBox
		    This.FindSwitch()
		    This.FindCommand()
		    This.FindParameters()
		    If Inlist(This.nWindowType, 0, 1) And This.cTitle == This.cSidekickFile And !Inlist(m.tcCommand, [es], [es all], [de], [desc], [descript], [description], [+], [us], [pa], [path], [-]) 
		      This.RunSidekickLine(This.cParcedText )
		    Else
		      If This.cTitle == This.cSidekickFile And This.cCommand == [+]
		        This.cCommand = [es]
		        This.cParameter = [+ ] + This.cParameter
		      Endif
		      This.cParameter = Trim(This.cParameter)
		      This.FindFunction()
		    Endif
		  Endif
		Endif
		_Cliptext = This.cClip
		
	ENDPROC

	PROCEDURE iscursor
		Lparameters tcAlias
		tcAlias = Evl(m.tcAlias, Alias())
		
		Return (Justpath(Dbf(m.tcAlias)) = Sys(2023)) And Justext(Dbf(m.tcAlias)) = [TMP]
	ENDPROC

	PROCEDURE isinteger
		Lparameters tcData
		Return Isdigit(tcData) And tcData == Transform(Val(tcData))
	ENDPROC

	PROCEDURE istag
		Lparameters tcTagName, tcTable
		*-- Passed the name of an index tag returns true if it is a tag for the specified table. Uses table in the current work area if no table name is passed.                                                                                                      
		Local Array laTags[1]
		
		*** Did we get a tag name?                                                                                                                                                                                                                                    
		If Type( [tcTagName] ) # [C]
		  *** Error - must pass a Tag Name                                                                                                                                                                                                                            
		  Error [9000: Must Pass a Tag Name when calling ISTAG()]
		  Return .F.
		Endif
		*** How about a table alias?                                                                                                                                                                                                                                  
		If Type( [tcTable] ) = [C] And ! Empty( m.tcTable )
		  *** Get all open indexes for the specified table                                                                                                                                                                                                            
		  Ataginfo( laTags, [], m.tcTable )
		Else
		  *** Get all open indexes for the current table                                                                                                                                                                                                              
		  Ataginfo( laTags, [] )
		Endif
		*** Do a Case Insensitive, Exact=ON, Scan of the first column of array                                                                                                                                                                                        
		*** Return Whether the Tag is Found or not                                                                                                                                                                                                                    
		Return ( Ascan( m.laTags, m.tcTagName, -1, -1, 1, 7 ) > 0 )
		
		
	ENDPROC

	PROCEDURE lefttrimcode
		Lparameters tcCode
		Local lcResult, lnLen, lnLines, lnMin, lnX
		
		Local Array laCode[1]
		
		#Define crlf Chr(13)+Chr(10)
		lcResult = []
		lnLines = Alines(laCode, m.tcCode)
		lnMin = 1e3
		For lnX = 1 To m.lnLines
		  If Empty(m.laCode(m.lnX))
		    Loop
		  Endif
		  lnLen = Len(m.laCode(m.lnX)) - Len(Ltrim(m.laCode(m.lnX)))
		  If m.lnLen  < m.lnMin
		    lnMin = m.lnLen
		  Endif
		Endfor
		For lnX = 1 To m.lnLines
		  lcResult = m.lcResult + Substr(m.laCode(m.lnX), m.lnMin + 1) + crlf
		Endfor
		Return m.lcResult
		
		
	ENDPROC

	PROCEDURE listdescript
		Local lcDescript, lcFile, lcSelected, lcText, lnFiles, lnX
		
		Local Array laDummy[1]
		Local Array laFiles[1]
		
		Dimension m.laFiles(1)
		lnFiles = This.GetAllFiles(,@m.laFiles)
		If m.lnFiles = 0
		  Return
		Endif
		Select 0
		Create Cursor (this.cCursor) (Filename c(240), FullName c(240), Descript c(100), Datetime D, Size i, LineS i, Text m, uDescript c(100))
		For lnX = 1 To m.lnFiles
		  If Lower(Justext(m.laFiles(m.lnX))) =  [prg]
		    lcDescript = This.GetDescript(m.laFiles(m.lnX))
		    If !Empty(m.lcDescript)
		      lcFile = Alltrim(m.laFiles(m.lnX))
		      Adir(laDummy, m.lcFile)
		      Insert Into (this.cCursor);
		        (Filename, FullName, Descript, uDescript, Datetime, Size) Values;
		        (This.ShowCase( Justfname(m.lcFile)),;
		          This.ShowCase( m.lcFile),;
		          m.lcDescript,;
		          Upper(m.lcDescript),;
		          This.dir2dt(m.laDummy(1, 4), m.laDummy(1, 3)),;
		          m.laDummy(1, 2))
		    Endif
		  Endif
		Endfor
		This.AddLinesAndText()
		If !Empty(This.cParameter)
		  For lnX = 1 To Getwordcount(This.cParameter)
		    lcText = Lower(Getwordnum(This.cParameter, m.lnX))
		    Select * From (this.cCursor) Where m.lcText $ Lower(Filename) Or m.lcText $ Lower(Descript) Order By uDescript Into Cursor (this.cCursor) Readwrite
		  Endfor
		Endif
		Select * From (this.cCursor) Into Cursor (this.cCursor) Readwrite Order By uDescript
		this.IndexFields() 
		lcSelected = This.GetDataFromGrid([Prg files with description], [Fullname], 1)
		If !Empty(m.lcSelected)
		  This.oEditorWin.Delete()
		  Modify Command (m.lcSelected) Nowait
		Endif
		
	ENDPROC

	PROCEDURE listfiles
		Lparameters tcFilter
		Local lcDescript, lcFile, lcFilter, lcMessage, lcText, lcWord, llOtherFolder, llRecords, lnFiles
		Local lnLen, lnWords, lnX, loDummy
		
		Local Array laDummy[1]
		
		#Define ccSelectFilter '!!'
		#Define ccVFPFilesToList [dbf], [scx], [vcx], [prg], [h], [dbc], [frx], [lbx], [mnx], [txt], [sk]
		#Define ccVFPTablesExtended [dbf], [dbc], [frx], [lbx], [mnx], [pjx], [scx], [vcx]
		#Define crlf Chr(13)+Chr(10)
		
		If ccSelectFilter $ m.tcFilter
		  This.cFilter = [Include]
		  tcFilter = Strtran(m.tcFilter, ccSelectFilter, [])
		Endif
		tcFilter = Lower(Evl(m.tcFilter, [vfp]))
		Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		Select 0
		If ![t] $ This.cOption
		  lnFiles = This.GetFilesInPath([*])
		Else
		  lnFiles = This.GetThorFiles([*], This.cCursor)
		Endif
		If m.lnFiles = 0
		  Return
		Endif
		Do Case
		  Case [e] $ This.cOption
		    Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Inlist(Lower(Justext(Filename)), [prg], [scx])
		    lcMessage = [Select a file to run:]
		  Case [f] $ This.cOption
		    lcMessage = [Pick a source table:]
		  Case This.cCommand = [unzip]
		    lcMessage = [Select file to unzip:]
		  Otherwise
		    lcMessage = [Select a file to edit:]
		Endcase
		Do Case
		  Case m.tcFilter = [ta] && Test area
		    lcFilter = Lower(This.cTestArea)
		    lnLen = Len(m.lcFilter)
		    If Empty(Justpath(m.lcFilter))
		      Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [prg] And Left(Lower(Juststem(Filename)), m.lnLen) = m.lcFilter
		    Else
		      Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [prg] And Left(Lower(Filename), m.lnLen) = m.lcFilter
		    Endif
		  Case m.tcFilter = [dbf] And [s] $ This.cOption And !Empty(This.cParameter)
		    lcFilter = Getwordnum(This.cParameter, 1)
		    Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [scx] And m.lcFilter $ Lower(Juststem(Filename))
		  Case m.tcFilter = [dbf] And [s] $ This.cOption
		    Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [scx]
		  Case m.tcFilter = [dbf] And [v] $ This.cOption And !Empty(This.cParameter)
		    lcFilter = Getwordnum(This.cParameter, 1)
		    Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [vcx] And m.lcFilter $ Lower(Juststem(Filename))
		  Case m.tcFilter = [dbf] And [v] $ This.cOption
		    Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [vcx]
		  Case m.tcFilter = [dbf] And !Empty(This.cParameter)
		    lcFilter = Getwordnum(This.cParameter, 1)
		    If m.lcFilter # '*'
		      Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [dbf] And m.lcFilter $ Lower(Juststem(Filename))
		    Else
		      Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [dbf] 
		    Endif
		  Case m.tcFilter = [dbf]
		    Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where Lower(Justext(Filename)) == [dbf]
		  Case m.tcFilter = [.v] && [.vcx]
		    Do Case
		      Case [.vcx] $ This.cParameter
		        This.AddOption([v])
		        This.cParameter = Strtran(This.cParameter, [.vcx], [])
		      Case [.vc] $ This.cParameter
		        This.AddOption([v])
		        This.cParameter = Strtran(This.cParameter, [.vc], [])
		      Case [.v] $ This.cParameter
		        This.AddOption([v])
		        This.cParameter = Strtran(This.cParameter, [.v], [])
		    Endcase
		  Case Occurs([.], m.tcFilter) = 1
		    For lnX = 1 To Getwordcount(m.tcFilter )
		      lcWord = Getwordnum(m.tcFilter, m.lnX)
		      Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where m.lcWord $ Lower(Filename)
		    Endfor
		  Case Getwordnum(m.tcFilter, 1) == [*] Or Getwordnum(m.tcFilter, 1) == [vfp]
		    lnWords = Getwordcount(m.tcFilter)
		    If m.lnWords > 1
		      For lnX = 2 To m.lnWords
		        lcWord = Getwordnum(m.tcFilter, m.lnX)
		        Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where m.lcWord $ Lower(Justfname(Filename))
		      Endfor
		    Endif
		  Case !Empty(m.tcFilter)
		    For lnX = 1 To Getwordcount(m.tcFilter)
		      lcWord = Getwordnum(m.tcFilter, m.lnX)
		      Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where m.lcWord $ Lower(Justfname( Filename))
		    Endfor
		  Otherwise
		    This.GetFilesInFolder()
		    llOtherFolder = .T.
		Endcase
		If Reccount(This.cCursor) = 0
		  If This.cCommand = [ed] And Getwordcount(This.cParameter) = 1
		    lcFile = Forceext(This.cParameter, [prg])
		    Wait Clear
		    If This.GiveMessage([No match, create new file?], 4 + 32, m.lcFile) = 6
		      This.RunEd(m.lcFile)
		    Else
		      This.GiveMessage([Nothing to do!])
		    Endif
		    Return
		  Else
		    This.GiveMessage([No match found])
		    Return .F.
		  Endif
		Endif
		Update (This.cCursor) Set Filename = [ ] + Filename Where Empty(Justpath(Filename))
		Do Case
		  Case m.tcFilter = [vfp]
		    Select Filename, Cast(Justfname(Filename) As c(50)) As f1, Filedate, FileSize From (This.cCursor) ;
		      Into Cursor (This.cCursor) Readwrite Where Inlist(Lower(Justext(Filename)), ccVFPFilesToList)
		  Case [?] = m.tcFilter Or m.tcFilter == [*]
		    Select Filename, Cast(Justfname(Filename) As c(50)) As f1, Filedate, FileSize From (This.cCursor) ;
		      Into Cursor (This.cCursor) Readwrite Where .T.
		  Case m.tcFilter = [dbf] And !Empty(This.cParameter) and this.cParameter # '*'
		    For lnX = 1 To Getwordcount(This.cParameter )
		      lcWord = Getwordnum(This.cParameter, m.lnX)
		      Select Filename, Cast(Justfname(Filename) As c(50)) As f1, Filedate, FileSize From (This.cCursor) ;
		        Into Cursor (This.cCursor) Readwrite Where m.lcWord $ Lower(Filename);
		        And Inlist(Lower(Justext(Filename)), ccVFPFilesToList)
		    Endfor
		  Case m.tcFilter = [dbf] Or m.tcFilter = [ta] Or m.llOtherFolder Or Left(m.tcFilter, 1) == [*]
		    Select Filename, Cast(Justfname(Filename) As c(50)) As f1, Filedate, FileSize From (This.cCursor) ;
		      Into Cursor (This.cCursor) Readwrite
		  Otherwise
		    For lnX = 1 To Getwordcount(m.tcFilter)
		      lcWord = Getwordnum(m.tcFilter, m.lnX)
		      If [.] $ m.tcFilter
		        Select Filename, Cast(Justfname(Filename) As c(50)) As f1, Filedate, FileSize From (This.cCursor) ;
		          Into Cursor (This.cCursor) Readwrite Where m.lcWord $ Lower(Filename)
		      Else
		        Select Filename, Cast(Justfname(Filename) As c(50)) As f1, Filedate, FileSize From (This.cCursor) ;
		          Into Cursor (This.cCursor) Readwrite Where m.lcWord $ Lower(Filename);
		          And Inlist(Lower(Justext(Filename)), ccVFPFilesToList)
		      Endif
		    Endfor
		Endcase
		If Reccount(This.cCursor) = 0
		  Wait Clear
		  This.RunEd(This.cParameter )
		  Return
		Endif
		Select Max(Len(Trim(f1))), Max(Len(Trim(Filename))) From (This.cCursor) Into Array laDummy
		Select Cast(This.ShowCase(f1) As c(m.laDummy(1, 1))) As Filename,;
		  Cast(This.ShowCase(Alltrim(Filename)) As c(m.laDummy(1, 2))) As FullName,;
		  Filedate, FileSize From (This.cCursor) Into Cursor (This.cCursor) Readwrite Order By 1
		llRecords = .F.
		If [a] $ This.cOption Or [e] $ This.cOption
		  Select Count(*) From (This.cCursor) Where Inlist(Lower(Justext(Filename)), ccVFPTablesExtended) Into Array laDummy
		Else
		  Select Count(*) From (This.cCursor) Where Inlist(Lower(Justext(Filename)), [dbf]) Into Array laDummy
		Endif
		llRecords = m.laDummy  > 0
		If [n] $ This.cOption
		  Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Order By Filename, Filedate Desc
		Endif
		
		If m.llRecords And Empty(Field([records]))
		  This.AddField(This.cCursor, [Records], [i])
		  This.AddField(This.cCursor, [Fields], [i])
		  This.AddField(This.cCursor, [MemoSize], [i])
		Endif
		Do Case
		  Case [a] $ This.cOption Or [e] $ This.cOption
		    Set Filter To Inlist(Lower(Justext(Filename)), ccVFPTablesExtended)
		  Otherwise
		    Set Filter To Inlist(Lower(Justext(Filename)), [dbf])
		Endcase
		Scan For RecordS = 0
		  Replace RecordS With This.GetRecordsInDBF(FullName)
		  Replace Fields With This.GetFieldCount(Fullpath(FullName))
		  Replace MemoSize With This.GetMemoSize(Fullpath(FullName))
		Endscan
		Set Filter To
		If [a] $ This.cOption Or [e] $ This.cOption
		  This.AddField(This.cCursor, [Descript], [c(100)])
		  This.AddField(This.cCursor, [Lines], [i])
		  This.AddField(This.cCursor, [Text], [m])
		
		  This.AddLinesAndText()
		  Scan
		    lcFile = Alltrim(FullName)
		    lcDescript = This.GetDescript(m.lcFile )
		    If !Empty( m.lcDescript )
		      Replace Descript With m.lcDescript
		    Endif
		  Endscan
		  Go Top
		Endif
		If !Empty(This.cFilter)
		  lcFilter = This.cFilter
		  This.AddField(This.cCursor, m.lcFilter, [l])
		Endif
		
		If Inlist(m.tcFilter, [dbf], [.vcx]) And [v] $ This.cOption && vcx
		  If [l] $ This.cOption
		    This.AddField(This.cCursor, [classes], [c(15)])
		    Do While .T.
		      Locate For Empty(Classes)
		      If !Found()
		        Exit
		      Endif
		      Scatter Memo Name m.loDummy
		      lcFile = Alltrim(FullName)
		      Select ObjName From (m.lcFile) Where reserved1 == [Class] And !Deleted() Into Array laDummy
		      Asort(m.laDummy)
		
		      For lnX = 1 To Alen(m.laDummy)
		        If m.lnX = 1
		          Replace Classes With m.laDummy(m.lnX)
		        Else
		          loDummy.Classes = m.laDummy(m.lnX)
		          Append Blank
		          Gather Memo Name m.loDummy
		        Endif
		      Endfor
		    Enddo
		
		  Else
		    If This.cCommand # [ed]
		      This.AddField(This.cCursor, [classes], [m])
		      Scan
		        lcFile = Alltrim(FullName)
		        Select ObjName From (m.lcFile) Where reserved1 == [Class] And !Deleted() Into Array laDummy
		        Asort(m.laDummy)
		        lcText = []
		        For lnX = 1 To Alen(m.laDummy)
		          lcText = m.lcText + Alltrim(m.laDummy(m.lnX)) + crlf
		        Endfor
		        lcText = Trim(m.lcText, 1, Chr(13), Chr(10))
		        Replace Classes With m.lcText
		      Endscan
		    Endif
		  Endif
		Endif
		
		This.DropFieldIfEmpty([records, lines, fields, text, descript, memosize])
		If [l] $ This.cOption And Inlist(m.tcFilter, [dbf], [.vcx]) And [v] $ This.cOption && vcx
		  Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Order By Filename, Classes
		Endif
		This.IndexFields()
		Wait Clear
		If m.tcFilter = [ta]
		  lcText = []
		  Return
		Else
		  lcText = This.GetDataFromGrid(m.lcMessage, [fullname], 0)
		Endif
		Do Case
		  Case !Empty(This.cFilter)
		  Case [e] $ This.cOption And Inlist(Lower(Justext(m.lcText)), [prg], [scx])
		    This.RunProgram(m.lcText)
		  Case Lower(Justext(m.lcText)) = [zip]
		  Case Inlist(This.cCommand, [us], [ta], [sf], [fp], [br])
		  Case This.nWindowType = 0 And This.cCommand == [use]
		  Case Lower(Justext(m.lcText)) = [sk]
		    Modify Command (m.lcText) Nowait
		  Case !Empty(m.lcText)
		    If Ascan(This.aInUse, Juststem(m.lcText), -1, -1, 1, 1 + 2 + 4) > 0
		      This.cTableToKeepOpen = Juststem(m.lcText)
		    Endif
		    This.RunEd(Fullpath(m.lcText))
		Endcase
		Return m.lcText
		
		
	ENDPROC

	PROCEDURE listusedtables
		Local lcCursor, lnTables
		
		Local Array laDummy[1]
		lnTables = Aused(laDummy)
		If m.lnTables > 0
		  lcCursor = this.cCursor 
		  Create Cursor (m.lcCursor) (Fullname c(250), workarea i, Alias c(10), Table c(25), Size i, Date d, records i, memosize i)
		  Append From Array m.laDummy Fields Fullname, workarea
		  Scan 
		    Replace Fullname With Dbf(Trim(Fullname))
		    Replace Table With Justfname(Fullname),;
		      RecordS With This.GetRecordsInDBF(FullName),; 
		      MemoSize With This.GetMemoSize(Fullpath(FullName)),; 
		      alias with Alias(workarea)
		  Endscan
		  Select Max(Len(Trim(Fullname))), Max(Len(Trim(Table))) From (m.lcCursor) Into Array laDummy
		  Select Cast(Table As c(m.laDummy(1, 2))) As Table, alias, Cast(Fullname As c(m.laDummy(1, 1))) As Fullname, Size, Date, records, memosize From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where !Empty(alias)
		Else
		  Return .F.
		Endif
		If Reccount() > 0
		  Scan
		    If Adir(laDummy, Fullname) > 0
		      Replace Size With m.laDummy(1, 2), Date With m.laDummy(1, 3)
		    Endif
		  Endscan
		Endif
		Return Reccount() > 0
	ENDPROC

	PROCEDURE log
		Lparameters txCaller
		Local lcCaller, lcFile, lcText
		
		If Vartype(m.txCaller) = [L]
		  If !Pemstatus(_Screen, [lLog], 5)
		    _Screen.AddProperty([lLog], m.tlCaller)
		  Else
		    _Screen.llog = m.txCaller
		  Endif
		Else
		  If _Screen.llog
		    lcCaller = Evl(m.txCaller, Program(2))
		    lcFile = [sidekicklog.txt]
		    Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		  Level: <<m.txCaller>>
		  cCommand    : <<this.cCommand>>
		  cParameter  : <<this.cParameter>>
		  cParcedText : <<this.cParcedText>>
		  nWindowType : <<this.nWindowType>> 
		    Endtext
		    Strtofile(m.lcText, m.lcFile, 1)
		    Wait Window 'Log added' at 10,25 timeout 2
		  Endif
		Endif
		
	ENDPROC

	PROCEDURE notes
		Text To lcDummy Noshow Textmerge Pretext 1+2+4
		Path:
		  /n No path
		  /f Full path
		  /r Relative path
		
		No (NewObject builder)  
		  /n Newest first
		
		Zip:
		  /d Delete after zip
		  
		Listfiles: 
		  /l List all classes as records  
		
		Fix: 
		  Autosize if PG
		  Header click: textbox.setfocus
		
		
		EndText
		
	ENDPROC

	PROCEDURE oeditorwininit
		Local lcProcess
		
		*!*  lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		This.oEditorWin = Execscript(_Screen.cThorDispatcher, [Thor_Proc_EditorWin])
		*!*  This.oEditorWin = Newobject([EditorWin],m.lcProcess)
		This.nWindowType = This.oEditorWin.FindWindow()
		This.nHandle = This.oEditorWin.GetWindowHandle()
		If This.nWindowType >= 0
		  This.nSelStart = This.oEditorWin.GetSelStart()
		  This.nSelEnd = This.oEditorWin.GetSelend()
		  This.nFileSize = This.oEditorWin.GetFileSize()
		  This.cTitle = This.oEditorWin.GetTitle()
		  This.nLineno = This.oEditorWin.GetLineNumber(This.nSelStart)
		Else
		  This.cTitle = [No active window!]
		Endif
		
	ENDPROC

	PROCEDURE openiffile
		Local lcFile, llSuccess
		
		lcFile = Lower(This.cParcedText)
		llSuccess = .T.
		If Getwordcount(m.lcFile) > 0 Or File(m.lcFile)
		  Do Case
		    Case Getwordcount(m.lcFile) > 1
		      llSuccess = .F.
		    Case Justext(m.lcFile) = [dbf] Or (Empty(Justext(m.lcFile)) And  File(Forceext(m.lcFile, [dbf])))
		      Select (Select(Juststem(m.lcFile )))
		      Use (m.lcFile )
		      This.sk_br()
		    Case Justext(m.lcFile ) = [txt] And File(m.lcFile)
		      Modify File (m.lcFile ) Nowait
		    Case File(m.lcFile )
		      llSuccess = This.RunEd(m.lcFile )
		    Otherwise
		      llSuccess = .F.
		  Endcase
		Endif
		Return m.llSuccess
	ENDPROC

	PROCEDURE ozipinit
		Local lcProcess
		
		If Vartype(This.oZip) # [O]
		  lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		  This.oZip = Newobject([ozip], m.lcProcess)
		Endif
		
	ENDPROC

	PROCEDURE readclasslibs
		Local lcClass, lcFile, lnClasses, lnI, lnReturn, lnSelect, lnX, loList, loTools, lx
		
		Local Array laClasses[1]
		Local Array laDummy[1]
		lnReturn = 0
		If llNoProject && No active project, use MRU
		  loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		  loList = m.loTools.GetMRUList([VCX])
		  lnSelect = Select()
		  Select 0
		  Create Cursor curClassLib (Class c(50), Classlib c(100))
		*!*    Index On Upper(Classlib) Tag Classlib
		*!*    Index On Upper(Class) Tag Class
		  this.IndexFields()
		  For Each m.lcClass In m.loList
		    Try
		      lcFile = Getwordnum(m.lcClass, 1, [|])
		      If Adir(laDummy, m.lcFile) > 0
		        lnClasses = Avcxclasses(laClasses, M.lcFile)
		        For lnI = 1 To M.lnClasses
		          Insert Into curClassLib (Class, Classlib);
		            Values (m.laClasses[m.lni, 1], Lower(M.lcFile))
		        Endfor
		      Endif
		    Catch
		    Endtry
		  Endfor
		  Select Distinct Class, Classlib From curClassLib Order By 2, 1 Into Cursor curClassLib Readwrite
		  If _Tally > 0
		    AddProperty(_vfp, [noClasses(] + Transform(_Tally) + [,2)], .F.)
		    AddProperty(_vfp, [noLenClasses], _Tally)
		    lnReturn = _Tally
		    lnX = 1
		    Scan
		      Store this.ShowCase(Trim(curClassLib.Class)) To ([_vfp.noClasses(] + Transform(m.lnX) + [,1)])
		      Store this.ShowCase(curClassLib.Classlib) To ([_vfp.noClasses(] + Transform(m.lnX) + [,2)])
		      lnX = m.lnX + 1
		    Endscan
		  Endif
		Else
		  loTools = Execscript (_Screen.cThorDispatcher, [class= tools from pemeditor])
		  lx = m.loTools.GetClasslist(, , .T., .F., .T., .F.)
		  If Alen(m.lx.List) > 1
		    AddProperty(_vfp, [noClasses(] + Transform(Alen(m.lx.List, 1)) + [,2)], .F.)
		    AddProperty(_vfp, [noLenClasses], Alen(m.lx.List, 1))
		    For lnX = 1 To Alen(m.lx.List, 1)
		      Store this.ShowCase(m.lx.List(m.lnX, 1)) To ([_vfp.noClasses(] + Transform(m.lnX) + [,1)])
		      Store this.ShowCase(Justfname(m.lx.List(m.lnX, 2))) To ([_vfp.noClasses(] + Transform(m.lnX) + [,2)])
		    Endfor
		    lnReturn = Alen(m.lx.List, 1)
		  Endif Alen(m.lx.List) > 1
		Endif
		
		Return m.lnReturn
		
		
	ENDPROC

	PROCEDURE readoptions
		#Define ccThorTool     'SideKick'
		
		Local loSk As [empty]
		Local lcFolder, loThor
		
		If [O] # Vartype(_Screen.oSKOptions)
		  loThor      = Execscript(_Screen.cThorDispatcher, [Thor Engine=])
		  If Vartype(m.loThor.GetOption([Project], ccThorTool)) = [X] && No defaults, so we set them!
		    m.loThor.SetOption([BackupFolder], [Bu?], ccThorTool )
		    m.loThor.SetOption([DefaultCommand], [?], ccThorTool )
		    m.loThor.SetOption([HelpURL], [https://github.com/tbleken/sidekick], ccThorTool )
		    m.loThor.SetOption([MRUTable], [SMKRUList], ccThorTool )
		    m.loThor.SetOption([Project], [sidekick.sk], ccThorTool )
		    m.loThor.SetOption([RunCommand], [exe], ccThorTool )
		    m.loThor.SetOption([Unzipfolder], [SKUnzip], ccThorTool )
		    m.loThor.SetOption([ZipTarget], [SKZip_], ccThorTool )
		    m.loThor.SetOption([GridAuto],.T., ccThorTool )
		    m.loThor.SetOption([NewFirst],.T., ccThorTool )
		    m.loThor.SetOption([DisplayCase], 2, ccThorTool )
		    m.loThor.SetOption([FontSize], 14, ccThorTool )
		    m.loThor.SetOption([MaxDescriptionLine], 15, ccThorTool )
		    m.loThor.SetOption([NextLength], 4, ccThorTool )
		    m.loThor.SetOption([PathReturned], 1, ccThorTool )
		    m.loThor.SetOption([WaitTimeout], 3, ccThorTool )
		    m.loThor.SetOption([ZipDelay], 100, ccThorTool )
		    m.loThor.SetOption([TestArea], [SKTest], ccThorTool )
		  Endif
		
		
		  loSk = Createobject([empty])
		  AddProperty(m.loSk, [cDefaultCommand], m.loThor.GetOption([DefaultCommand],  ccThorTool))
		  AddProperty(m.loSk, [nFontsize], m.loThor.GetOption([Fontsize],  ccThorTool))
		  AddProperty(m.loSk, [lGridAuto], m.loThor.GetOption([GridAuto],  ccThorTool))
		  AddProperty(m.loSk, [lNewFirst], m.loThor.GetOption([NewFirst],  ccThorTool))
		  AddProperty(m.loSk, [nPathReturned], m.loThor.GetOption([PathReturned],  ccThorTool))
		  AddProperty(m.loSk, [nDisplayCase], m.loThor.GetOption([DisplayCase],  ccThorTool))
		  AddProperty(m.loSk, [cMRUTable], Alltrim(m.loThor.GetOption([MRUTable],  ccThorTool)))
		  AddProperty(m.loSk, [lNewFirst], m.loThor.GetOption([NewFirst],  ccThorTool))
		  AddProperty(m.loSk, [nNextLength], m.loThor.GetOption([NextLength],  ccThorTool))
		  AddProperty(m.loSk, [cBackupFolder], Alltrim(m.loThor.GetOption([BackupFolder],  ccThorTool)))
		  AddProperty(m.loSk, [cUnzipFolder], Alltrim(m.loThor.GetOption([UnzipFolder],  ccThorTool)))
		  AddProperty(m.loSk, [cZipTarget], Alltrim(m.loThor.GetOption([ZipTarget],  ccThorTool)))
		  AddProperty(m.loSk, [nZipDelay], m.loThor.GetOption([ZipDelay],  ccThorTool))
		  AddProperty(m.loSk, [cProject], Alltrim(m.loThor.GetOption([Project],  ccThorTool)))
		  AddProperty(m.loSk, [cRunCommand], Alltrim(m.loThor.GetOption([RunCommand],  ccThorTool)))
		  AddProperty(m.loSk, [nMaxDescriptLine], m.loThor.GetOption([MaxDescriptLine],  ccThorTool))
		  AddProperty(m.loSk, [cHelpURL], Alltrim(m.loThor.GetOption([HelpUrl],  ccThorTool)))
		  AddProperty(m.loSk, [nWaitTimeout], m.loThor.GetOption([WaitTimeout],  ccThorTool))
		  AddProperty(m.loSk, [cTestArea], Alltrim(m.loThor.GetOption([TestArea],  ccThorTool)))
		  _Screen.AddProperty([oSKOptions], m.loSk)
		Endif
		
		This.nMaxDescriptLine = _Screen.oSKOptions.nMaxDescriptLine
		This.nZipDelay = _Screen.oSKOptions.nZipDelay
		This.nTimeOut = _Screen.oSKOptions.nWaittimeout * 1000
		This.nNextLength = _Screen.oSKOptions.nNextLength
		This.cBackupFolder = _Screen.oSKOptions.cBackupFolder
		This.cUnzipFolder = _Screen.oSKOptions.cUnzipFolder
		This.cZipTarget = _Screen.oSKOptions.cZipTarget
		This.cSidekickFile  = _Screen.oSKOptions.cProject
		This.cRun = _Screen.oSKOptions.cRunCommand
		This.cSidekickHelp = Addbs(_Screen.oSKOptions.cHelpURL)
		This.cMRUTable = Forceext(_Screen.oSKOptions.cMRUTable, [dbf])
		This.cDefaultCommand = _Screen.oSKOptions.cDefaultCommand
		This.cTestArea = _Screen.oSKOptions.cTestArea
		If _Screen.oSKOptions.nFontSize < 6
		  This.nFontSize = _Screen.FontSize
		Else
		  This.nFontSize = _Screen.oSKOptions.nFontSize
		Endif
		If _Screen.oSKOptions.lGridAuto
		  This.AddOption([b])
		Endif
		If _Screen.oSKOptions.lnewfirst
		  This.AddOption([n])
		Endif
		Do Case
		  Case _Screen.oSKOptions.nDisplayCase = 1
		    This.cDisplayCase = [lower]
		  Case _Screen.oSKOptions.nDisplayCase = 2
		    This.cDisplayCase = [proper]
		  Otherwise
		    This.cDisplayCase = [Upper]
		Endcase
		Do Case
		  Case _Screen.oSKOptions.npathreturned = 1 && Relative Path
		    This.cPathReturned = [r]
		  Case _Screen.oSKOptions.npathreturned = 2 && FullPath
		    This.cPathReturned = [f]
		  Otherwise
		    This.cPathReturned = [] && No path
		Endcase
		This.cSKFile = [sk_]
		If Not File(This.cMRUTable)
		  Select 0
		  If Directory([data])
		    lcFolder = [data]
		  Else
		    lcFolder = []
		  Endif
		  Create Table (Forcepath(This.cMRUTable, m.lcFolder))  (FullName Char(240), Module Char(100), Method Char(40), Lineno Integer, Descript Char(40), Datetime  Datetime, Active L, External L)
		  Select (This.nSelect)
		Endif
		
	ENDPROC

	PROCEDURE readregistryoption
		Lparameters tcOption
		Local lcReturn
		
		tcOption = Evl(m.tcOption, [EditorCommentString])
		lcReturn = Execscript(_Screen.cThorDispatcher, [Thor_Proc_GetRegistryOption.prg], m.tcOption )
		Return m.lcReturn
	ENDPROC

	PROCEDURE removedoublecharacter
		Lparameters tcText, tcCharacter
		Local lcString
		
		If Pcount() < 2
		  tcCharacter = Space(1)
		Endif
		lcString = Replicate(m.tcCharacter, 2)
		Do While m.lcString $ m.tcText
		  tcText = Strtran(m.tcText, m.lcString, m.tcCharacter)
		Enddo
		Return m.tcText
	ENDPROC

	PROCEDURE removeprocendproc
		Lparameters tcCode
		#Define crlf Chr(13)+Chr(10)
		Local lcLine, lcReturn, lcWord, lnLines, lnSelect, lnX
		
		Local Array laCode[1]
		
		lnSelect = Select()
		lnLines = Alines(laCode, m.tcCode)
		Select 0
		Create Cursor curCode (cCode c(254))
		For lnX = 1 To m.lnLines
		  lcLine = m.laCode(m.lnX)
		  lcWord = Lower(Getwordnum(m.lcLine, 1))
		  Do Case
		    Case Empty(m.lcLine)
		      Loop
		    Case Left(m.lcWord, 4) = [func]
		      Loop
		    Case Left(m.lcWord, 4) = [proc]
		      Loop
		    Case Left(m.lcWord, 4) = [endp]
		      Exit
		    Case Left(m.lcWord, 5) = [endfu]
		      Exit
		    Otherwise
		      Insert Into curCode (cCode) Values (m.lcLine)
		  Endcase
		Endfor
		lcReturn = []
		Scan
		  lcReturn = m.lcReturn + cCode + crlf
		Endscan
		Select (m.lnSelect)
		Return m.lcReturn
	ENDPROC

	PROCEDURE replacecurrentline
		Lparameters tcText
		This.CutCurrentLine()
		This.WriteCurrentLine(m.tcText)
		
	ENDPROC

	PROCEDURE restoreselection
		This.oEditor.Select(This.nSelStart, This.nSelEnd)
	ENDPROC

	PROCEDURE returnunknowncommand
		Lparameters tnText
		Local lcText
		
		#Define ccUnknownCommand 'Illegal command'
		
		_Cliptext = This.cClip
		Do Case
		  Case Empty(m.tnText)
		    lcText = ccUnknownCommand + [!]
		  Case m.tnText = 1
		    lcText = ccUnknownCommand + [ in this window!]
		Endcase
		This.GiveMessage(ccUnknownCommand, , m.lcText, This.nTimeOut)
		
	ENDPROC

	PROCEDURE runed
		Lparameters tcPar
		Local lcAlias, lcCommand, lcExt, lcFile, lcFolder, lcMethod, lcObject, lcParOrg, lcParam1
		Local lcParameters, llRun, lnLine, lnLineNo, lnNew, loTools
		
		#Define ccPipe "|"
		#Define ccAmp  [&] + [&]
		#Define ccUnknownCommand 'Illegal command'
		lcParOrg = m.tcPar
		If Getwordnum(m.tcPar, 1) == This.cRun
		  llRun = .T.
		  tcPar = Substr(m.tcPar, Len(This.cRun) + 2 )
		Endif
		If Occurs(["], m.tcPar) > 0 And Occurs(["], m.tcPar) % 2 = 0
		  tcPar = Chrtran(m.tcPar, ["], ['])
		Endif
		lcParam1 = m.tcPar
		If Empty(m.tcPar) Or (Val(m.tcPar) > 0 And m.tcPar = Transform(Val(m.tcPar)))
		  lnLine = Val(m.tcPar)
		  lnLine = Evl(m.lnLine, 1)
		  If File(This.cSidekickFile )
		    lcParam1 = This.GetNumberedline(This.cSidekickFile, m.lnLine )
		  Else
		    Return .T.
		  Endif
		Endif
		If m.lcParam1 = [0]
		  lcParam1 = This.cSidekickFile
		Endif
		lcParam1 = Chrtran(m.lcParam1, ccPipe, [])
		lcParam1 = Alltrim(m.lcParam1, 0, [!], Chr(13))
		If ccAmp $ m.lcParam1
		  lcParam1 = Left(m.lcParam1, At(ccAmp, m.lcParam1) - 1)
		Endif
		If [(] $ m.lcParam1 And ! Inlist(Getwordnum(m.lcParam1, 1), This.cRun, [do])
		  lcParam1 = Evaluate(m.lcParam1)
		  If Vartype(m.lcParam1) = [L] && Function was called
		    Return .T.
		  Endif
		Endif
		lcFolder = [classes\]
		lnLineNo = Int(Val(Strextract(m.lcParam1, [:], [], Occurs([:], m.lcParam1))))
		If m.llRun And (Empty(Justext(m.lcParam1)) Or [.vcx] $ m.lcParam1)
		  Try
		    Execscript(m.lcParam1)
		  Catch
		    llRun = .F.
		  Endtry
		Endif
		If m.llRun
		  Return .T.
		Endif
		Do Case
		  Case Empty(Justext(m.lcParam1)) And Right(m.lcParam1, 1) # [)] And !Inlist(Lower(Left(m.lcParam1, 4)), [http], [mail])
		    Do Case
		      Case This.cCommand == [ed]
		        Return .F.
		      Case This.cCommand == [dr]
		        This.GiveMessage([No file found!])
		        Return .F.
		      Otherwise
		        lcExt = [prg]
		        lcParam1 = Forceext(m.lcParam1, m.lcExt)
		    Endcase
		  Case [.scx] $ Lower(m.lcParam1)
		    lcExt = [scx]
		  Case [.vcx] $ Lower(m.lcParam1)
		    lcExt = [vcx]
		  Case [.prg] $ Lower(m.lcParam1)
		    lcExt = [prg]
		  Case Occurs([.], m.lcParam1) = 1
		    lcExt = Lower(Justext(m.lcParam1))
		  Case [.txt] $ Lower(m.lcParam1)
		    lcExt = [txt]
		  Case [.sk] $ Lower(m.lcParam1)
		    lcExt = [sk]
		  Otherwise
		    lcExt = []
		Endcase
		lcFile = Strextract(m.lcParam1, [], m.lcExt, 1, 1 + 4)
		lcFile = Chrtran(m.lcFile, ['], [])
		Do Case
		  Case Getwordnum(m.tcPar, 1) == [do]
		    This.TryExecute(m.tcPar)
		  Case Inlist(Lower(Strextract(m.lcParam1, [], [:], 1, 4)), [http:], [https:])
		    This.ShellX(m.lcParam1)
		  Case Inlist(m.lcExt, [exe], [com], [bat])
		    This.ShellX(m.tcPar)
		  Case m.lcExt = [sk]
		    Modify Command (m.tcPar) Nowait
		  Case m.lcExt = [vcx] Or m.lcExt = [scx]
		    lcParam1 = Lower(m.lcParam1)
		    If [:] $ m.lcParam1
		      lcParameters = Strextract(m.lcParam1, m.lcExt + [.], [:])
		    Else
		      lcParameters = Strextract(m.lcParam1, m.lcExt + [.])
		    Endif
		    lcObject = Getwordnum(m.lcParameters, 1, [.])
		    lcMethod = Substr(m.lcParameters, Len(m.lcObject) + 2)
		    loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		    m.loTools.EditSourceX(m.lcFile, m.lcObject, m.lcMethod, m.lnLineNo)
		  Case Getwordnum(m.lcParam1, 1) = This.cRun
		    lcCommand = Ltrim(Strextract(m.lcParam1, This.cRun, []))
		    Try
		      Execscript(m.lcCommand)
		    Catch
		      Try
		        Do (m.lcCommand)
		      Catch
		        Try
		          Execscript(Juststem(m.lcCommand))
		        Catch
		          This.GiveMessage(ccUnknownCommand, , m.lcCommand)
		        Endtry
		      Endtry
		    Endtry
		  Case m.lcExt = [prg]
		    If m.lnLineNo > 0
		      If Occurs([:], m.lcParam1) > 1 And At([:], m.lcParam1, 2) > 2
		        lcParam1 = Left(m.lcParam1, At([:], m.lcParam1, Occurs([:], m.lcParam1)) - 1)
		      Endif
		      Editsource(m.lcFile, m.lnLineNo)
		    Else
		      If Lower(Getwordnum(m.lcParam1, 1)) = [ed]
		        lcParam1 = Substr(m.lcParam1, 3)
		      Endif
		      loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		      m.loTools.EditSourceX(Fullpath(m.lcParam1 ))
		    Endif
		  Case m.lcExt = [dbf]
		    lcAlias = Juststem(m.lcFile)
		    Select (Select(m.lcAlias))
		    Use (m.lcFile)
		    If Ascan(This.aInUse, m.lcAlias, -1, -1, 1, 15) = 0
		      lnNew = Alen(This.aInUse, 1) + 1
		      Dimension This.aInUse(m.lnNew, 2)
		      This.aInUse(m.lnNew, 1) = m.lcAlias
		      This.aInUse(m.lnNew, 2) = Select()
		    Endif
		    This.sk_br()
		  Case m.lcParam1 = [.*]
		    Return
		  Otherwise
		    loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		    m.loTools.EditSourceX(Fullpath(m.lcParam1 ))
		Endcase
		
	ENDPROC

	PROCEDURE runprogram
		Lparameters tcFile
		Local lcCommand, lcExt
		
		lcExt = Lower(Justext(m.tcFile))
		Do Case
		  Case m.lcExt = [prg]
		    lcCommand = Textmerge([do <<m.tcFile>>])
		  Case m.lcExt = [scx]
		    lcCommand = Textmerge([do form <<m.tcFile>>])
		Endcase
		Try
		  Execscript(m.lcCommand)
		Catch
		  This.GiveMessage([Can not run file!], 48, m.tcFile)
		Endtry
		
		
	ENDPROC

	PROCEDURE runsidekickline
		Lparameters tcCommand
		Do Case
		  Case Getwordnum(m.tcCommand, 1) = [do]
		    Execscript(m.tcCommand)
		  Case Getwordnum(m.tcCommand, 1) = This.cRun
		    tcCommand = Alltrim(Strextract(m.tcCommand, This.cRun, []), 0, Chr(10), Chr(13), Chr(31), Chr(32))
		    Execscript(m.tcCommand)
		  Otherwise
		    Try
		      Execscript(m.tcCommand)
		    Catch
		      This.RunEd(m.tcCommand )
		    Endtry
		Endcase
		
	ENDPROC

	PROCEDURE scanallwindows
		Lparameters toWindows, tnCallerHandler, tnPrefix, tnEdType
		Local lcCode, lcPrefix, lcReturn, lnHandle, loWindow
		
		#Define crlf Chr(13)+Chr(10)
		Do Case
		  Case Empty(m.tnPrefix )
		    lcPrefix = []
		  Case m.tnPrefix = -1
		    lcPrefix = [] && [0 ]
		  Otherwise
		    lcPrefix = Transform(m.tnPrefix) + [ ]
		Endcase
		lcReturn = []
		For Each m.loWindow In m.toWindows FoxObj
		  lnHandle = m.loWindow.nWHAndle
		  If m.lnHandle = m.tnCallerHandler
		    Loop
		  Endif
		  lcCode = This.GetEditSourceCode(m.lnHandle, m.tnEdType, m.lcPrefix)
		  If !Empty(m.lcCode)
		    If Empty(m.lcReturn )
		      lcReturn = m.lcCode
		    Else
		      lcReturn = m.lcReturn + crlf + m.lcCode
		    Endif
		  Endif
		Endfor
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE setupgrid
		This.oGrid = Createobject([pg])
		This.oGrid.Visible = .T.
		
	ENDPROC

	PROCEDURE setupregistry
		This.oRegistry = Createobject([vfpxregistry])
	ENDPROC

	PROCEDURE shellx
		Lparameters tcURL, tcCommand, tcParameter
		tcCommand = Evl(m.tcCommand, [open])
		tcParameter = Evl(m.tcParameter, [])
		#Define SW_HIDE 0
		#Define SW_SHOWNORMAL 1
		#Define SW_SHOWMINIMIZED 2
		#Define SW_SHOWMAXIMIZED 3
		*!*   Legal verbs: open, edit, print, find, explore, NULL
		Declare Integer ShellExecute In shell32.Dll ;
		  Integer hndWin, String cAction, String cFileName, ;
		  String cParams, String cDir, Integer nShowWin
		ShellExecute( 0, m.tcCommand, m.tcURL, m.tcParameter, [], SW_SHOWNORMAL )
	ENDPROC

	PROCEDURE showcase
		Lparameters tcText
		If !Inlist(Lower(This.cDisplayCase), [upper], [lower], [proper])
		  This.cDisplayCase = [lower]
		Endif
		Return Evaluate(Textmerge([Trim(<<this.cDisplayCase>>(m.tcText))]))
		
		
	ENDPROC

	PROCEDURE skfactory
		Local lcMethod, llSuccess
		
		lcMethod = [sk_] + This.cCommand
		llSuccess = .F.
		
		If !Pemstatus(_Screen, [lTry], 5)
		  _Screen.AddProperty([lTry],.F.)
		Endif
		Do Case
		  Case File(Forceext( m.lcMethod, [.prg]))
		    _Screen.AddProperty([oSidekick], This)
		    Set Step On
		    If Empty(This.cParameter)
		      Do (m.lcMethod )
		    Else
		      Do (m.lcMethod ) With This.cParameter
		    Endif
		    Removeproperty(_Screen, [osidekick])
		    _Screen.osidekick = .Null.
		    llSuccess = .T.
		  Otherwise
		    If Pemstatus(This, m.lcMethod, 5)
		      lcMethod = [this.] + m.lcMethod + [()]
		      If _Screen.ltry
		        Try
		          Public goError
		          Evaluate(m.lcMethod)
		          llSuccess = .T.
		        Catch To m.goError
		          Wait Window [Cannot evaluate ] + m.lcMethod At 10, 25
		        Finally
		        Endtry
		      Else
		        llSuccess = Evaluate(m.lcMethod)
		      Endif
		    Endif
		Endcase
		If m.llSuccess
		  Release m.goError
		Endif
		Return m.llSuccess Or This.lsuccess
	ENDPROC

	PROCEDURE sk_be
		Local lcText, lcWord1, lcWord2
		
		If This.nWindowType = 0
		  Return
		Endif
		#Define crlf Chr(13)+Chr(10)
		lcWord1 = Getwordnum(This.cParameter, 1, [, ])
		lcWord2 = Getwordnum(This.cParameter, 2, [, ])
		If Empty(m.lcWord1) Or Empty(m.lcWord2) Or ![.] $ m.lcWord1 Or ![.] $ m.lcWord2
		  This.GiveMessage([syntax: BE object1.event1,object2.event2], 0 + 64, [Invalid Parameters(s)], 5000)
		Else
		  lcText = Textmerge([Bindevent(<<Juststem(lcWord1)>>, "<<Justext(lcWord1)>>", <<Juststem(lcWord2)>>, "<<Justext(lcWord2)>>")])
		  This.ReplaceCurrentLine(m.lcText + crlf)
		Endif
	ENDPROC

	PROCEDURE sk_br
		Local lcAlias, lcFile, lnSelect
		If !Empty(This.cParameter) And Getwordcount(This.cParameter) = 1 And This.cCommand == [br]
		  lcAlias = Juststem(This.cParameter)
		  If File(Forceext(m.lcAlias, [dbf]))
		    Select Select(m.lcAlias)
		    Use (m.lcAlias)
		    This.DoBrowModal()
		  Else
		    If Len(this.cParameter) = 1 and Empty(Chrtran(this.cParameter,'*,.-',''))
		      this.cParameter = '*'
		    Endif
		    lcFile = This.ListFiles([dbf])
		
		    If Empty(m.lcFile)
		      This.GiveMessage([No table selected!])
		    Else
		      lnSelect = Select(Juststem(m.lcFile))
		      Select (m.lnSelect)
		      Use (m.lcFile)
		      This.DoBrowModal()
		      If m.lnSelect = 0
		        Use
		      Endif
		    Endif
		  Endif
		Else
		  If !Empty(Dbf())
		    If [i] $ This.cOption
		      This.IndexFields()
		    Endif
		    This.DoBrowModal()
		  Else
		    this.cParameter = '*'
		    this.sk_br()
		  Endif
		Endif
		Use in Select(this.cCursor)
		
	ENDPROC

	PROCEDURE sk_db
		Local lcParameter, lcReturn, lldbo
		
		lldbo = [x] $ This.cOption
		lcParameter = This.cParameter
		If Left(m.lcParameter, 1) = [=]
		  lcParameter = Substr(m.lcParameter, 2)
		Endif
		If Empty(m.lcParameter ) Or Getwordcount(m.lcParameter ) > 1
		  Return
		Endif
		If !m.lldbo
		  lcReturn = Textmerge([DebugOut '<<Strtran( m.lcParameter ,'m.','') >>', <<m.lcParameter >>])
		Else
		  lcReturn = Textmerge([?'<<Strtran( m.lcParameter ,'m.','') >>', <<m.lcParameter >>])
		Endif
		This.ReplaceCurrentLine(m.lcReturn)
		This.lsuccess = .T.
	ENDPROC

	PROCEDURE sk_dd
		Local lcResult
		
		If This.nWindowType # 10
		  Return
		Endif
		#Define ccCR Chr(13)
		
		lcResult = [DoDefault(] + _oPEMEditor.oUtils.oBeautifyX.FetchParametersList() + [)] + ccCR
		This.ReplaceCurrentLine(m.lcResult)
	ENDPROC

	PROCEDURE sk_def
		Lparameters tcProject
		Local lcParam1
		If !This.CheckOrCreateSidekickFile()
		  Return
		Endif
		lcParam1 = This.GetLineNo(This.cSidekickFile, 1)
		If InList(Lower(Getwordnum(m.lcParam1, 1)) , [default], '*default')
		  m.lcParam1 = Chrtran(m.lcParam1,'*','')
		  lcParam1 = Getwordnum(m.lcParam1, Getwordcount(m.lcParam1 ))
		
		Else
		  This.GiveMessage([No Default group defined in ] + This.cSidekickFile, 0)
		  Return
		Endif
		If !Empty(m.tcProject)
		  lcParam1 = m.tcProject
		Endif
		If Val(m.lcParam1) # 0
		  This.GetLinesToProcess(Val(m.lcParam1))
		Else
		  This.RunEd(m.lcParam1)
		Endif
		
	ENDPROC

	PROCEDURE sk_desc
		#Define ccCR Chr(13)
		Local lcText
		
		Do Case
		  Case This.nWindowType = 0 && Command window
		    Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		    This.ListDescript()
		  Case Inlist(This.nWindowType, 1, 2) && Program or text file
		    If This.nLineno < This.nMaxDescriptLine
		      If Empty(This.cParameter)
		        lcText = This.cDescriptionMask1 + Space(3) + This.cDescriptionMask2 + ccCR
		      Else
		        lcText = This.cDescriptionMask1 + [ ] + This.cParameter + [ ] + This.cDescriptionMask2 + ccCR
		      Endif
		      This.oEditorWin.Delete()
		      This.oEditorWin.Insert(m.lcText)
		      If Empty(This.cParameter)
		        This.oEditorWin.SetInsertionPoint(This.oEditorWin.GetSelStart() - 4)
		      Endif
		    Else
		      Wait Window Textmerge([Current line number is outside the Description range (1 to <<this.nMaxDescriptLine>>)!])
		    Endif
		Endcase
	ENDPROC

	PROCEDURE sk_dr
		This.ListFiles(This.cParameter)
	ENDPROC

	PROCEDURE sk_ec
		* Execute Clipboard
		Do Case
		  Case !Empty(This.cParameter)
		    Try
		      Execscript(This.cParameter )
		    Catch
		      This.GiveMessage(Textmerge([Unknown command "<<this.cParameter>>"!]))
		    Endtry
		  Case [C] = Vartype(This.cClip )
		    Try
		      Execscript(This.cClip)
		    Catch
		      This.GiveMessage([Can't execute the clipboard], 48, [], 3000)
		    Endtry
		  Otherwise
		    This.GiveMessage([Illegal command!])
		Endcase
		
	ENDPROC

	PROCEDURE sk_ed
		Local llSuccess
		llSuccess = .F.
		Do Case
		  Case InList(JustExt(this.cParameter),'exe','bat','com')
		    this.ShellX(this.cParameter)  
		  Case This.cParameter == [-]
		    This.sk_def()
		  Case Left(This.cParameter, 1) = [!]
		    This.RunEd(Substr(This.cParameter, 1))
		  Case Empty(This.cParameter) Or Inlist(This.cParameter, [?], [*]) Or [w] $ This.cOption && List ALL files
		    This.cParameter = Chrtran(This.cParameter, [?*], [])
		    This.ListFiles([*])
		  Case Occurs([.], This.cParameter) > 1 && object in a vcx or scx
		    This.RunEd(This.cParameter)
		  Case Occurs([.], This.cParameter) = 1;  && File extension given
		    Or !This.cParameter = Transform(Val(This.cParameter))
		    This.AddOption([a])
		    This.ListFiles(This.cParameter)
		  Case !Empty(This.cParameter) And This.cParameter # [0] And Val(This.cParameter) = 0 And Getwordcount(This.cParameter) = 1
		    This.AddOption([a])
		    This.ListFiles(This.cParameter)
		  Case This.cParameter = Transform(Val(This.cParameter))
		    If This.cParameter = [0]
		      Modify Command (This.cSidekickFile ) Nowait
		    Else
		      This.GetLinesToProcess(Val(This.cParameter))
		    Endif
		  Otherwise
		    This.RunEd(This.cParameter)
		Endcase
	ENDPROC

	PROCEDURE sk_equ
		#Define ccCR Chr(13)
		Local lcMethod, lcProcedure, lcText, llSuccess, lnFiles
		
		llSuccess = .F.
		lcProcedure = Set([Procedure])
		*!*  lnFiles = This.GetFilesInPath([prg], This.cCursor)
		
		If File([myscrap.prg])
		  Set Procedure To [myscrap] Additive
		Endif
		lcMethod = This.cParameter
		lcText = []
		If !Right(m.lcMethod, 1) = [)]
		  lcMethod = m.lcMethod + [()]
		Endif
		Try
		  Public goError
		  lcText = Transform(Evaluate(m.lcMethod))
		  llSuccess = .T.
		Catch To m.goError
		  This.GiveMessage([No or invalid result!], 0 + 48, m.lcMethod )
		Endtry
		If m.llSuccess
		  Release m.goError
		Endif
		Release Procedure [myscrap]
		If !Empty(m.lcText)
		  This.ReplaceCurrentLine(m.lcText + ccCR)
		Endif
		
		
	ENDPROC

	PROCEDURE sk_err
		Local lcCursor, lcMessage, lnErrors, lnX
		
		lnErrors = Alen(This.aInError)
		If m.lnErrors < 2
		  Messagebox( [No error to report])
		  Return
		Endif
		lcCursor = [CurError]
		If This.aInError(1, 1) = 1526 && ODBC error
		  Create Cursor (m.lcCursor) (No i, Element N(1), Descript c(30), Message c(200) Null)
		Else
		  Create Cursor (m.lcCursor) (Element N(1), Descript c(30), Message c(200) Null)
		Endif
		lnX = 1
		Do Case
		  Case This.aInError(1, 1) = 1526 && ODBC error
		    For lnX = 1 To m.lnErrors
		      Insert Into (m.lcCursor) Values (m.lnX, 1, [Error number], Transform(This.aInError(m.lnX, 1)))
		      Insert Into (m.lcCursor) Values (m.lnX, 2, [Error message], This.aInError(m.lnX, 2))
		      Insert Into (m.lcCursor) Values (m.lnX, 3, [ODBC error message], This.aInError(m.lnX, 3))
		      Insert Into (m.lcCursor) Values (m.lnX, 4, [ODBC SQL state], This.aInError(m.lnX, 4))
		      Insert Into (m.lcCursor) Values (m.lnX, 5, [ODBC error no.], Transform(This.aInError(m.lnX, 5)))
		      Insert Into (m.lcCursor) Values (m.lnX, 6, [ODBC connection handle], Transform(This.aInError(m.lnX, 6)))
		    Endfor
		  Case Inlist(This.aInError(1, 1), 1427, 1429) && Ole error
		    Insert Into (m.lcCursor) Values (1, [Error number], Transform(This.aInError(m.lnX, m)))
		    Insert Into (m.lcCursor) Values (2, [VFP error message], This.aInError(m.lnX, 2))
		    Insert Into (m.lcCursor) Values (3, [OLE error message], This.aInError(m.lnX, 3))
		    Insert Into (m.lcCursor) Values (4, [Application name], This.aInError(m.lnX, 4))
		    If !Isnull(This.aInError(m.lnX, 5))
		      Insert Into (m.lcCursor) Values (5, [Application help file], This.aInError(m.lnX, 5))
		      Insert Into (m.lcCursor) Values (6, [Application help context id], This.aInError(m.lnX, 6))
		    Endif
		    Insert Into (m.lcCursor) Values (7, [OLE 2.0 exception number], Transform(This.aInError(m.lnX, 7)))
		  Otherwise
		    Insert Into (m.lcCursor) Values (1, [Error number], Transform(This.aInError(m.lnX, 1)))
		    Insert Into (m.lcCursor) Values (2, [Error message], This.aInError(m.lnX, 2))
		    If !Isnull(This.aInError(m.lnX, 3))
		      Insert Into (m.lcCursor) Values (3, [Parameters], This.aInError(m.lnX, 3))
		    Endif
		    If !Isnull(This.aInError(m.lnX, 4))
		      Insert Into (m.lcCursor) Values (4, [Work area], Transform(This.aInError(m.lnX, 4)))
		    Endif
		    If !Isnull(This.aInError(m.lnX, 5))
		      Do Case
		        Case This.aInError(m.lnX, 5) = 1
		          lcMessage = [Insert trigger failed]
		        Case This.aInError(m.lnX, 5) = 1
		          lcMessage = [Update trigger failed]
		        Otherwise
		          lcMessage = [Delete trigger failed]
		      Endcase
		      Insert Into (m.lcCursor) Values (5, [Trigger error], m.lcMessage )
		    Endif
		Endcase
		This.GetDataFromGrid([Current error:], , , , [N])
		
	ENDPROC

	PROCEDURE sk_es
		* EditSource builder
		#Define crlf Chr(13)+Chr(10)
		Local lcCallerName, lcCommand, lcFullName, lcProject, lcText, llClip, llNewProject, lnCallerHandle
		Local lnCallerType, lnEdType, lnLength, lnProject, loWindows
		
		lcText = This.cParameter
		lnCallerType = This.nWindowType
		If m.lnCallerType > 0
		  If This.oEditorWin.nHandle = 10
		    This.oEditorWin.nHandle = This.nHandle
		  Endif
		  lcCallerName = Lower(This.oEditorWin.GetTitle())
		  lcFullName = Fullpath(m.lcCallerName)
		Endif
		lnCallerHandle = This.nHandle
		If m.lnCallerType < 0 && Or (m.lnCallerType = 0 And Empty(m.lcCallerName))
		  Wait Window [Not legal from this window] At 10, 25 Timeo 5
		  Return
		Endif
		lnProject = 0
		loWindows = This.oEditorWin.GetOpenWindows()
		llClip = .T.
		lnEdType = 1
		llNewProject = .F.
		Do Case
		  Case Inlist( m.lnCallerType, 1, 2) And Justext(m.lcCallerName) == [sk] && m.lcCallerName = Lower(This.cSidekickFile)
		    lnEdType = 4 && Only number, Ed syntax
		    Do Case
		      Case Left(m.lcText, 1) = [+] && find next group
		        lnProject = This.GetNextProject()
		        lcText = Substr(m.lcText, 2)
		        If Empty(Left(m.lcText, 1))
		          lcProject = Getwordnum(m.lcText, 1)
		          lcText = []
		        Else
		          lcProject = Getwordnum(m.lcText, 2)
		          lcText = Getwordnum(m.lcText, 1)
		        Endif
		        llNewProject = .T.
		      Case Val(m.lcText) > 0
		        lnProject = Int(Val(m.lcText))
		        lnLength = Len(Transform(m.lnProject))
		        lcText = Substr(m.lcText, m.lnLength + 1 )
		      Otherwise
		        lnProject = -1
		    Endcase
		    Do Case
		      Case Inlist(Lower(m.lcText), [x], [editsourcex], [edx], [ex])
		        lnEdType = 3
		      Case Inlist(Lower(m.lcText), [s], [editsource], [eds], [ed])
		        lnEdType = 1
		      Case Inlist(Lower(m.lcText), [e], [es])
		        lnEdType = 2
		    Endcase
		    lcCommand  = This.ScanAllWIndows(m.loWindows, m.lnCallerHandle, m.lnProject, m.lnEdType)
		    This.oEditorWin.SelectWindow(m.lnCallerHandle)
		    This.CutCurrentLine()
		    If m.llNewProject
		      lcProject = Evl(m.lcProject, [New group])
		      lcProject = Inputbox([Type new group name: ], [], m.lcProject)
		      lcProject = Evl(m.lcProject, [New group])
		      lcCommand = [#] + Transform(m.lnProject) + [ ] + m.lcProject + crlf + crlf + m.lcCommand
		    Endif
		    If !Empty(m.lcCommand) And This.GiveMessage([Paste the following code:] + crlf + m.lcCommand, 4 + 64, [Current file is ] + This.cSidekickFile ) = 6
		      This.WriteCurrentLine(m.lcCommand)
		    Else
		      Wait Window At 10, 25 [Operation cancelled!] Timeout 2
		    Endif
		  Case m.lnCallerType >= 0
		    Do Case
		      Case [s] $ Lower(m.lcText) Or [s] $ This.cOption
		        lnEdType = 1
		      Case [e] $ Lower(m.lcText) Or [e] $ This.cOption
		        lnEdType = 2
		      Case [x] $ Lower(m.lcText) Or [x] $ This.cOption
		        lnEdType = 3
		      Case [n] $ Lower(m.lcText)
		        lnEdType = 4
		    Endcase
		    If Left(Lower(m.lcText), 3) = [all]
		      lcCommand  = This.ScanAllWIndows(m.loWindows, m.lnCallerHandle, m.lnProject, m.lnEdType)
		      This.oEditorWin.SelectWindow(m.lnCallerHandle)
		      This.CutCurrentLine()
		      If !Empty(m.lcCommand) And  This.GiveMessage([Paste the following code:] + crlf + m.lcCommand, 4 + 64, [Current file is ] + This.cSidekickFile ) = 6
		        This.WriteCurrentLine(m.lcCommand)
		      Else
		        Wait Window At 10, 25 [Operation cancelled!] Timeout 2
		      Endif
		    Else
		      If m.lnCallerType > 0
		        lcCommand = This.GetEditSourceCode(m.lnCallerHandle, m.lnEdType, [])
		        This.CutCurrentLine()
		        If !Empty(m.lcCommand)
		          If This.GiveMessage( [Copy this code to the clipboard?] + crlf + m.lcCommand, 4 + 32, [Generated code!]) = 6
		            This.cClip = m.lcCommand
		          Else
		            Wait Window At 10, 25 [Operation cancelled!] Timeout 2
		          Endif
		        Endif
		      Else
		        This.GiveMessage([Illegal command!], 0 + 48, [This function only works in code windows!], 3000)
		      Endif
		    Endif
		  Case Empty(m.lcCallerName)
		    This.GiveMessage( [Select a program or text file, or a method, first!], 0 + 48, [Not applicable from here!], 3000)
		  Otherwise
		    This.GiveMessage([Illegal command!], 0 + 48, [This function only works in code windows!], 3000)
		Endcase
		This.lsuccess = .T.
		This.oEditorWin.SelectWindow(m.lnCallerHandle)
		
	ENDPROC

	PROCEDURE sk_ff		&& Utility to fine file in folder and subfolders
		Local lcFile, lcFileMask, lcFolder, lnLastKey
		
		lcFolder = Curdir()
		If Getwordcount(This.cParameter) = 1
		  lcFileMask = This.cParameter
		Else
		  lcFileMask = [*.*]
		Endif
		This.AddOption([r])
		Wait Window [Processing files and folders!] At 10, 25 Nowait Noclear
		This.GetFilesAndSubfolders(m.lcFolder, m.lcFileMask)
		Wait Clear
		Select (This.cCursor)
		If Reccount() > 0
		  This.IndexFields()
		  Set Order To
		  This.sk_br()
		  lnLastKey = Lastkey()
		  If m.lnLastKey = 13
		    lcFile = Alltrim(Evaluate(This.cCursor + [.filename]))
		    If 'y'$this.cOption or This.GiveMessage([Place the filename in the clipboard?], 4 + 32, m.lcFile ) = 6
		      This.cClip = m.lcFile
		      If 'y'$this.cOption
		        MessageBox( m.lcFile + ' is copied to the clipboard.',0+64,'Sidekick',this.nTimeOut)
		      Endif
		    Endif
		  Endif
		Else
		  This.GiveMessage([No matching records!], 0 + 64, This.cParameter)
		Endif
		
	ENDPROC

	PROCEDURE sk_fl
		Local lcFile, lcPar, llConfirm, lnLastKey
		
		lcPar = This.cParameter
		Do case 
		  Case Left(m.lcPar, 1) == [.]
		    lcPar = Substr(m.lcPar, 2)
		  Case right(m.lcPar, 1) == [.]
		    lcPar = lcPar + '*'
		Endcase
		*!*  If Left(m.lcPar, 1) == [.]
		*!*    lcPar = Substr(m.lcPar, 2)
		*!*  Endif
		
		If This.GetFilesInPath(m.lcPar, ,.T.) > 0
		  *!*  Set Step On 
		  This.AddOption([i])
		  This.sk_br()
		  lnLastKey = Lastkey()
		  If m.lnLastKey = 13
		    llConfirm = .T.
		    Do Case
		      Case [y] $ This.cOption
		      Case [q] $ This.cOption And This.GiveMessage([Place the filename in the clipboard?], 4 + 32, m.lcFile ) = 6
		      Otherwise
		        llConfirm = .F.
		    Endcase
		    If m.llConfirm
		      lcFile = Alltrim(Evaluate(This.cCursor + [.filename]))
		      This.cClip = m.lcFile
		      MessageBox( m.lcFile + ' is copied to the clipboard.',0+64,'Sidekick',this.nTimeOut)
		    Endif
		  Endif
		Else
		  This.GiveMessage([No match to ] + This.cParameter )
		Endif
		
	ENDPROC

	PROCEDURE sk_fp
		*Field picker
		Local lcAlias, lcFormFileName, lcReturn, lcTable
		
		If !Empty(This.cParameter)
		  lcAlias = This.cParameter
		Else
		  lcAlias = Alias()
		Endif
		If Empty(m.lcAlias) Or !Empty(This.cParameter)
		  This.cParameter = Iif(This.cParameter = [?], [], This.cParameter)
		  This.ListFiles([dbf])
		  If Lastkey() = 97
		    Wait Window [No table selected or specified] At 10, 25 Timeout 3
		    Return
		  Else
		    lcTable = Alltrim(FullName)
		    Select Select(Juststem(m.lcTable))
		    Use (m.lcTable)
		  Endif
		Endif
		lcAlias = Alias()
		If !Empty(m.lcAlias)
		  Execscript(_Screen.cThorDispatcher, [PEME_OpenTable], m.lcAlias)
		  lcFormFileName = Execscript(_Screen.cThorDispatcher, [Full Path=PEME_Snippet_FP.SCX])
		  Do Form (m.lcFormFileName) With m.lcAlias, [], [] To m.lcReturn
		  This.ReplaceCurrentLine(m.lcReturn)
		Else
		  This.GiveMessage([No table is selected!])
		Endif
		
	ENDPROC

	PROCEDURE sk_grp
		Local lcClip, lcText, lcWord, lnSelect, lnWords, lnX
		
		If This.nWindowType > 0 And !This.lInputBox
		  Return .F.
		Endif
		lnSelect = Select()
		lcClip = _Cliptext
		If This.nWindowType = 0 Or This.lInputBox
		  Select 0
		  Create Cursor curGroups (text1 c(240), Grouptxt c(3), Group c(50), Groupno i)
		  Append From (Forceext(This.cSidekickFile, [.sk])) Sdf
		  Replace All Grouptxt With Ltrim(Strextract(text1, [#], [ ], 1)),;
		    Groupno With Val(Strextract(text1, [#], [ ], 1))
		  If [x] $ This.cOption
		    Replace All Group With Strextract(text1, [ ], [], 1) For Groupno # 0
		    Select Grouptxt, Group  From curGroups x;
		      Where x.Groupno # 0 Order By Groupno;
		      Into Cursor curGroups Readwrite
		  Else
		    Replace All Group With Strextract(text1, [ ], [], 1) For Groupno > 0
		    Select Grouptxt, Group  From curGroups x;
		      Where x.Groupno > 0 Order By Groupno;
		      Into Cursor curGroups Readwrite
		  Endif
		  If _Tally > 0
		    Select Grouptxt As Groupno, Group  From curGroups Into Cursor curGroups Readwrite
		    If !Empty(This.cParameter)
		      lnWords = Getwordcount(This.cParameter)
		      For lnX = 1 To m.lnWords
		        lcWord = Getwordnum(This.cParameter, m.lnX)
		        Select * From curGroups Into Cursor curGroups Readwrite Where m.lcWord $ Lower(Groupno + [|] + Group)
		      Endfor
		    Endif
		    Go Top
		    lcText = This.GetDataFromGrid([Select group from ] + This.cSidekickFile, [groupno])
		    If !Empty(m.lcText)
		      This.sk_def(m.lcText )
		    Endif
		  Endif
		  This.CutCurrentLine()
		Endif
		Select (m.lnSelect)
		
		
	ENDPROC

	PROCEDURE sk_hei
		Local lcCursor, lcPar
		
		lcPar = This.cParameter
		lcPar = Evl(m.lcPar, [my*.prg])
		
		If This.GetFilesInPath(m.lcPar,,.T.   ) > 0
		  This.sk_br()
		Else
		  This.GiveMessage([No match!])
		Endif
		
	ENDPROC

	PROCEDURE sk_help
		This.RunEd(This.cSidekickHelp)
	ENDPROC

	PROCEDURE sk_hk
		#Define ccTool         'Browse all Thor Tools'
		Local lcDestAlias, lcHotkey, lcProg, lcWord, llExcludeNotUsed, lnWords, lnX
		
		Local Array laDummy[1]
		
		llExcludeNotUsed = Execscript(_Screen.cThorDispatcher, [Get Option=], ccTool, ccTool)
		lcDestAlias = [curHotKeys]
		Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		Select 0
		Execscript(_Screen.cThorDispatcher, [Thor_Proc_GetHotKeyDefs], m.lcDestAlias, m.llExcludeNotUsed )
		Select Distinct Cast(Descript As c(100)) As Descript, Chrtran(HotKey, [-], [+]) As HotKey, Cast([] As c(10)) As sortkey, PRGName, StatusBar From (m.lcDestAlias);
		  Where !Empty(HotKey ) And Substr(Descript, 3, 1) # [-] Into Cursor (m.lcDestAlias ) ;
		  Readwrite
		Scan
		  lcHotkey = HotKey
		  Select Recno() From (_Screen.Cthorfolder + [\source\hotkeys])  Hotkeys Where Hotkeys.Key = Substr(m.lcHotkey, 1 + Rat([+], m.lcHotkey ), 10) Into Array laDummy
		  Replace sortkey With Padl(m.laDummy, 2, [ ]) + m.lcHotkey
		Endscan
		Select Distinct HotKey, Descript, PRGName, sortkey From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Order By sortkey Readwrite
		Select HotKey, Descript, PRGName From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Readwrite
		lnWords = Getwordcount(This.cParameter)
		For lnX = 1 To m.lnWords
		  lcWord = Getwordnum(This.cParameter, m.lnX)
		  Select * From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Readwrite Where m.lcWord  $ Lower(HotKey + [|] + Descript + [|] + PRGName)
		Endfor
		This.IndexFields()
		If Reccount() = 0
		  This.GiveMessage([No match!])
		  Return
		Endif
		lcProg = This.GetDataFromGrid([Thor tools], [prgname], 1)
		Use
		If !Empty(m.lcProg)
		  Execscript(_Screen.cThorDispatcher, m.lcProg)
		Endif
		If !This.lSKComment
		  This.CutCurrentLine()
		Endif
		
		
	ENDPROC

	PROCEDURE sk_inc
		Local lcClip, lcParameter, lcText
		
		Local Array laHeaders[1]
		Local Array laList[1]
		
		If This.nWindowType = 0
		  Return
		Endif
		#Define ccCR Chr(13)
		lcParameter = This.cParameter
		If This.cCommand = [#] And Len(This.cCommand) > 1
		  lcParameter = Substr(This.cCommand, 2)
		Endif
		lcClip = _Cliptext
		Select 0
		If This.GetFilesInPath([H]) = 0
		  _Cliptext = This.cClip
		  Return
		Endif
		Select (This.cCursor)
		Select *, Cast([] As Memo) As Data From (This.cCursor) Into Cursor (This.cCursor) Readwrite
		Scan
		  Replace Data With Filetostr(Filename)
		Endscan
		If !Empty(m.lcParameter )
		  Select * From (This.cCursor) Into Cursor (This.cCursor) Readwrite Where m.lcParameter  $ Lower(Filename)
		Endif
		lcText = This.GetDataFromGrid([Select file:], This.cCursor + [.Filename])
		If !Empty(m.lcText)
		  This.ReplaceCurrentLine([#Include ] + m.lcText + ccCR)
		Endif
		
		
	ENDPROC

	PROCEDURE sk_ins
		Local lcCode, lcData, lcExtension, lcFile, lcMethod, lcProc, lcSource, lcText, lnProcs, lnSelect
		Local lnX
		
		Local Array laProc[1]
		
		If This.nWindowType = 0
		  Return
		Endif
		#Define crlf Chr(13)+Chr(10)
		lcMethod = Trim(Lower(This.cParameter))
		lcCode = []
		Do Case
		  Case [s] $ This.cOption
		    lcExtension = [scx]
		  Case [v] $ This.cOption
		    lcExtension = [vcx]
		  Otherwise
		    lcExtension = Justext(m.lcMethod)
		    lcExtension = Evl(m.lcExtension, [prg])
		Endcase
		If Inlist(Lower(Justext(m.lcMethod)), [prg], [h]) And !Empty(Juststem(m.lcMethod))
		  If File(m.lcMethod)
		    lcCode = Filetostr(m.lcMethod)
		  Else
		    This.GiveMessage([File not found!], 48, Alltrim(m.lcMethod))
		  Endif
		Else
		  lcText = []
		  lnSelect = Select()
		  Select 0
		  Do Case
		    Case Inlist(m.lcExtension, [vcx], [scx])
		      Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		      Create Cursor CurMethods (Filename c(240), Source c(240), Code m)
		      This.GetFilesInPath(m.lcExtension, [curprgs], .T.)
		      Scan
		        lcFile = curprgs.Filename
		        This.getMethdosFromClasslib(m.lcFile )
		      Endscan
		      If !Empty(m.lcMethod)
		        For lnX = 1 To Getwordcount(m.lcMethod)
		          lcText = Getwordnum(m.lcMethod, m.lnX )
		          Select * From CurMethods Into Cursor CurMethods Readwrite Where m.lcText $ Lower( Filename + [|] + Source)
		        Endfor
		      Endif
		      Wait Clear
		
		      Select CurMethods
		      If Reccount() > 0
		        lcCode = This.GetDataFromGrid([Select method to insert], [curmethods.code])
		        If !Empty(m.lcCode )
		          lcCode = CurMethods.Code
		        Endif
		      Else
		        This.GiveMessage([No match found!], 48, m.lcMethod)
		      Endif
		      lcMethod = Justext(Trim(CurMethods.Source))
		      lcSource = Trim(CurMethods.Source )
		    Case m.lcExtension = [prg]
		      Create Cursor CurMethods (Method c(240), Source c(240), Code m)
		      Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		      This.GetFilesInPath([prg], [curPrgs], .T.)
		      Scan
		        lcSource = Alltrim(curprgs.Filename)
		        lnProcs = Aprocinfo(laProc, curprgs.Filename, 0)
		        For lnX = 1 To m.lnProcs
		          If m.laProc(m.lnX, 3) = [Procedure] And (Empty(Juststem(m.lcMethod)) Or m.lcMethod $ Lower(m.laProc(m.lnX, 1)) Or Empty(m.lcMethod)) && And ![.] $ m.laProc(m.lnX, 1)
		            lcProc = m.laProc(m.lnX, 1)
		            lcCode = This.GetMethodFromPrg(m.lcProc, m.lcSource)
		            If [.] $ m.lcProc
		              lcProc = Justext(m.lcProc)
		            Endif
		            Insert Into CurMethods (Source, Method, Code) Values (m.lcSource, m.lcProc, m.lcCode )
		          Endif
		        Endfor
		      Endscan
		      Scan
		        lcSource = Alltrim(curprgs.Filename)
		        If Lower(m.lcMethod) $ Juststem(Lower(curprgs.Filename))
		          lcCode = Filetostr(curprgs.Filename)
		          lcText = [-->] + Juststem(curprgs.Filename)
		          Insert Into CurMethods (Source, Method, Code) Values (m.lcSource, m.lcText, m.lcCode )
		        Endif
		      Endscan
		      Select CurMethods
		      If !Empty(m.lcMethod)
		        Select * From CurMethods Into Cursor CurMethods Readwrite Where m.lcMethod $ Lower(Method + [|] + Source)
		      Endif
		      This.IndexFields('method')
		      *!*        Index On Lower(Method) Tag Method
		      *!*        Locate
		      Wait Clear
		      If Reccount() > 0
		        lcCode = This.GetDataFromGrid([Select method to insert], [curmethods.code])
		        If !Empty(m.lcCode )
		          lcCode = CurMethods.Code
		        Endif
		      Else
		        This.GiveMessage([No match found!], 48, m.lcMethod)
		      Endif
		      lcMethod = Trim(CurMethods.Method)
		      lcSource = Trim(CurMethods.Source )
		    Case m.lcExtension = [h]
		      Create Cursor CurMethods (Source c(240), Code m)
		      Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		      This.GetFilesInPath([h], [curPrgs], .T.)
		      Scan
		        lcFile = Alltrim(curprgs.Filename)
		        lcData = Filetostr(m.lcFile)
		        Insert Into CurMethods (Source, Code) Values (m.lcFile, m.lcData)
		      Endscan
		      Select CurMethods
		      This.IndexFields()
		      Wait Clear
		      If Reccount() > 0
		        lcCode = This.GetDataFromGrid([Select file to insert from], [curmethods.code])
		        If !Empty(m.lcCode )
		          lcCode = CurMethods.Code
		        Endif
		      Else
		        This.GiveMessage([No match found!], 48, m.lcMethod)
		      Endif
		
		    Otherwise
		      This.GiveMessage([This only works for .prg and .h files])
		  Endcase
		  Use In Select([curmethods])
		  Select (m.lnSelect)
		  Use In Select([curprgs])
		Endif
		If !Empty(m.lcCode)
		  If This.nWindowType = 10
		    lcCode = This.removeProcEndproc(m.lcCode)
		  Endif
		  lcCode = This.LeftTrimCode(m.lcCode )
		  This.ReplaceCurrentLine(m.lcCode + crlf)
		Endif
		
		
	ENDPROC

	PROCEDURE sk_lor
		Local lcText, lnLength
		
		lnLength = Val(This.cParameter)
		lnLength = Min(Evl(m.lnLength, 2), 122)
		Text To m.lcText Noshow Textmerge Pretext 1 + 2
		Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis dictum semper quam id imperdiet. Ut et arcu eu felis euismod tristique. Aliquam varius rutrum nibh, ut rhoncus nisl commodo a. Maecenas nisi neque, sagittis non dolor et, finibus vestibulum dui. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean augue orci, dictum a consectetur nec, dictum sit amet mauris. Morbi vitae mollis metus, pellentesque aliquet nunc.
		
		Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean consectetur, eros rhoncus eleifend porta, ipsum est fringilla nisi, vitae congue dui ante sit amet orci. Maecenas eget bibendum nibh, sit amet volutpat libero. Nulla a aliquam mi. Nullam mattis laoreet dapibus. Donec interdum est sit amet purus aliquet rutrum. Mauris ornare interdum malesuada. Vivamus a neque eu odio laoreet pellentesque eu ac felis.
		
		Nulla iaculis sem vestibulum elit pretium, quis imperdiet justo vulputate. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nulla facilisis tempus odio eu vulputate. Etiam tincidunt et metus quis dictum. Quisque non lectus fringilla, ullamcorper libero ut, scelerisque ex. Cras luctus erat sit amet rhoncus porttitor. Nam finibus volutpat arcu hendrerit dignissim. Proin bibendum nisl lacinia viverra fringilla. Vestibulum pellentesque quis mi non euismod. Etiam varius nibh et quam sagittis, nec hendrerit nisi elementum. Nulla aliquam turpis id orci suscipit, eu faucibus nisl venenatis. Duis lacinia felis nibh, sit amet consequat leo vestibulum vitae. Praesent eu sollicitudin nibh. Pellentesque iaculis non ipsum quis hendrerit. Donec ex est, malesuada vel ullamcorper vel, dapibus eget ligula.
		
		Etiam vel facilisis nunc. Cras sed nulla nec nunc mattis ullamcorper id nec augue. Curabitur vehicula orci sit amet odio facilisis semper. Praesent eu tempus ex. Fusce porttitor lectus dictum urna feugiat, nec aliquam dolor lacinia. Integer eget faucibus risus. Donec at purus quis tortor auctor fermentum aliquam sed elit. Quisque ac lorem in nibh fermentum tempor. In viverra odio ut neque tempus fringilla.
		
		Aenean quis sollicitudin eros. Nunc lacinia odio a velit feugiat, non posuere augue facilisis. Phasellus viverra justo risus, viverra facilisis nisi condimentum eu. Suspendisse nibh augue, aliquet nec efficitur nec, volutpat ac purus. Nunc vehicula ornare ornare. Nulla facilisi. Pellentesque quis enim quam. Maecenas mi felis, facilisis id enim laoreet, luctus bibendum mauris. Maecenas tincidunt non massa eget posuere. Donec ut efficitur tellus. Pellentesque massa mauris, laoreet in eleifend non, gravida at mi. Proin eu sem dignissim, rhoncus metus quis, ultricies odio. Nam at massa non sapien bibendum facilisis. Donec sit amet elementum nunc, sed pellentesque nunc. Maecenas aliquam nulla non elit varius, et varius justo auctor. Etiam neque leo, consequat quis luctus nec, sollicitudin sed ante.
		
		Vivamus tristique lacus nulla, dignissim rhoncus nisl lobortis vel. Donec nec lobortis nulla. Interdum et malesuada fames ac ante ipsum primis in faucibus. Morbi accumsan iaculis tellus ut volutpat. Vivamus a augue in nisi malesuada dignissim nec id lorem. Sed facilisis luctus sapien vitae venenatis. Morbi tempus elementum enim at placerat. Vestibulum pellentesque justo iaculis fermentum pulvinar. Donec venenatis imperdiet lectus, sed volutpat dolor porttitor eu. Sed sollicitudin vel sapien ullamcorper vehicula. Nunc placerat lobortis elit a vehicula. Etiam pulvinar congue enim eu tincidunt. Mauris nec dolor lobortis, ornare nunc a, pulvinar lorem. Cras congue ipsum eu aliquam eleifend. Nullam lobortis, mauris non pellentesque aliquet, nisi quam lacinia libero, et malesuada libero est sed risus.
		
		Pellentesque sit amet blandit velit, vitae pharetra nibh. Curabitur sed posuere libero. Ut lobortis, lectus a dignissim tincidunt, urna leo euismod dolor, eget dapibus ligula ante a mi. Quisque blandit efficitur suscipit. Praesent efficitur eros sit amet nunc elementum ornare. Quisque id nisi eros. Nulla facilisi. Pellentesque et neque orci. Ut arcu lorem, posuere a hendrerit vitae, blandit sed sapien. Donec vehicula, urna dignissim facilisis auctor, dui lectus venenatis elit, at eleifend tortor ligula eget tortor. Aenean blandit non neque eget tristique. Proin rhoncus eget massa quis posuere. Proin vel imperdiet magna. Vestibulum tincidunt condimentum scelerisque.
		
		Phasellus sem mauris, sagittis vel sapien et, commodo placerat ex. Suspendisse eu tellus tristique, bibendum arcu eu, venenatis purus. Ut egestas, leo id scelerisque dictum, mi leo venenatis libero, quis imperdiet quam elit eu quam. Aenean at sem lectus. Etiam id sem nisi. Donec ut ex velit. Nunc at nisi sit amet neque viverra blandit. Aenean nec venenatis nisl. Sed ullamcorper ipsum non finibus iaculis. Donec condimentum molestie nunc vel finibus. Maecenas quis lobortis risus, in luctus magna. Praesent elit leo, luctus ac commodo ac, tincidunt sed nisl. Pellentesque tristique arcu elit, vel cursus erat lacinia non. Etiam a molestie justo. Vivamus ullamcorper quam eu vulputate faucibus.
		
		Aenean pretium sit amet massa ac rutrum. Nunc eget commodo urna. Duis faucibus vitae lacus sed facilisis. Donec tincidunt sed elit a auctor. Proin rutrum leo id pretium molestie. Sed porta interdum dolor, nec lobortis dui convallis sit amet. Vestibulum congue turpis id est mollis, in iaculis nunc commodo. Vivamus nisi odio, fermentum non congue et, consequat non nulla. Sed eu blandit quam, et lacinia odio. Proin convallis viverra libero, vel finibus elit volutpat at. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.
		
		Nunc quis metus nec metus ornare pharetra id vel nulla. Cras varius faucibus elit a ultricies. Nam feugiat augue massa, eu sodales justo porta at. Vestibulum imperdiet, sem in ullamcorper malesuada, ipsum turpis elementum ex, at auctor ipsum orci vel quam. Maecenas sollicitudin ligula arcu, eget semper nibh scelerisque vitae. Suspendisse sed nunc tellus. Aenean dictum, ipsum vitae malesuada facilisis, augue augue vehicula odio, non tristique lorem tortor in mi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec elementum ante. Donec vitae tincidunt orci. Duis a accumsan erat.
		Endtext
		lcText = Left(m.lcText, At([.], m.lcText, m.lnLength))
		If [c] $ This.cOption
		  This.CutCurrentLine()
		  This.cClip = m.lcText
		Else
		  This.ReplaceCurrentLine(m.lcText )
		Endif
		
		
		
	ENDPROC

	PROCEDURE sk_ltry
		*!*  If !Pemstatus(_Screen, [lTry], 5)
		*!*    _Screen.AddProperty([lTry],.F.)
		*!*  Endif
		_screen.ltry = !_screen.ltry 
		Wait Window _screen.ltry at 10,25 timeout 2
	ENDPROC

	PROCEDURE sk_menu
		Local lcAsk, lcCommand, lcDesc, lcFile, lcProg, lcSelect, lcSidekickOptions, lcURL, lcVar, lcWindow
		Local llNomenu, lnLines, lnX
		
		Local Array laSidekickChoices[1]
		
		lcSidekickOptions = This.GetHelpTopics()
		lcSelect = Select()
		
		Select 0
		Create Cursor curSidekick (Nomenu l, Command c(20), Descript c(50),  Window c(2), Ask c(25),  url c(100))
		
		lnLines = Alines(m.laSidekickChoices, m.lcSidekickOptions )
		For lnX = 1 To m.lnLines
		  lcWindow = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 1, [|]))
		  llNomenu = .F.
		  Do Case
		    Case Left(m.lcWindow, 1) = [*]
		      Loop
		    Case m.lcWindow = [a]
		    Case This.nWindowType = 0 And [c] $ m.lcWindow && Command window
		    Case This.nWindowType > 0 And [e] $ m.lcWindow && Modify window/file
		    Case This.nWindowType >= 10 And [f] $ m.lcWindow && Form or class window
		    Case This.nWindowType < 0 And [m] $ m.lcWindow && Menu version
		    Otherwise
		      Loop
		  Endcase
		  lcCommand = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 2, [|]))
		  If m.lcCommand = [<blank>]
		    lcCommand = [ <blank>]
		  Endif
		  lcDesc = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 3, [|]))
		  lcAsk = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 5, [|]))
		  lcURL = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 4, [|]))
		  If Left(m.lcDesc, 1) = [-]
		    lcDesc = Substr(m.lcDesc, 2)
		    llNomenu = .T.
		  Endif
		
		  Do Case
		    Case Left(m.lcURL, 2) = [sk] And [ #] $ m.lcURL
		      lcURL = Strtran(m.lcURL, [#], [.md#])
		      lcURL = Textmerge([<<this.cSidekickHelp>>blob/master/documents/<<m.lcURL>>])
		    Case Left(m.lcURL, 2) = [sk]
		      lcURL = Forceext(m.lcURL, [md])
		      lcURL = Textmerge([<<this.cSidekickHelp>>blob/master/documents/<<m.lcURL>>])
		    Case m.lcURL = [<default>]
		      lcURL = Textmerge([<<this.cSidekickHelp>>])
		    Case m.lcURL = [<ver>]
		      lcDesc = [Version: ] + This.cVersion
		      lcURL = Textmerge([<<this.cSidekickHelp>>/blob/master/Change%20Log.md])
		  Endcase
		
		
		  Insert Into curSidekick (Command, Descript, Ask, url, Nomenu) Values (m.lcCommand, m.lcDesc, m.lcAsk, m.lcURL, m.llNomenu  )
		Endfor
		Select Command, Descript, url, Ask, Nomenu From curSidekick Into Cursor curSidekick Readwrite
		If ![x] $ This.cOption
		  This.addSKExtensions()
		Endif
		This.IndexFields([Command])
		If [y] $ This.cOption
		  Browse Normal
		  List Off Command, Descript, Ask To Print
		Endif
		lcProg = This.GetDataFromGrid(Textmerge([<<this.cProgram>> "commands", Ctrl+Enter opens url]), [command], 2)
		lcAsk = Alltrim(Ask)
		llNomenu = Nomenu
		
		Use
		Select (m.lcSelect)
		If Getwordnum(m.lcProg, 1) # [0]
		  lcProg = Getwordnum( m.lcProg, 1)
		Endif
		If !Empty(m.lcProg)
		  Do Case
		    Case m.llNomenu
		    Case Lower(m.lcAsk) == [na]
		      lcProg = []
		    Case m.lcProg = [<blank>]
		      lcProg = [menu] && [ed]
		    Case m.lcProg = [2-9999]
		      lcProg = Alltrim(Inputbox(m.lcAsk), [Empty for list])
		      lcProg = Evl(m.lcProg, [*])
		    Case m.lcProg = [0 <file>]
		      lcFile = Alltrim(Inputbox(m.lcAsk, [Specify .sk file name!]))
		      If Empty(m.lcFile)
		        This.GiveMessage([No Sidekick file is specified!], 0 + 48)
		        Return
		      Endif
		      lcFile = Forceext(m.lcFile, [sk])
		      lcProg = [0 ] + m.lcFile
		    Case m.lcProg = [?=]
		      lcVar = Alltrim(Inputbox(m.lcAsk, [Value is required!]))
		      If Empty(m.lcVar)
		        This.GiveMessage([No variable given], 0 + 48)
		        Return
		      Endif
		      lcProg = m.lcProg + m.lcVar
		    Case Lower(m.lcAsk) = [filename or url:]
		      lcProg = m.lcProg + [ ] + Inputbox(m.lcAsk, [Enter a value or press Enter for list!])
		    Case !Empty(m.lcAsk)
		      lcProg = m.lcProg + [ ] + Inputbox(m.lcAsk, [Value is required!])
		    Case Inlist(Lower(m.lcProg), [sk], [sked], [eval])
		      lcProg = m.lcProg + [ ] + Inputbox([Name of file:], [Empty gives picklist])
		  Endcase
		  If This.lSKComment
		    lcProg = [*] + m.lcProg
		  Endif
		  If !Empty(m.lcProg) And !m.llNomenu
		    Execscript(_Screen.cThorDispatcher, [thor_tool_sidekick], m.lcProg )
		  Else
		    This.GiveMessage([This command is not available via Help menu!])
		  Endif
		Endif
		If This.lSKComment
		  This.CutCurrentLine()
		Endif
		
		
	ENDPROC

	PROCEDURE sk_mf_remove
		* Modify form
		Local lcCode, lcCursor, lcDBF, lcFile, lcMessage, lcMethod, lcProc, lcWord, lnProcs, lnWords, lnX
		
		Local Array laDummy[1]
		Local Array laProc[1]
		
		lcCursor = This.cCursor
		?'this.cparameter', this.cparameter
		If [.] $ This.cParameter Or !Pemstatus(_Screen, [sklastform], 5)
		  This.cParameter = Chrtran(This.cParameter, [.], [])
		  This.GetFilesInPath([scx],, .T.)
		*!*    Select (m.lcCursor)
		  Select Cast(Justfname(Filename) As c(50)) As Form, Filename, FileSize As Size, Filedate As Date;
		    From (Alias()) Into Cursor ( Alias()) Readwrite
		  Select Max(Len(Trim(Form))), Max(Len(Trim(Filename))) From (Alias()) Into Array laDummy
		  Select Cast(Form As c(m.laDummy(1))) As Form, Cast(Filename As c(m.laDummy(2))) As Filename, Size, Date;
		    From (Alias()) Into Cursor ( Alias()) Readwrite
		  lnWords = Getwordcount(This.cParameter)
		  For lnX = 1 To m.lnWords
		    lcWord = Getwordnum(This.cParameter, m.lnX)
		    Select * From (Alias()) Where m.lcWord $ Lower(Filename) Into Cursor (Alias()) Readwrite
		  Endfor
		  lcMessage = [Select a form to modify:]
		  If Reccount() > 1
		    this.IndexFields()
		    Set Order To date desc 
		    lcDBF = This.GetDataFromGrid(m.lcMessage, [Filename])
		  Else
		    lcDBF = Alltrim(Filename)
		  Endif
		  _Screen.AddProperty([sklastform], m.lcDBF)
		Endif
		If Pemstatus(_Screen, [sklastform], 5) And !Empty(_Screen.sklastform)
		  lcDBF = _Screen.sklastform
		  Select Methods From (m.lcDBF) Into Array laDummy Where BaseClass = [form] and !Empty(methods)
		  If _Tally > 0
		    lcFile = Forceext([sk] + Sys(2015), [prg])
		    Strtofile(m.laDummy(1, 1), m.lcFile)
		    lnProcs = Aprocinfo(laProc, m.lcFile)
		    If m.lnProcs > 0
		      Create Cursor (m.lcCursor + [1]) (Function c(25), Code m)
		      For lnX = 1 To m.lnProcs
		        If m.laProc(m.lnX, 3) = [Procedure] && And (m.lcMethod $ Lower(m.laProc(m.lnX, 1)) Or Empty(m.lcMethod)) && And ![.] $ m.laProc(m.lnX, 1)
		          lcProc = m.laProc(m.lnX, 1)
		          lcCode = This.GetMethodFromPrg(m.lcProc, m.lcFile )
		          If [.] $ m.lcProc
		            lcProc = Justext(m.lcProc)
		          Endif
		          Insert Into (m.lcCursor + [1]) (Function, Code) Values (m.lcProc, m.lcCode)
		        Endif
		      Endfor
		    EndIf
		*!*      Set Step On 
		    If File(m.lcFile)
		      Erase (m.lcFile)
		    EndIf
		    Select * from (m.lcCursor + [1]) into cursor (this.cCursor) readwrite
		    Select (this.cCursor)
		    this.IndexFields('function')
		    lcMessage = Proper(Juststem(m.lcDBF)) + [ - Select a method:]
		    lcMethod = This.GetDataFromGrid(m.lcMessage, [Function])
		    Wait Window m.lcMethod At 10, 25
		    _Screen.AddProperty([sklastmethod], m.lcMethod )
		  Else
		    Wait Window [No method has code in it...] At 10, 25
		  Endif
		Endif
		
		
		
		
		
	ENDPROC

	PROCEDURE sk_no
		#Define Stripextension 'BIZ,$$$'
		#Define ccCursor 'CurObjects'
		Local lcClass, lcClassFilter, lcClassInfo, lcClassLib, lcFilter, lcNewText, lcParameter
		Local lcPasteText, lcPrefix, lcSource, lcText, lcVariable, llClipboard, llMethod, llPartOfClass
		Local llPartOfClasslib, llRefresh, lnClasses, lnHits, lnI, lnSelect, lnX, ltTimestamp
		lnSelect = Select()
		lcFilter = []
		lcParameter = This.cParameter
		lcClassFilter = Getwordnum(m.lcParameter, 2, [= ])
		lcParameter = Getwordnum(m.lcParameter, 1, [= ] )
		If Empty(m.lcClassFilter)
		  lcClassFilter = Evl(m.lcParameter, [lo])
		  lcParameter = []
		Endif
		llMethod = [.] $ m.lcParameter
		
		If m.llMethod
		  lcPrefix = Getwordnum(m.lcParameter, 1, [.])
		  lcVariable = Getwordnum(This.cParameterOriginal, 2, [.])
		Else
		  lcPrefix = []
		  If Empty(m.lcParameter)
		    lcVariable = m.lcClassFilter && []
		  Else
		    lcVariable = This.cParameterOriginal
		  Endif
		Endif
		
		If ![o] $ This.cOption
		  This.GetFilesInPath([vcx], [curdummy])
		  If Reccount([curdummy]) > 0
		    Create Cursor (ccCursor) (Classname c(50), LibName c(240), Timestamp T, Classinfo c(254) )
		    Select curDummy
		    Scan
		      lcSource = Trim(curDummy.Filename)
		      Use In Select([tempsource])
		      Use (m.lcSource) Again In 0 Alias tempsource
		      Select tempsource
		      Scan For reserved1 == [Class] And !Deleted()
		        lcClass = tempsource.ObjName
		        lcClassLib = m.lcSource
		        ltTimestamp = This.DecodeTimeStamp(tempsource.Timestamp)
		        If  ! [r] $ This.cOption
		          lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(Sys(2014, m.lcClassLib, Curdir()))
		        Else
		          lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(m.lcClassLib)
		        Endif
		        Insert Into (ccCursor) (Classname, LibName, Classinfo, Timestamp) Values (;
		            This.ShowCase( tempsource.ObjName), This.ShowCase(m.lcSource), m.lcClassInfo, m.ltTimestamp )
		      Endscan
		      Use In tempsource
		    Endscan
		    Use In curDummy
		  Endif
		  Select (ccCursor)
		  lnClasses = Reccount()
		
		  Do Case
		    Case (Left(m.lcClassFilter, 1) == [*] Or Right(m.lcClassFilter, 1) == [*]) And Len(m.lcClassFilter) > 1
		      If Getwordcount(This.cParameter) = 1
		        lcFilter = Chrtran(m.lcClassFilter, [*], [])
		        lcVariable = [lo] + Proper(m.lcFilter)
		      Endif
		      Select * From (ccCursor) Where m.lcFilter $ Lower(Classname) Into Cursor (ccCursor) Readwrite Order By 1, 2
		    Case Getwordcount(This.cParameter ) = 2
		      lcVariable = Getwordnum(This.cParameterOriginal, 1)
		      lcFilter = Getwordnum(This.cParameter, 2)
		      Select * From (ccCursor) Where m.lcFilter $ Lower(Classname) Into Cursor (ccCursor) Readwrite Order By 1, 2
		    Case Empty(This.cParameter );
		        Or This.cParameter == [*];
		        Or m.lcClassFilter == [*];
		        Or Empty(m.lcParameter)
		      Select * From (ccCursor) Into Cursor (ccCursor) Readwrite Order By 1, 2
		    Otherwise
		      Select * From (ccCursor) Where m.lcClassFilter = Lower(Classname)  Into Cursor (ccCursor) Readwrite Order By 1, 2
		  Endcase
		  lnHits = Reccount()
		Else
		  Private llNoProject
		  llPartOfClass = [*] $ m.lcClassFilter
		  llRefresh = [!] $ m.lcClassFilter
		  llPartOfClasslib = [+] $ m.lcClassFilter
		  llClipboard = [-] $ m.lcClassFilter
		  lcClassFilter = Chrtran(m.lcClassFilter, [*!+-], [])
		
		  lcParameter = Evl(m.lcParameter, [*]) && TB
		
		  Do Case
		    Case m.llMethod And Len(m.lcClassFilter) = 0
		      This.GiveMessage([Illegal input!], 0, [], 5000)
		      Return
		  Endcase
		  llNoProject = Type([_vfp.activeproject.name]) = [U] Or Empty(_vfp.ActiveProject.Name)
		  lcNewText = []
		  Do Case
		    Case m.llNoProject
		      This.readClassLibs()
		    Case m.llRefresh Or !Pemstatus(_vfp, [noClasses], 5) Or Empty(_vfp.noClasses);
		        Or !Pemstatus(_vfp, [noLenClasses], 5) Or _vfp.noLenClasses = 1
		      lnClasses = This.readClassLibs()
		    Otherwise
		      lnClasses = _vfp.noLenClasses
		  Endcase
		  lcClassFilter = Lower(m.lcClassFilter)
		  Do Case
		    Case Type([_vfp.activeproject.name]) = [U] And !Pemstatus(_vfp, [noProject], 5)
		      AddProperty(_vfp, [noProject], [])
		    Case !Pemstatus(_vfp, [noProject], 5)
		      AddProperty(_vfp, [noProject], _vfp.ActiveProject.Name)
		  Endcase
		  Do Case
		    Case m.llNoProject
		      _vfp.Noproject = []
		      lnClasses = This.readClassLibs()
		    Case m.llRefresh
		      If Type([_vfp.activeproject.name]) = [C]
		        _vfp.Noproject = _vfp.ActiveProject.Name
		      Endif
		      This.readClassLibs()
		    Case Type([_vfp.activeproject.name]) # [U] And !_vfp.Noproject == _vfp.ActiveProject.Name
		      _vfp.Noproject = _vfp.ActiveProject.Name
		      This.readClassLibs()
		  Endcase
		  If m.lnClasses > 1
		    Select 0
		    Create Cursor (ccCursor) (Classname c(50), LibName c(240), Classinfo c(254) )
		    this.IndexFields()
		    lnHits = 0
		    For lnI = 1 To _vfp.noLenClasses
		      lcClassLib  = _vfp.noClasses(m.lnI, 2)
		      lcClass     = _vfp.noClasses(m.lnI, 1)
		      Do Case
		        Case m.llPartOfClass And Len(m.lcClassFilter) > 0 And m.lcClassFilter $ Lower(m.lcClass)
		        Case m.llPartOfClasslib And Len(m.lcClassFilter) > 0 And;
		            (m.lcClassFilter $ Lower(m.lcClass) Or m.lcClassFilter $ Lower(m.lcClassLib))
		        Case Len(m.lcClassFilter) > 0 And m.lcClass = Lower(m.lcClassFilter)
		        Case Empty(This.cParameter) && or m.lcParameter == [*] && TBCheck
		        Case This.cParameter == [*]
		        Otherwise
		          Loop
		      Endcase
		      lnHits = m.lnHits + 1
		      If ! [r] $ This.cOption
		        lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(Sys(2014, m.lcClassLib, Curdir()))
		      Else
		        lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(m.lcClassLib)
		      Endif
		      Insert Into (ccCursor) (Classname, LibName, Classinfo) Values (This.ShowCase(m.lcClass), This.ShowCase(Sys(2014, m.lcClassLib)), m.lcClassInfo )
		    Endfor
		    Go Top
		  Endif
		Endif
		If Reccount() = 0
		  Wait Window [No match found] At 10, 25 Timeout 2
		  Return
		Endif
		If [n] $ This.cOption && Newest first
		  Select * From (ccCursor) Into Cursor (ccCursor) Order By Classname, Timestamp Desc Readwrite
		Endif
		
		lcClassInfo =  This.GetDataFromGrid([Pick a class], [Classinfo], 1)
		If Empty(m.lcClassInfo)
		  Return
		Endif
		If m.lnHits > 0
		  lcClassInfo = Alltrim(Evaluate(ccCursor + [.ClassInfo]))
		  lcClass  = Getwordnum (m.lcClassInfo, 1, [|])
		  lcClassLib     = Getwordnum (m.lcClassInfo, 2, [|])
		  lcPasteText = []
		  If Empty(m.lcVariable) Or Right(m.lcVariable, 1) = [*]
		    lcVariable = [lo] + Proper(Juststem(m.lcClass))
		    For lnX = 1 To Getwordcount(Stripextension, [,])
		      lcText = Getwordnum(Stripextension, m.lnX, [,])
		      If Lower(Right(m.lcVariable, Len(m.lcText))) == Lower(m.lcText)
		        lcVariable = Left(m.lcVariable, Len(m.lcVariable) - Len(m.lcText))
		        Exit
		      Endif
		    Endfor
		  Endif
		  If m.llMethod
		    If ! [r] $ This.cOption
		      lcPasteText = m.lcPrefix + [.NewObject('] + m.lcVariable + [','] + Juststem(m.lcClass) + [', '] + Alltrim(m.lcClassLib) + [')]
		    Else
		      lcPasteText = m.lcPrefix + [.NewObject('] + m.lcVariable + [','] + Juststem(m.lcClass) + [', '] + Justfname (m.lcClassLib) + [')]
		    Endif
		  Else
		    If ! [r] $ This.cOption
		      If This.nWindowType # 0
		        lcPasteText = [Local ] + m.lcVariable + [ as ] + m.lcClass + [ of ] + Alltrim(m.lcClassLib) + crlf
		      Endif
		      lcPasteText = m.lcPasteText + m.lcVariable + [ = NewObject('] + Juststem(m.lcClass) + [', '] + Alltrim(m.lcClassLib) + [')]
		    Else
		      If This.nWindowType = 0
		        lcPasteText = m.lcPasteText + m.lcVariable + [ = NewObject('] + Juststem(m.lcClass) + [', '] + m.lcClassLib + [')]
		      Else
		        lcPasteText = [Local ] + m.lcVariable + [ as ] + m.lcClass + [ of ] + Justfname (m.lcClassLib) + crlf
		        lcPasteText = m.lcPasteText + m.lcVariable + [ = NewObject('] + Juststem(m.lcClass) + [', '] + Justfname (m.lcClassLib) + [')]
		      Endif
		    Endif
		  Endif
		  If m.llClipboard
		    _Cliptext = Iif(Empty(m.lcPrefix), m.lcVariable, m.lcPrefix + [.] + m.lcVariable)
		  Endif
		  If This.nWindowType # 0
		    lcPasteText = m.lcPasteText + crlf
		  Endif
		  This.oEditorWin.Paste(m.lcPasteText)
		Else
		  This.GiveMessage([No match found!], 0 + 48, [], 5000)
		Endif
		Select (m.lnSelect)
		Return
		
		
	ENDPROC

	PROCEDURE sk_op
		Local llSuccess
		
		llSuccess = .T.
		Do Case
		  Case InList(JustExt(this.cParameter),'exe','bat','com')
		    this.ShellX(this.cParameter)
		  Case This.nWindowType > 0 And This.cParameter == [+]
		    This.HandleMRUTable([Add])
		  Case This.nWindowType > 0 And This.cParameter == [-]
		    This.HandleMRUTable([Delete])
		  Case [m] $ This.cOption
		    This.HandleMRUTable([Browse])
		  Case Empty(This.cParameter) Or Inlist(This.cParameter, [?], [*]) Or !Empty(Justext(This.cParameter)) && Or [w] $ This.cOption
		    This.cParameter = Chrtran(This.cParameter, [?*], [])
		    This.HandleMRUTable([List])
		  Case Empty(Justext(This.cParameter)) And File(Forceext(This.cParameter, [prg]))
		    Modify Command (Forceext(This.cParameter, [prg]))
		  Case !Empty(Justext(This.cParameter))
		    This.ListFiles(This.cParameter)
		  Case !Empty(This.cParameter) And This.cParameter # [0] And Val(This.cParameter) = 0
		    Try
		      This.RunEd(This.cParameter)
		      llSuccess = .T.
		    Catch
		      If This.cParameter # [*]
		        This.AddOption([a])
		      Endif
		      This.ListFiles(This.cParameter)
		    Endtry
		  Case This.cParameter = Transform(Val(This.cParameter))
		    If This.cParameter = [0]
		      Modify Command (This.cSidekickFile ) Nowait
		    Else
		      This.GetLinesToProcess(Val(This.cParameter))
		    Endif
		  Otherwise
		    This.RunEd(This.cParameter)
		Endcase
	ENDPROC

	PROCEDURE sk_ot
		Local lcAlias, lcCursor, lnFiles, lnWorkArea, lnX
		
		Local Array laDummy[1]
		
		lnWorkArea = 0
		lcCursor = This.cCursor && 'curOpenTables'
		Create Cursor (m.lcCursor) (Workarea i, Alias c(20), Table c(50), RecordS i, Order c(50))
		
		lnFiles = Aused(laDummy)
		For lnX = 1 To m.lnFiles
		  Insert Into (m.lcCursor) (Workarea, Alias) Values (m.laDummy(m.lnX, 2), m.laDummy(m.lnX, 1))
		Endfor
		Scan
		  Replace Table With This.ShowCase( This.FixPath( Dbf(Workarea))),;
		    RecordS With Reccount(Workarea),;
		    Order With Order(Workarea)
		Endscan
		Select * From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where Alias # Upper(m.lcCursor)
		This.IndexFields([workarea])
		This.lNoMessage = .F.
		If Reccount() > 1
		  This.lNoMessage = .F.
		  lnWorkArea = Val(This.GetDataFromGrid([List of open tables], [workarea]))
		Else
		  This.GiveMessage([No tables are open!])
		Endif
		If m.lnWorkArea > 0
		  This.GiveMessage(Textmerge([Work area <<Transform(m.lnWorkArea)>>, alias "<<this.ShowCase(Alltrim(Alias))>>"  is selected!]))
		  This.nSelect = m.lnWorkArea
		Else
		  This.GiveMessage(Textmerge( [No change, work area <<Int(this.nSelect)>>, alias "<<this.ShowCase( this.cAlias) >>" is selected!]))
		Endif
		This.lsuccess = .T.
	ENDPROC

	PROCEDURE sk_pa
		Local lcFolder, lcPath, lcRoot, lnElements, lnFiles, lnI, lnSize, lnX
		
		Local Array laDummy[1]
		Local Array laFiles[1]
		
		lcPath = Set([Path])
		Create Cursor (This.cCursor) (Type c(10), Folder c(200), Files i, Size i)
		lcRoot = Addbs(Fullpath(Set([Default]))) + [*.*]
		
		lnFiles = Adir(laFiles, m.lcRoot )
		lnSize = 0
		If m.lnFiles > 0
		  For lnI = 1 To m.lnFiles
		    lnSize = m.lnSize + m.laFiles(m.lnI, 2)
		  Endfor
		Endif
		Insert Into (This.cCursor) (Type, Folder, Files, Size) Values ([Default], Justpath(m.lcRoot), m.lnFiles, m.lnSize  )
		
		lnElements = Alines(laDummy, m.lcPath, 1 + 4, [;], [,])
		If m.lnElements > 0
		  For lnX = 1 To m.lnElements
		    lcFolder = m.laDummy(m.lnX)
		    lnFiles = Adir(laFiles, Addbs(m.lcFolder) + [*.*])
		    lnSize = 0
		    For lnI = 1 To m.lnFiles
		      lnSize = m.lnSize + m.laFiles(m.lnI, 2)
		    Endfor
		
		    If ! [:] $ m.lcFolder
		      lcFolder = [..\] + m.lcFolder
		    Endif
		    Insert Into (This.cCursor) (Type, Folder, Files, Size) Values ([], m.lcFolder, m.lnFiles, m.lnSize  )
		
		  Endfor
		Endif
		Select * From (This.cCursor) Into Cursor (This.cCursor) Order By Type, Folder
		This.GetDataFromGrid([Current path], , , , [N])
	ENDPROC

	PROCEDURE sk_rt
		* Random Text
		Local lcText, lnParagraphs, lnSentences
		
		lnSentences = Val(Getwordnum(This.cParameter, 2, [, ]))
		lnParagraphs = Val(Getwordnum(This.cParameter, 1, [, ]))
		lnParagraphs = Evl(m.lnParagraphs, 1)
		lnSentences = Evl(m.lnSentences, 1)
		lcText = This.GetRandomText(m.lnParagraphs, m.lnSentences)
		If [c] $ This.cOption
		  This.CutCurrentLine()
		  This.cClip = m.lcText
		Else
		  This.ReplaceCurrentLine(m.lcText )
		Endif
	ENDPROC

	PROCEDURE sk_sb
		Local lcTable
		
		lcTable = Alias()
		If !Empty(m.lcTable)
		  Select (m.lcTable)
		  This.lCloseTables = .F.
		  Execscript(_Screen.cThorDispatcher, [Thor_Proc_SuperBrowse])
		Else
		  This.GiveMessage([No table is open in the current work area.])
		Endif
	ENDPROC

	PROCEDURE sk_sk
		Local lcCursor, lcDescript, lcFile, lcFilename, lcPar, lcPath, lcProg, lnSelect, lnTools
		
		If Left(This.cParcedText, 1) = [*]
		  Return .F.
		Endif
		lcFilename = This.cParameter
		If Left(This.cCommand, 1) = [!] And Len(This.cCommand) > 1
		  lcFilename = Substr(This.cCommand, 2)
		Endif
		
		
		If Empty(m.lcFilename)
		  lnSelect = Select()
		  lcCursor = [curCustom]
		  lnTools = This.GetFilesInPath([prg], m.lcCursor )
		  Select Cast(Lower(Substr(Juststem(Filename), 4)) As c(30)) As Program, FileSize, Filedate, Cast([] As c(100)) As Descript, Filename;
		    From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where Lower(Left(Juststem(Filename), 3)) = [sk_]
		  If _Tally = 0
		    This.GiveMessage([No tool matching sk_ *.prg found], 0 + 48, [No custom tool defined])
		  Else
		    Scan
		      lcFile = Alltrim(Filename)
		      lcDescript = This.GetDescript(m.lcFile )
		      If !Empty( m.lcDescript )
		        Replace Descript With m.lcDescript
		      Endif
		    Endscan
		    This.IndexFields([program])
		    lcProg = This.GetDataFromGrid(Textmerge([My "<<this.cProgram>>" extensions (R/O) to run:]), [Filename], 1)
		    Use
		    Select (m.lnSelect)
		    If !Empty(m.lcProg)
		      _Screen.AddProperty([oSidekick], This)
		      Do (m.lcProg)
		      Removeproperty(_Screen, [osidekick])
		    Endif
		    If !This.lSKComment
		      This.CutCurrentLine()
		    Endif
		  Endif
		Else
		  lcFilename = Getwordnum(m.lcFilename, 1)
		  lcPar = Getwordnum(m.lcFilename, 2)
		  lcProg = Forceext([sk_] + m.lcFilename, [prg])
		  If File(m.lcProg )
		    Try
		      If !Empty(m.lcPar)
		        Do (m.lcProg ) With m.lcPar
		      Else
		        Do (m.lcProg )
		      Endif
		      This.lsuccess = .T.
		    Catch
		    Endtry
		  Else
		    If This.GiveMessage([File ] + m.lcProg + [ is not found], 4 + 48, [Create it?]) = 6
		      Do Case
		        Case Directory([prog])
		          lcPath = [prog]
		        Case Directory([prg])
		          lcPath = [prg]
		        Otherwise
		          lcPath = []
		      Endcase
		      This.lSKComment = .F.
		      Modify Command (Forcepath(m.lcProg, m.lcPath)) Nowait
		    Endif
		  Endif
		Endif
		If !This.lSKComment
		  This.CutCurrentLine()
		Endif
		
		
	ENDPROC

	PROCEDURE sk_sked
		Local lcCursor, lcDescript, lcFile, lcMessage, lcProg, lcProgFile, lcText, lnHandle, lnSelect
		Local lnTools
		
		If [z] $ This.cOption
		  Set Step On
		Endif
		lcProg = This.cParameter
		*!*  If This.cCommand = [!!] And Len(This.cCommand ) > 2
		*!*    lcProg = Substr(This.cCommand, 3)
		*!*  Endif
		If !Lower(m.lcProg) = This.cSKFile
		  lcProg = This.cSKFile + m.lcProg
		Endif
		lcProgFile = Forceext(m.lcProg, [prg])
		If !Empty(m.lcProg) And !m.lcProg == This.cSKFile
		  If File(m.lcProgFile)
		    Modify Command (m.lcProgFile) Nowait
		  Else
		    If Directory('prog')
		      m.lcProgFile = ForcePath(m.lcProgFile,'prog')
		    Endif
		    If This.GiveMessage([File ] + m.lcProgFile + [ is not found!], 4 + 64, [Create it?], 10000) # 7
		      lcText = This.cDescriptionMask1 + [  ] + This.cDescriptionMask2
		      Strtofile(m.lcText, m.lcProgFile)
		      Modify Command (m.lcProgFile) Nowait
		      lnHandle = This.oEditorWin.Findlastwindow()
		      This.oEditorWin.SelectWindow(m.lnHandle)
		      This.oEditorWin.SetInsertionPoint(15)
		    Endif
		  Endif
		Else
		  lnSelect = Select()
		  lcCursor = [curCustom]
		  lnTools = This.GetFilesInPath([prg], m.lcCursor )
		  Select Cast(Lower(Substr(Juststem(Filename), 4)) As c(30)) As Program, FileSize, Filedate, Cast([] As c(100)) As Descript, Filename;
		    From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where Lower(Left(Juststem(Filename), 3)) = This.cSKFile
		  If _Tally = 0
		    lcMessage = [No tool matching ] + This.cSKFile + [ found]
		    This.GiveMessage(m.lcMessage, 0 + 48, [No custom tool defined])
		  Else
		    Scan
		      lcFile = Alltrim(Filename)
		      lcDescript = This.GetDescript(m.lcFile )
		      If !Empty( m.lcDescript )
		        Replace Descript With m.lcDescript
		      Endif
		    Endscan
		    this.IndexFields('program')
		    lcProg = This.GetDataFromGrid(Textmerge([My "<<this.cProgram>>" extensions to edit:]), [Filename], 1)
		    Use
		    Select (m.lnSelect)
		    If !Empty(m.lcProg)
		      Modify Command (m.lcProg) Nowait
		    Endif
		    If !This.lSKComment
		      This.CutCurrentLine()
		    Endif
		  Endif
		Endif
		This.lsuccess = .T.
	ENDPROC

	PROCEDURE sk_sx
		this.ShellX(GetWordNum(this.cParameter,1),,StrExtract(this.cParameter,' '))
	ENDPROC

	PROCEDURE sk_ta
		Local lcExt, lcFile, lcMessage, lcText, lnHandle, lnLen, lnMax, lnX
		
		lcMessage = [Select file to open:]
		lnLen = Len(Trim(This.cTestArea)) + 1
		Do Case
		  Case Empty(This.cParameter)
		    lcExt = []
		  Case Val(This.cParameter) > 0
		    lcExt = Alltrim(Transform( This.cParameter))
		  Case Inlist(This.cParameter, [?], [,], [.])
		    This.AddOption([a])
		    This.ListFiles([ta])
		    If Reccount() > 0
		      lcFile = This.GetDataFromGrid(m.lcMessage, [fullname], 0)
		    Else 
		      m.lcFile = ''
		    Endif
		    If Empty(m.lcFile)
		      Return
		    Endif
		  Case Inlist(This.cParameter, [+])
		    This.AddOption([a])
		    This.ListFiles([ta])
		    Calculate Max(Val(Substr(Fullname, m.lnLen ))) To m.lnMax
		    lcExt = Transform(m.lnMax + 1)
		  Case Inlist(This.cParameter, [-])
		    This.AddOption([a])
		    This.ListFiles([ta])
		    lnX = 1
		    Do While .T.
		      Locate For Val(Substr(Fullname, m.lnLen )) = m.lnX
		      If Found()
		        lnX = m.lnX + 1
		        Loop
		      Endif
		      Exit
		    Enddo
		    lcExt = Transform(m.lnX)
		  Otherwise
		    lcExt = [_] + Getwordnum(This.cParameter, 1)
		Endcase
		If Empty(m.lcFile)
		  lcFile = Forceext(This.cTestArea + m.lcExt, [.prg])
		Endif
		If !File(m.lcFile)
		  If This.GiveMessage([File ] + m.lcFile + [ does not exist,] + Chr(13) + Chr(10) + [create it?], 4 + 32, [New file?]) = 6
		    lcText = This.cDescriptionMask1 + [  ] + This.cDescriptionMask2
		    Strtofile(m.lcText, m.lcFile)
		    Modify Command (m.lcFile) Nowait
		    lnHandle = This.oEditorWin.Findlastwindow()
		    This.oEditorWin.SelectWindow(m.lnHandle)
		    This.oEditorWin.SetInsertionPoint(15)
		  Endif
		Else
		  Modify Command (m.lcFile) Nowait
		Endif
		
		
		
	ENDPROC

	PROCEDURE sk_tools
		#Define ccTool         'Browse all Thor Tools'
		Local lcDesc, lcDestAlias, lcHotkey, lcProg, lcWord, llExcludeNotUsed, lnX
		
		Local Array laDummy[1]
		
		llExcludeNotUsed = Execscript(_Screen.cThorDispatcher, [Get Option=], ccTool, ccTool)
		lcDestAlias = [curHotKeys]
		Select 0
		Wait Window [Wait while Sidekick processes files!] At 10, 25 Nowait Noclear
		Execscript(_Screen.cThorDispatcher, [Thor_Proc_GetHotKeyDefs], m.lcDestAlias, m.llExcludeNotUsed )
		Select Distinct Cast(Ltrim(Descript) As c(100)) As Descript, Chrtran(HotKey, [-], [+]) As HotKey, Cast([] As c(10)) As sortkey, PRGName, StatusBar From (m.lcDestAlias);
		  Into Cursor (m.lcDestAlias ) Where Left(Descript, 1) # [ ]; && And Substr(Descript, 3, 1) # [-]
		  Readwrite
		Update (m.lcDestAlias) Set Descript = Substr(Descript, 4) Where Like([? - *], Descript)
		Scan
		  lcHotkey = HotKey
		  Select Recno() From (_Screen.Cthorfolder + [\source\hotkeys])  Hotkeys Where Hotkeys.Key = Substr(m.lcHotkey, 1 + Rat([+], m.lcHotkey ), 10) Into Array laDummy
		  If _Tally > 0
		    Replace sortkey With Padl(m.laDummy, 2, [ ]) + m.lcHotkey
		  Endif
		Endscan
		Select HotKey, Descript, PRGName From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Readwrite
		lcDesc = []
		lcHotkey = []
		Scan
		  If Lower(Descript) == m.lcDesc And Lower(HotKey) = m.lcHotkey
		    Delete
		  Endif
		  lcDesc = Lower(Descript)
		  lcHotkey = Lower(HotKey)
		Endscan
		If !Empty(This.cParameter)
		  For lnX = 1 To Getwordcount(This.cParameter)
		    lcWord = Getwordnum(This.cParameter, m.lnX)
		    Select * From (m.lcDestAlias ) Into Cursor (m.lcDestAlias ) Readwrite Where m.lcWord  $ Lower( Descript + [|] + PRGName)
		  Endfor
		Endif
		Select * From (m.lcDestAlias ) Into Cursor (m.lcDestAlias ) Readwrite Order By Descript Where !Deleted()
		This.IndexFields()
		Wait Clear
		lcProg = This.GetDataFromGrid([Thor tools], [prgname], 1)
		Use
		If !Empty(m.lcProg)
		  Execscript(_Screen.cThorDispatcher, m.lcProg)
		Endif
		
		
	ENDPROC

	PROCEDURE sk_unzip
		Local lcNew, lcTargetFolder, lcZipFile, llOK
		
		lcZipFile = Getwordnum(This.cParameter, 1)
		lcTargetFolder = Getwordnum(This.cParameter, 2)
		
		If Vartype(This.oZip) # [O]
		  This.oZipInit()
		Endif
		If m.lcZipFile = [?] Or Empty(m.lcZipFile)
		  lcZipFile = This.ListFiles([.zip])
		Endif
		
		If Empty(m.lcZipFile)
		  This.GiveMessage([You must specify a zip file!])
		  Return .F.
		Endif
		If Empty(Justext(m.lcZipFile))
		  lcZipFile = Forceext(m.lcZipFile, [.zip])
		Endif
		lcTargetFolder = Evl(m.lcTargetFolder, This.cUnzipFolder)
		llOK = .T.
		lcNew = [already existing]
		If !Directory(m.lcTargetFolder)
		  Try
		    Md (m.lcTargetFolder)
		    lcNew = [new]
		  Catch
		    llOK = .F.
		    This.GiveMessage([Can't create folder ] + m.lcTargetFolder)
		  Endtry
		Endif
		If !File(m.lcZipFile)
		  This.GiveMessage([No file called ] + m.lcZipFile)
		  llOK = .F.
		Endif
		If !m.llOK
		  Return .T.
		Else
		  If !This.oZip.Unzip(m.lcZipFile, m.lcTargetFolder)
		    This.GiveMessage(This.oZip.cErrorMessage)
		  Else
		    This.GiveMessage(m.lcZipFile + [ is unzipped into ] + m.lcNew + [ folder ] + m.lcTargetFolder)
		  Endif
		Endif
		
	ENDPROC

	PROCEDURE sk_us
		Local lcDBF, lcFullName, lcMessage, lcTable, lcText, llListfiles, lnPos
		
		llListfiles = .T.
		Do Case
		  Case File(This.cParameter)
		    llListfiles = .F.
		  Case [.dbf] $ This.cParameter
		    This.cParameter = Strtran(This.cParameter, [.dbf], [])
		  Case [.d] $ This.cParameter
		    This.cParameter = Strtran(This.cParameter, [.d], [])
		  Case [.vcx] $ This.cParameter
		    This.AddOption([v])
		    This.cParameter = Strtran(This.cParameter, [.vcx], [])
		  Case [.vc] $ This.cParameter
		    This.AddOption([v])
		    This.cParameter = Strtran(This.cParameter, [.vc], [])
		  Case [.v] $ This.cParameter
		    This.AddOption([v])
		    This.cParameter = Strtran(This.cParameter, [.v], [])
		  Case [.scx] $ This.cParameter
		    This.AddOption([s])
		    This.cParameter = Strtran(This.cParameter, [.scx], [])
		  Case [.sc] $ This.cParameter
		    This.AddOption([s])
		    This.cParameter = Strtran(This.cParameter, [.sc], [])
		  Case [.s] $ This.cParameter
		    This.AddOption([s])
		    This.cParameter = Strtran(This.cParameter, [.s], [])
		Endcase
		If This.nWindowType # 0 And ([s] $ This.cOption Or [v] $ This.cOption)
		  Return
		Endif
		Do Case
		  Case [u] $ This.cOption Or This.cParameter == [-]
		    This.AddOption([-b])
		    This.AddOption([u])
		    lcMessage = [List if tables in use:]
		  Otherwise
		    lcMessage = [Pick a table to use:]
		Endcase
		If [c] $ This.cOption Or [u] $ This.cOption
		  If This.ListUsedTables()
		    lcMessage = [Pick a table to close:]
		    This.lNoMessage = .T.
		    lcDBF = This.GetDataFromGrid(m.lcMessage, [fullname], 0)
		    If Lastkey() = 27
		      lcDBF = []
		    Endif
		  Else
		    This.GiveMessage([No tables are currently in use], , , This.nTimeOut )
		  Endif
		Else
		  If m.llListfiles
		    lcDBF = This.ListFiles([dbf])
		  Else
		    lcDBF = This.cParameter
		  Endif
		Endif
		If Vartype(m.lcDBF) = [C] And !Empty(m.lcDBF)
		  This.lNoSelectOnExit = .T.
		  If m.llListfiles
		    lcTable = Trim(Juststem(Evaluate(This.cCursor + [.fullname])))
		    lcFullName = Trim(Evaluate(This.cCursor + [.fullname]))
		  Else
		    lcTable = Juststem(m.lcDBF)
		    lcFullName = m.lcDBF
		  Endif
		  lcFullName = This.FixPath( m.lcFullName )
		  This.cTableSelected = m.lcTable
		  Do Case
		    Case [g] $ This.cOption && Close table
		
		      Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		        Select  from <<StrExtract(this.FixPath(lcFullName),'','.')>>
		      Endtext
		      lnPos = This.oEditorWin.nCurrentLineStart
		      This.ReplaceCurrentLine(m.lcText )
		      This.oEditorWin.SetInsertionPoint(m.lnPos + 7)
		    Case [u] $ This.cOption
		      Select Trim(Evaluate(This.cCursor + [.alias]))
		      This.GiveMessage(Trim(Evaluate(This.cCursor + [.alias])) + [ is selected], , , This.nTimeOut )
		    Case [c] $ This.cOption And !Empty(m.lcDBF)
		      Use In Select(Trim(Evaluate(This.cCursor + [.alias])))
		      This.GiveMessage(Trim(Evaluate(This.cCursor + [.alias])) + [ is closed], , , This.nTimeOut )
		    Otherwise
		      If This.nWindowType = 0 Or This.lInputBox
		        Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		          * Select Select("<<m.lcTable>>" )
		          * Use "<<m.lcFullName>>"
		        Endtext
		        Select Select(m.lcTable )
		        If Select([query]) > 0 And  Lower(Juststem(Dbf(Select([query])))) = Lower(m.lcTable)
		          Use In Query
		        Endif
		
		        Use (m.lcFullName )
		        If !This.lInputBox
		          This.CutCurrentLine()
		          This.ReplaceCurrentLine(m.lcText + Chr(13))
		        Endif
		        If [b] $ This.cOption
		          This.DoBrowModal()
		        Else
		          Return
		        Endif
		      Else
		        If ! [s] $ This.cOption And ! [v] $ This.cOption 
		          Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		            Use "<<m.lcFullName>>" in Select("<<m.lcTable>>")
		          Endtext
		          This.ReplaceCurrentLine(m.lcText)
		        Endif
		      Endif
		  Endcase
		Else
		  If ! [c] $ This.cOption
		    This.GiveMessage([No files matches], , , 3000)
		  Endif
		  Return .T.
		
		Endif
		
	ENDPROC

	PROCEDURE sk_ver
		This.CutAndGiveMessage([Version: ] + This.cVersion, 64, This.cProgram )
	ENDPROC

	PROCEDURE sk_zero
		If Directory('text') and ADir(laDir,'*.sk')>0
		  Rename *.sk to text\*.sk
		Endif
		Do Case
		  Case This.cParcedText = [**]
		    This.cParameter = [*]
		    This.ChangeSidekickFile()
		  Case Empty(This.cParameter)
		    This.CutCurrentLine()
		    Modify Command (This.cSidekickFile ) Nowait
		  Case This.cParameter = [?]
		    This.CutAndGiveMessage(Textmerge([Active "<<this.cProgram>>" project file is <<this.cSidekickFile>>]), 64, This.cProgram )
		  Case Inlist(This.cParameter, [*], [-], [+], [/])
		    This.ChangeSidekickFile()
		  Case Getwordnum(This.cParameter, 1) # This.cRun
		    This.ChangeSidekickFile()
		Endcase
		
	ENDPROC

	PROCEDURE sk_zip
		Local lcDestination, lcFileList, lcFiles, lcFolder, lcText, llSuccess, lnFails, lnFiles, lnLines
		Local lnX
		
		Local Array laDummy[1]
		
		If Vartype(This.oZip) # [O]
		  This.oZipInit()
		Endif
		This.cParameter = Evl(This.cParameter, [?])
		lcFiles = Getwordnum(This.cParameter, 1)
		lcDestination = Getwordnum(This.cParameter, 2)
		If ![d] $ This.cOption
		  lcDestination = Forceext(m.lcDestination, [zip])
		  If Empty(m.lcDestination)
		    lcDestination = This.GetLastFile(Forceext(This.cZipTarget, [.zip]))
		    lcDestination = This.GetNextFile(m.lcDestination, This.nNextLength)
		  Endif
		  Do Case
		    Case  Inlist(This.GetLastCharacter(m.lcDestination), [!], [*])
		      lcDestination = Juststem(Chrtran( m.lcDestination, [*!], []))
		      lcDestination = This.GetLastFile(Forceext(m.lcDestination, [zip]))
		      lcDestination = This.GetNextFile(m.lcDestination, This.nNextLength)
		    Case This.GetLastCharacter(m.lcDestination) = [?]
		      lcDestination = Chrtran(m.lcDestination, [?], []) + This.GetSortableDate()
		  Endcase
		Endif
		If m.lcFiles # [?] And Empty(Getwordnum(This.cParameter, 2)) And ![,] $ m.lcFiles And (Empty(Justext(m.lcFiles)) Or Lower(Justext(m.lcFiles)) = [zip]) And !File(m.lcFiles)
		  lcDestination = Forceext(m.lcFiles, [.zip])
		  lcFiles = []
		Endif
		lcFiles = Evl(m.lcFiles, [?])
		Do Case
		  Case [?] $ m.lcFiles
		    If [d] $ This.cOption
		      This.AddOption([a])
		      This.lAddExtraExtensions = .T.
		    Endif
		    lcFiles = Chrtran(m.lcFiles, [?], [])
		    This.cFilter = [Include]
		    lcFiles = This.ListFiles(m.lcFiles )
		  Case Len(m.lcFiles) # Len(Chrtran(m.lcFiles, [*], []))
		    lnFiles = Adir(laDummy, m.lcFiles)
		    If m.lnFiles > 0
		      lcFolder = Justpath(m.lcFiles)
		      lcFiles = Lower(This.MakeStringFromArray(@m.laDummy, m.lcFolder ))
		    Else
		      This.GiveMessage( [No match found], 0 + 48 )
		    Endif
		  Otherwise
		Endcase
		If !Empty(m.lcFiles)
		  lcFileList = This.GetFilelistToProcess(Lower(m.lcFiles))
		Endif
		If !Empty(m.lcFileList)
		  lcText = [added]
		  If ![d] $ This.cOption
		    lnLines = Alines(m.laDummy, m.lcFileList, 0, [,])
		    lnFails = 0
		    For lnX = 1 To m.lnLines
		      Wait Window [Zipping ] + m.laDummy(m.lnX) At 10, 25 Nowait Noclear
		      If !This.oZip.Zip(m.laDummy(m.lnX), m.lcDestination)
		        This.GiveMessage(This.oZip.cErrorMessage, 48, [Fail!])
		        lnFails = m.lnFails + 1
		      Else
		        If [d] $ This.cOption
		          Erase (m.laDummy(m.lnX))
		          lcText = [moved]
		        Endif
		      Endif
		    Endfor
		
		    This.CutAndGiveMessage(Textmerge([<<m.lnLines - m.lnFails>> files <<m.lcText>> to file <<m.lcDestination >>]), ,;
		        Textmerge([<<this.cProgram>> zip utility]), This.nTimeOut)
		  Else
		
		    lcDestination = Evl(m.lcDestination, Alltrim(This.cBackupFolder))
		    If This.GetLastCharacter(m.lcDestination) = [?]
		      lcDestination = Strtran(m.lcDestination, [?], This.GetSortableDate())
		    Endif
		    llSuccess = .T.
		    If This.GiveMessage([Are you sure that you want files moved], 16 + 4, [Destination folder is ] + m.lcDestination) # 6
		      This.GiveMessage([Operation cancelled])
		      Return .T.
		    Endif
		
		    If !Directory(m.lcDestination )
		      Try
		        Md (m.lcDestination )
		      Catch
		        This.GiveMessage([Can't create folder ] + m.lcDestination, 16, [Something went wrong])
		        llSuccess = .F.
		      Endtry
		    Endif
		    If !m.llSuccess
		      Return
		    Endif
		    lnLines = Alines(m.laDummy, m.lcFileList, 0, [,])
		    lnFails = 0
		    For lnX = 1 To m.lnLines
		      Wait Window [Moving ] + m.laDummy(m.lnX) At 10, 25 Nowait Noclear
		      Try
		        Rename (m.laDummy(m.lnX)) To Forcepath( m.laDummy(m.lnX), m.lcDestination )
		      Catch
		        This.GiveMessage([Can't move file ] + m.laDummy(m.lnX))
		        lnFails = m.lnFails + 1
		      Endtry
		    Endfor
		    This.CutAndGiveMessage(Textmerge([<<m.lnLines - m.lnFails>> files moved to folder <<m.lcDestination >>]), ,;
		        Textmerge([<<this.cProgram>> move utility]), This.nTimeOut)
		  Endif
		Else
		  This.CutAndGiveMessage([Nothing to do!], , , This.nTimeOut)
		Endif
		Return
		
		
	ENDPROC

	PROCEDURE splitcommand
		Local lcCommand, lcParameter, lcText, lnColumn, lnLen, lnLines, lnX, lnY
		
		Local Array laCommands[1]
		Local Array laDummy[1]
		lcCommand = This.cCommand
		lnLen = Len(m.lcCommand)
		lcParameter = []
		Text To m.lcText Noshow Textmerge Pretext 1 + 2
		  ?       | menu
		  ??      | menu | x
		  =       | equ
		  -       | def
		  !       | sk
		  !!      | sked
		  ,       | ta
		  .       | ta
		  ::      | op    | w
		  ++      | dr    | a
		  --      | zip   | d
		  +-+     | dr    | ad
		  +++     | dr    | e
		  ?=      | db    | x
		  //      | op    | w
		  br      | br
		  bri     | br    | i
		  briw    | br    | wi
		  brw     | br    | w
		  brwi    | br    | wi
		  cl      | us    | c
		  db 
		  de      | desc
		  def
		  defa    | def
		  default | def
		  desc
		  descript    | desc  |
		  description | desc  |
		  dre     | dr    | e
		  drr     | dr    | e
		  drx     | dr    | a
		  ed
		  ec
		  er      | err
		  err
		  error   | err
		  es
		  ev      | equ
		  evl     | equ
		  equ
		  fl
		  fly    | fl    | y
		  ff
		  ffy    | ff    | y
		  ffq    | ff    | q
		  fp
		  hei
		  help
		  hk
		  hotkeys | hk
		  lo      | ot
		  lor
		  lorem   | lor
		  menu
		  mf
		  no
		  ot
		  op
		  pa
		  path    | pa
		  rt
		  shx     | sx
		  sk
		  sked
		  sx
		  ta
		  tore
		  test    | ta
		  tidy    | zip   | d
		  th      | tools
		  thor    | tools
		  tool    | tools
		  tools
		  zip       
		  unzip
		  uz      | unzip
		  ver
		  version | ver
		  
		Endtext
		If This.nWindowType > 0 && Code editor
		  Text To m.lcText Additive Noshow Textmerge Pretext 1 + 2
		      +      | ins  |
		      #      | inc  |
		      #inc   | inc  |
		      ins
		      Insert | ins  |
		      sf     | us   | g
		
		  Endtext
		Endif
		If this.lInputBox or This.nWindowType < 1 && Command window and screen
		  Text To m.lcText Additive Noshow Textmerge Pretext 1 + 2
		      +    | dr
		      0    | zero
		      **   | zero
		      *    | grp
		      gr   | grp
		      grp
		      zero
		      us
		      Use  | us
		
		  Endtext
		Endif
		If This.nWindowType > 2 && Form or class method
		  Text To m.lcText Additive Noshow Textmerge Pretext 1 + 2
		      be
		      dd
		
		  Endtext
		Endif
		lnLines = Alines(laDummy, m.lcText, 1 + 4)
		Dimension m.laCommands(m.lnLines, 3)
		For lnX = 1 To m.lnLines
		  For lnY = 1 To 3
		    laCommands(m.lnX, m.lnY) = Alltrim(Getwordnum(m.laDummy(m.lnX), m.lnY, [|]), 0, Chr(9), Chr(32), Chr(0))
		    If Empty(m.laCommands(m.lnX, 2))
		      laCommands(m.lnX, 2) = Alltrim(Getwordnum(m.laDummy(m.lnX), 1, [|]), 0, Chr(9), Chr(32), Chr(0))
		    Endif
		  Endfor
		Endfor
		For lnX = m.lnLen To 1 Step - 1
		  lnColumn = Ascan(m.laCommands, Left(m.lcCommand, m.lnX), 1, -1, 1, 1 + 2 + 4 + 8)
		  If m.lnColumn > 0
		    Exit
		  Endif
		Endfor
		If !Empty(m.lnColumn)
		  This.cCommand = Evl( m.laCommands(m.lnColumn, 2),  m.laCommands(m.lnColumn, 1))
		  lcParameter = Substr(m.lcCommand, Len(m.laCommands(m.lnColumn, 1)) + 1)
		  If !Empty(m.laCommands(m.lnColumn, 3))
		    This.cOption = This.cOption + m.laCommands(m.lnColumn, 3)
		  Endif
		Endif
		If !Empty(m.lcParameter)
		  This.cParameter = Trim(m.lcParameter + [ ] + Alltrim(This.cParameter))
		Endif
	ENDPROC

	PROCEDURE tryexecute
		Lparameters tcCommand
		Local llOK
		
		#Define ccUnknownCommand 'Illegal command'
		tcCommand = Evl(m.tcCommand, This.cParameter )
		Try
		  Execscript(m.tcCommand )
		  llOK = .T.
		Catch
		  This.GiveMessage(ccUnknownCommand, , m.tcCommand)
		Endtry
		Return m.llOK
		
		
	ENDPROC

	PROCEDURE writecurrentline
		Lparameters tcText
		Local lcClip
		If Vartype(m.tcText) # [C] or this.nWindowType < 0
		  Return
		Endif
		If this.oEditorWin.nHandle = 10
		  this.oEditorWin.nHandle = this.nHandle 
		Endif
		this.oEditorWin.Insert(m.tcText)
		
		
		
	ENDPROC

	PROCEDURE ZOrder
		LPARAMETERS nOrder
	ENDPROC

ENDDEFINE

DEFINE CLASS vfpxregistry AS custom 		&& A class that works with the Windows Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "vfpx\vfpxregistry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Close the current registry key
		*m: deletekey		&& Delete the specified key
		*m: deletekeyvalue		&& Deletes a value under a key
		*m: enumeratekeys		&& Enumerate key names from the specfied key
		*m: enumeratekeyvalues		&& Enumerate values under the specified key
		*m: getkey		&& Gets the value for the specified key
		*m: iskey		&& Returns .T. if the specified key exists
		*m: iskeyvalue		&& Returns .T. if the specified key value exists
		*m: moveregistrykeys		&& Moves all keys and values from one location to another
		*m: openkey		&& Opens the specified key
		*m: setkey		&& Sets the specified key to the specified value
		*p: ncurrentkey		&& The current open key
		*p: nmainkey		&& The main key for the Registry
		*p: nresult		&& The result code of the most recent method call
	*</DefinedPropArrayMethod>

	PROTECTED ncurrentkey
	*<PropValue>
		Name = "vfpxregistry"
		ncurrentkey = 0
		nmainkey = 0
		nresult = 0
		Width = 17
	*</PropValue>
	
	PROTECTED PROCEDURE closekey		&& Close the current registry key
		* Close the current key and blank the current key value.
		
		with This
			RegCloseKey(.nCurrentKey)
			.nCurrentKey = 0 
		endwith
		
	ENDPROC

	PROCEDURE deletekey		&& Delete the specified key
		* Delete the specified key and all subkeys and values under it.
		
		lparameters tcSubKey, ;
			tnMainKey
		local laKeys[1], ;
			lnKeys, ;
			llReturn, ;
			lnI, ;
			lcKey, ;
			lnMainKey, ;
			lcSubKey
		with This
		
		* Call ourselves recursively to delete all subkeys first.
		
			lnKeys   = .EnumerateKeys(tcSubKey, @laKeys, tnMainKey)
			llReturn = .T.
			for lnI = 1 to lnKeys
				lcKey    = addbs(tcSubKey) + laKeys[lnI]
				llReturn = .DeleteKey(lcKey, tnMainKey)
				if not llReturn
					exit
				endif not llReturn
			next lnI
			if llReturn
		
		* If the main key wasn't passed, use the default value.
		
				lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, ;
					.nMainKey, tnMainKey)
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
				lcSubKey = iif(right(tcSubKey, 1) = '\', ;
					left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteKey(lnMainKey, lcSubKey)
				llReturn = .nResult = cnSUCCESS
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes a value under a key
		* Delete the specified value in the specified key.
		
		lparameters tcSubKey, ;
			tcValue, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteValue(.nCurrentKey, tcValue)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the value.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE enumeratekeys		&& Enumerate key names from the specfied key
		lparameters tcSubKey, ;
			taKeyNames, ;
			tnMainKey
		local lnMainKey, ;
			lnNames, ;
			lcKey, ;
			lnSize, ;
			lcBuffer1, ;
			lnSize1, ;
			lcBuffer2
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnNames  = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnSize    = cnBUFFER_SIZE
					lcBuffer1 = space(cnBUFFER_SIZE)
					lnSize1   = cnBUFFER_SIZE
					lcBuffer2 = space(cnBUFFER_SIZE)
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, @lnSize, ;
						cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey   = alltrim(lcKey)
							lcKey   = left(lcKey, len(lcKey) - 1)
							lnNames = lnNames + 1
							dimension taKeyNames[lnNames]
							taKeyNames[lnNames] = lcKey
		
		* If we had an error and it's not EOF, return an error code.
		
						case .nResult <> cnERROR_EOF
							lnNames = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnNames = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnNames
		
	ENDPROC

	PROCEDURE enumeratekeyvalues		&& Enumerate values under the specified key
		lparameters tcSubKey, ;
			taKeyValues, ;
			tnMainKey
		local lnMainKey, ;
			lnValues, ;
			lcKey, ;
			lnKeySize, ;
			lcValue, ;
			lnValSize, ;
			lnType, ;
			lcBuffer, ;
			lnSize
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnValues = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnKeySize = cnBUFFER_SIZE
					lcValue   = space(cnBUFFER_SIZE)
					lnValSize = cnBUFFER_SIZE
					lnType    = 0
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
						@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey    = left(lcKey, lnKeySize)
							lnValues = lnValues + 1
							dimension taKeyValues[lnValues, 2]
							taKeyValues[lnValues, 1] = lcKey
							do case
								case lnType = cnREG_SZ
									taKeyValues[lnValues, 2] = left(lcValue, ;
										lnValSize - 1)
								case lnType = cnREG_DWORD
									taKeyValues[lnValues, 2] = ctobin(left(lcValue, 4), ;
										'4RS')
								case lnType = cnREG_EXPAND_SZ
									lcValue  = left(lcValue, lnValSize - 1)
									lcBuffer = space(cnBUFFER_SIZE)
									lnSize   = cnBUFFER_SIZE
									lnSize   = ExpandEnvironmentStrings(@lcValue, ;
										@lcBuffer, lnSize)
									taKeyValues[lnValues, 2] = left(lcBuffer, ;
										lnSize - 1)
								case lnType = cnREG_BINARY
									taKeyValues[lnValues, 2] = left(lcValue, lnValSize)
								case lnType = cnREG_MULTI_SZ
									taKeyValues[lnValues, 2] = strtran(left(lcValue, ;
										lnValSize - 1), ccNULL, ccCR)
										&& use ALINES() on the return value to get the individual
										&& values
							endcase
		
		* If we had an error and it's not EOF, return 0 entries.
		
						case .nResult <> cnERROR_EOF
							lnValues = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnValues = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnValues
		
	ENDPROC

	PROCEDURE getkey		&& Gets the value for the specified key
		lparameters tcSubKey, ;
			tcValueName, ;
			tuDefault, ;
			tnMainKey, ;
			tl64Bit
		local lnMainKey, ;
			luValue, ;
			lcValueName, ;
			lcBuffer, ;
			lnSize, ;
			lnType, ;
			lnFlags
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the default to use wasn't passed, initialize it to an empty string.
		
			luValue = iif(vartype(tuDefault) = 'C', tuDefault, '')
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Create a buffer to hold the key value.
		
			lcBuffer = space(cnBUFFER_SIZE)
			lnSize   = cnBUFFER_SIZE
			lnType   = 0
		
		* If we're supposed to get a 64-bit value, do so.
		
			do case
				case tl64Bit
					lnFlags  = cnRRF_RT_ANY + cnRRF_SUBKEY_WOW6464KEY
					.nResult = RegGetValue(.nCurrentKey, tcSubKey, lcValueName, ;
						lnFlags, @lnType, @lcBuffer, @lnSize)
		
		* Get a 32-bit value.
		
				case .OpenKey(tcSubKey, lnMainKey)
					.nResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						@lnType, @lcBuffer, @lnSize)
					.CloseKey()
			endcase
		
		* Get the key value and convert it into the proper return value based on the
		* data type.
		
			do case
				case .nResult <> cnSUCCESS
				case lnType = cnREG_SZ
					luValue = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_EXPAND_SZ
					luValue  = left(lcBuffer, lnSize - 1)
					lcBuffer = space(cnBUFFER_SIZE)
					lnSize   = cnBUFFER_SIZE
					lnSize   = ExpandEnvironmentStrings(@luValue, @lcBuffer, ;
						lnSize)
					luValue  = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_DWORD
					luValue = ctobin(left(lcBuffer, 4), '4RS')
				case lnType = cnREG_BINARY
					luValue = left(lcBuffer, lnSize)
				case lnType = cnREG_MULTI_SZ
					luValue = strtran(left(lcBuffer, lnSize - 1), ccNULL, ccCR)
						&& use ALINES() on the return value to get the individual
						&& values
			endcase
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE Init
		lparameters tnMainKey
		
		* Declare the API functions we'll need.
		
		declare integer RegOpenKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegCreateKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegDeleteKey in Win32API ;
			integer nKey, string @cSubKey
		declare integer RegCloseKey in Win32API ;
			integer nKey
		declare integer RegSetValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer nType, string cBuffer, integer nBufferSize
		declare integer RegQueryValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer @nType, string @cBuffer, integer @nBufferSize
		declare integer RegDeleteValue in Win32API ;
			integer nKey, string cSubKey
		declare integer RegEnumKey in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize
		declare integer RegEnumKeyEx in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
			integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
		declare integer RegEnumValue IN Win32API ;
			integer nKey, integer nValue, string @cSubKey, ;
			integer @nKeySize, integer nReserved, integer @nType, ;
			string @cValue, integer @nValSize
		declare integer ExpandEnvironmentStrings IN Win32API ;
			string @lpSrc, string @lpDst, integer nSize
		declare integer RegGetValue IN Win32API ;
			integer hkey, string lpSubKey, string lpValue, integer dwFlags, ;
			integer @pdwType, string @pvData, integer @pcbData
		
		* Initialize the main key.
		
		This.nMainKey = iif(vartype(tnMainKey) = 'N', tnMainKey, cnHKEY_CURRENT_USER)
		
		* Carry on with the base behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE iskey		&& Returns .T. if the specified key exists
		lparameters tcSubKey, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we could, the key exists, so close it.
		
			llReturn = .OpenKey(tcSubKey, lnMainKey)
			if llReturn
				.CloseKey()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE iskeyvalue		&& Returns .T. if the specified key value exists
		lparameters tcSubKey, ;
			tcValueName, ;
			tnMainKey
		This.GetKey(tcSubKey, tcValueName, , tnMainKey)
		return This.nResult = cnSUCCESS
		
	ENDPROC

	PROCEDURE moveregistrykeys		&& Moves all keys and values from one location to another
		lparameters tcOldKey, ;
			tcNewKey, ;
			tlNoDelete
		local laKeys[1], ;
			lnKeys, ;
			lnI, ;
			lcKey, ;
			lcOldKey, ;
			lcNewKey, ;
			laValues[1], ;
			lnValues
		with This
		
		* Get all subkeys and call ourselves recursively to get all subkeys of those
		* and copy them to the new location (and possibly remove them from the old
		* location).
		
			lnKeys = .EnumerateKeys(tcOldKey, @laKeys)
			for lnI = 1 to lnKeys
				lcKey    = laKeys[lnI]
				lcOldKey = addbs(tcOldKey) + lcKey
				lcNewKey = addbs(tcNewKey) + lcKey
				.MoveRegistryKeys(lcOldKey, lcNewKey, tlNoDelete)
			next lnI
		
		* Get all values copy them to the new location (and possibly remove them from
		* the old location).
		
			lnValues = .EnumerateKeyValues(tcOldKey, @laValues)
			for lnI = 1 to lnValues
				.SetKey(tcNewKey, laValues[lnI, 1], laValues[lnI, 2])
			next lnI
			if not tlNoDelete
				.DeleteKey(tcOldKey)
			endif not tlNoDelete
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE openkey		&& Opens the specified key
		lparameters tcSubKey, ;
			tnMainKey, ;
			tlCreate
		local lnHandle, ;
			lcSubKey, ;
			llReturn
		
		* Try to create or open the registry key. If it succeeded, store the key handle
		* in the nCurrentKey property; if not, zero nCurrentKey.
		
		with This
			lnHandle = 0
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
			lcSubKey = iif(right(tcSubKey, 1) = '\', ;
				left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
			if tlCreate
				.nResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
			else
				.nResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
			endif tlCreate
			llReturn     = .nResult = cnSUCCESS
			.nCurrentKey = iif(llReturn, lnHandle, 0)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setkey		&& Sets the specified key to the specified value
		lparameters tcSubKey, ;
			tcValueName, ;
			tuValue, ;
			tnMainKey, ;
			tnType
		local lnMainKey, ;
			lcDataType, ;
			lcValue, ;
			lnSize, ;
			lcValueName, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the type wasn't specified, initialize it to cnREG_SZ.
		
			lnType = iif(vartype(tnType) = 'N', tnType, cnREG_SZ)
		
		* Convert the value to a string if necessary. Terminate the string with a null
		* and calculate the size.
		
			lcDataType = vartype(tuValue)
			do case
				case lnType = cnREG_MULTI_SZ
					lcValue = strtran(tuValue, ccCR, ccNULL)
				case lcDataType = 'C'
					lcValue = tuValue
				case lcDataType $ 'NIFYB' and lnType = cnREG_DWORD
					lcValue = bintoc(tuValue, '4RS')
				case lcDataType $ 'NIFYB'
					lcValue = transform(tuValue)
				case lcDataType = 'D'
					lcValue = dtoc(tuValue)
				case lcDataType = 'T'
					lcValue = ttoc(tuValue)
				case lcDataType = 'L'
					lcValue = iif(tuValue, 'Y', 'N')
			endcase
			if inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
				lcValue = lcValue + ccNULL
			endif inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
			lnSize = len(lcValue)
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Try to open or create the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey, .T.)
		
		* Set the key value.
		
				.nResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
					lnType, lcValue, lnSize)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the success flag.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey, .T.)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
