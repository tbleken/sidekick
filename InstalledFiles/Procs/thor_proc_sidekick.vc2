*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="thor_proc_sidekick.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS oapi_apprun AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: checkprocessexitcode
		*m: extractdword
		*m: getprochandle
		*m: killproc
		*m: launchapp
		*m: launchappandwait
		*m: parseprocessinfostruc
		*m: releasehandle
		*p: iccommandline
		*p: icerrormessage
		*p: iclaunchdir
		*p: icwindowmode
		*p: inprocesshandle
		*p: inthreadhandle
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED inprocesshandle,inthreadhandle
	*<PropValue>
		Height = 95
		iccommandline = 0
		icerrormessage = 0
		iclaunchdir = 0
		icwindowmode = 0
		inprocesshandle = 0
		inthreadhandle = 0
		Name = "oapi_apprun"
		Width = 190
		_memberdata = <VFPData>
			<memberdata name="icerrormessage" display="icErrorMessage"/>
			<memberdata name="iccommandline" display="icCommandLine"/>
			<memberdata name="iclaunchdir" display="icLaunchDir"/>
			<memberdata name="icwindowmode" display="icWindowMode"/>
			<memberdata name="inprocesshandle" display="inProcessHandle"/>
			<memberdata name="inthreadhandle" display="inThreadHandle"/>
			<memberdata name="launchapp" display="LaunchApp"/>
			<memberdata name="launchappandwait" display="LaunchAppAndWait"/>
			<memberdata name="checkprocessexitcode" display="CheckProcessExitCode"/>
			<memberdata name="releasehandle" display="ReleaseHandle"/>
			<memberdata name="getprochandle" display="GetProcHandle"/>
			<memberdata name="killproc" display="KillProc"/>
			<memberdata name="parseprocessinfostruc" display="ParsePROCESSINFOStruc"/>
			<memberdata name="extractdword" display="ExtractDWORD"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE checkprocessexitcode
		*  examine the Process handle object's termination code member
		*  Provide the user with the option to examine another process
		*  termination code by passing an explicit handle, otherwise
		*  use the object's process instance
		Lparameter nProcessToCheck
		Local nExitCode
		
		If Type([nProcessToCheck]) # [N]
		  nProcessToCheck = This.inProcessHandle
		Endif
		Declare SHORT GetExitCodeProcess In Win32API As CheckExitCode ;
		  Integer hProcess, ;
		  Integer @lpdwExitCode
		nExitCode = 0
		If ! Isnull(m.nProcessToCheck)
		  If CheckExitCode(m.nProcessToCheck, @m.nExitCode) = 1
		    *  We retrieved an exit code (259 means still running, tho)
		    Return m.nExitCode
		  Else
		    *  Process did not exist in process table - no exit status
		    This.icErrorMessage = [Process to check not in active Process Table]
		    Return Null
		  Endif
		Else
		  This.icErrorMessage = [NULL process handle passed to CheckProcessExitCode()]
		  Return Null
		Endif
		
		
	ENDPROC

	PROCEDURE Destroy
		*  Mommy, mommy make it go away!
		With This
		  If Type([.inThreadHandle]) = [N] And Not Isnull(.inThreadHandle)
		    *  If we still hold it, dispose the Thread handle
		    .ReleaseHandle(.inThreadHandle)
		    .inThreadHandle = Null
		  Endif
		  If Type([.inProcessHandle]) = [N] And Not Isnull(.inProcessHandle)
		    *  If we still hold it, dispose the Process handle
		    .ReleaseHandle(.inProcessHandle)
		    .inProcessHandle = Null
		  Endif
		  *  NB - the process and thread object hang around until all handles to them are
		  *  disposed by CloseHandle - going out of scope doesn't release them.
		Endwith
		DoDefault()
	ENDPROC

	PROCEDURE extractdword
		*  Convert a 4 byte string to an unsigned long (DWORD)                                                                                                                                                                                                      
		Lparameter cStringToExtractFrom
		If Type([cStringToExtractFrom]) = [C] And Len(m.cStringToExtractFrom) >= 4
		  Return (((Asc(Subst(m.cStringToExtractFrom, 4, 1)) * 256) + ;
		        Asc(Subst(m.cStringToExtractFrom, 3, 1))) * 256 + ;
		      Asc(Subst(m.cStringToExtractFrom, 2, 1))) * 256 + ;
		    Asc(Left(m.cStringToExtractFrom, 1))
		Else
		  This.icErrorMessage = [Invalid DWORD string passed for conversion]
		  Return Null
		Endif
		
		
	ENDPROC

	PROCEDURE getprochandle
		*  Hand back the process handle in case someone needs it
		Return This.inProcessHandle
		
	ENDPROC

	PROCEDURE Init
		*                                                                                                                                                                                                                                                           
		*  API_AppRun - use the CreateProcess() API to launch, monitor, and kill an Executable                                                                                                                                                                       
		*                                                                                                                                                                                                                                                           
		*  Properties:                                                                                                                                                                                                                                               
		*                                                                                                                                                                                                                                                           
		*  inProcessHandle      (P)  ProcessHandle generated by CreateProcess()                                                                                                                                                                                          
		*  inThreadHandle      (P) ThreadHandle for First Thread of inProcessHandle                                                                                                                                                                                     
		*  icErrorMessage      R/O Error Message Detailed Description                                                                                                                                                                                                   
		*  icCommandLine      R/W Command Line to launch via CreateProcess()                                                                                                                                                                                            
		*  icLaunchDir        R/W Directory to use as startup dir for CreateProcess()                                                                                                                                                                                    
		*  icWindowMode      R/W Window Start Mode, one of (HID, NOR, MIN, MAX) or empty                                                                                                                                                                                
		*              defaults to empty, the default for the executable is used                                                                                                                                                                                           
		*                                                                                                                                                                                                                                                           
		*  Methods:                                                                                                                                                                                                                                                  
		*                                                                                                                                                                                                                                                           
		*  Init          (O) Command Line, (O) Start Dir, (O) Window Start Mode                                                                                                                                                                                           
		*              If sent, the icCommandLine, icLaunchDir and icWindowMode properties are set                                                                                                                                                                         
		*  Destroy                                                                                                                                                                                                                                                   
		*  LaunchApp        // Launches .icComandLine from .icLaunchDir in .icWindowMode                                                                                                                                                                                 
		*              // NB - at least .icCommandLine must be set to not fail                                                                                                                                                                                             
		*              RETURNS: BOOL, check icErrorMessage on .F.                                                                                                                                                                                                          
		*  LaunchAppAndWait    // Call LaunchApp() and wait on either user termination or process termination                                                                                                                                                          
		*              RETURNS: BOOL, check icErrorMessage on .F.                                                                                                                                                                                                          
		*  CheckProcessExitCode  (O) Process handle to check, defaults to .inProcessHandle                                                                                                                                                                            
		*              // Get Process named by Process Handle's Exit Code (259 = still running)                                                                                                                                                                            
		*              RETURNS:  Integer, check on NULL, if NULL, check icErrorMessage                                                                                                                                                                                     
		*  ExtractDWORD      (R) String to convert                                                                                                                                                                                                                      
		*              //Converts a 4 byte or longer string to a DWORD integer                                                                                                                                                                                             
		*              RETURNS:  Integer, check on NULL, if NULL arg was invalid                                                                                                                                                                                           
		*  KillProc        (O) Process handle to Terminate, defaults to .inProcessHandle                                                                                                                                                                                 
		*              // Kills specified process using TerminateProcess()                                                                                                                                                                                                 
		*              RETURNS:  BOOL, check icErrorMessage on .F.                                                                                                                                                                                                         
		*  GetProcHandle      //  Returns the Process Handle for the current Process                                                                                                                                                                                    
		*              // NB - only useful for KillProc(), since Destroy will close the handle                                                                                                                                                                             
		*              RETURNS:  Integer, check for NULL, if NULL no process was started yet                                                                                                                                                                               
		*  ParsePROCESSINFOStruc  // Pulls the Process Handle and Thread Handle from the PROCESSINFO structure                                                                                                                                                        
		*              // Only used internally                                                                                                                                                                                                                             
		*  ReleaseHandle      (R)  Handle to Close                                                                                                                                                                                                                      
		*              //  Invokes CloseHandle() to explicitly release process/thread handles                                                                                                                                                                              
		*              //  Only used internally, but can be externalized                                                                                                                                                                                                   
		*              RETURNS:  BOOL, check .icErrorMessage on .F.                                                                                                                                                                                                        
		*                                                                                                                                                                                                                                                           
		Lparameters tcCommandLine, tcLaunchDir, tcWindowMode
		*  Set up the environment for the object                                                                                                                                                                                                                     
		Local Array aDirTest[1, 5]
		
		With This
		  .icErrorMessage = []
		  .icCommandLine = []
		  .icLaunchDir = []
		  .icWindowMode = []
		  .inProcessHandle = Null
		  .inThreadHandle = Null
		  * store parameters if passed                                                                                                                                                                                                                               
		  If Type([tcCommandLine]) = [C]
		    .icCommandLine = Alltrim(m.tcCommandLine)
		  Endif
		  Do Case
		    Case Type([tcLaunchDir]) # [C]
		      *  Not a character expression - ignore                                                                                                                                                                                                                     
		    Case Adir(aDirTest, m.tcLaunchDir, [D]) # 1
		      *  Either directory doesn't exist, or there's a wildcard in the expression                                                                                                                                                                                 
		      .icErrorMessage = [Invalid directory for startup passed to Init method]
		    Otherwise
		      *  Valid directory - save it                                                                                                                                                                                                                               
		      .icLaunchDir = Alltrim(m.tcLaunchDir)
		  Endcase
		  Do Case
		    Case Type([tcWindowMode]) # [C]
		      *  Not passed in or not valid type                                                                                                                                                                                                                         
		    Case Inlist(Padr(Upper(Alltrim(m.tcWindowMode)), 3), [NOR], [MIN], [MAX], [HID])
		      *  Valid mode - set it                                                                                                                                                                                                                                     
		      .icWindowMode = Padr(Upper(Alltrim(m.tcWindowMode)), 3)
		    Otherwise
		      *  No a valid character string                                                                                                                                                                                                                             
		      If ! Empty(.icErrorMessage)
		        .icErrorMessage = .icErrorMessage + [ &] + Chr(13) + Chr(10)
		      Endif
		      .icErrorMessage = .icErrorMessage + [Invalid WindowMode passed to Init Method]
		  Endcase
		Endwith
		Return .T.
		
		
	ENDPROC

	PROCEDURE killproc
		*  A wrapper on TerminateProcess(), it will terminate the process owned by                                                                                                                                                                                  
		*  the object unless you pass it another Process Handle.  If it's already dead,                                                                                                                                                                             
		*  nothing interesting happens                                                                                                                                                                                                                              
		*                                                                                                                                                                                                                                                           
		*  TerminateProcess() does not shut down in an orderly fashion;  this is for emergencies!                                                                                                                                                                   
		Lparameter nProcessToKill
		Local nResult
		
		If Type([nProcessToKill]) # [N]
		  nProcessToKill = This.inProcessHandle
		Endif
		Declare SHORT TerminateProcess In WIN32API As KillProc ;
		  Integer hProcess, ;
		  Integer uExitCode
		If ! Isnull(m.nProcessToKill)
		  nResult = KillProc(m.nProcessToKill, 0)
		  This.icErrorMessage = Iif(m.nResult = 0, [TerminateProcess() could not kill process handle ] + Str(m.nProcessToKill), [])
		Else
		  This.icErrorMessage = [NULL handle passed to KillProc()]
		  nResult = 0
		Endif
		Return (m.nResult = 1)
		
		
	ENDPROC

	PROCEDURE launchapp
		*  Launch executable by CreateProcess() and return immediately                                                                                                                                                                                              
		Local cCommandLine, cProcessInfo, cStartUpInfo, cWindowMode, lResult, uFromDir
		
		this.icErrorMessage = []
		  If Type([ this.icCommandLine]) # [C]
		    *  Command line must be a character string                                                                                                                                                                                                                 
		    this.icErrorMessage = [icCommandLine must be set, and a string value]
		  Return .F.
		Else
		  cCommandLine = Alltrim(this.icCommandLine)
		Endif
		If Type([this.icLaunchDir]) # [C] Or Empty(this.icLaunchDir)
		  *  If not a character string, pass a null pointer, defaulting to Current Working Dir                                                                                                                                                                       
		  uFromDir = 0
		Else
		  *  Otherwise, null pad the string                                                                                                                                                                                                                          
		  uFromDir = this.icLaunchDir + Chr(0)
		Endif
		If Type([this.icWindowMode]) # [C]
		  *  If not passed, set to null string                                                                                                                                                                                                                       
		  cWindowMode = []
		Else
		  *  Translate the passed window mode to uppercase                                                                                                                                                                                                           
		  cWindowMode = Upper(this.icWindowMode)
		Endif
		*  This API call does the work.  The parameters are as follows:                                                                                                                                                                                             
		*    lpszModuleName - ptr-> file name of module to execute.                                                                                                                                                                                                  
		*      Since we aren't launching .CPLs, do not use                                                                                                                                                                                                           
		*    lpszCommandLine - ptr-> command to execute, as passed in method                                                                                                                                                                                         
		*    lpSecurityAttributesProcess - ptr-> SECURITY_ATTRIBUTES structure for Process.                                                                                                                                                                          
		*      Pass a null pointer                                                                                                                                                                                                                                   
		*    lpSecurityAttributesThread - ptr-> SECURITY_ATTRIBUTES structure for first thread.                                                                                                                                                                      
		*      Pass a null pointer                                                                                                                                                                                                                                   
		*    bInheritHandles - whether or not chlid inherits parent handles.                                                                                                                                                                                         
		*      Since no SECURITY_ATTRIBUTES passed, default to FALSE                                                                                                                                                                                                 
		*    dwCreateFlags - Process Creation Mode flag set.                                                                                                                                                                                                         
		*      We use the default mode at normal priority, ie 0                                                                                                                                                                                                      
		*    lpvEnvironment  - ptr-> a set of environment strings as if a MULTI_SZ.                                                                                                                                                                                   
		*      We don't set, so pass a null pointer                                                                                                                                                                                                                  
		*    lpszStartupDir - ptr-> the starting directory.                                                                                                                                                                                                          
		*      If none provided to method, pass a null pointer                                                                                                                                                                                                       
		*    lpStartInfo - ptr-> a STARTUPINFO structure.                                                                                                                                                                                                            
		*      We use one structure member at times.                                                                                                                                                                                                                 
		*    lpProcessInfo - ptr-> a PROCESS_INFORMATION structure, used to return PID/PHANDLE detail.                                                                                                                                                               
		*      We use one member to retain the Process handle, and destroy the thread handle                                                                                                                                                                         
		Declare SHORT CreateProcess In WIN32API As CrPr ;
		  String lpszModuleName, ;
		  String @lpszCommandLine, ;
		  String lpSecurityAttributesProcess, ;
		  String lpSecurityAttributesThread, ;
		  SHORT bInheritHandles, ;
		  Integer dwCreateFlags, ;
		  String lpvEnvironment, ;
		  String lpszStartupDir, ;
		  String @lpStartInfo, ;
		  String @lpProcessInfo
		*  Make default Structures for the CreateProcess call                                                                                                                                                                                                       
		*                                                                                                                                                                                                                                                          
		*  ProcessInfo -  struc, 4 DWORDs, a Process Handle, a Thread Handle, a ProcessID and a ThreadID                                                                                                                                                             
		*          we save the Process and Thread Handles in member properties to ensure that                                                                                                                                                                           
		*          they are properly disposed at Destroy by CloseHandle().  We dispose of the                                                                                                                                                                           
		*          thread handle immediately                                                                                                                                                                                                                            
		cProcessInfo = Repl(Chr(0), 16)
		*  StartUpInfo is a 68 byte long complex structure;  we either have 68 bytes with a cb member (byte 1) 68                                                                                                                                                   
		*  or with cb of 68, dwFlag low order byte (byte 45) of 1, and low order byte wShowWindow (byte 49) set to                                                                                                                                                  
		*  the SW_ value appropriate for the Window Mode desired.                                                                                                                                                                                                   
		Do Case
		  Case m.cWindowMode = [HID]
		    *  Hide - use STARTF_USESHOWFLAG and value of 0                                                                                                                                                                                                            
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) + ;
		      Repl(Chr(0), 23)
		  Case m.cWindowMode = [NOR]
		    *  Normal - use STARTF_USESHOWFLAG and value of 1                                                                                                                                                                                                          
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) + ;
		      Repl(Chr(0), 3) + ;
		      Chr(1) + ;
		      Repl(Chr(0), 19)
		  Case m.cWindowMode = [MIN]
		    *  Minimize - use STARTF_USESHOWFLAG and value of 2                                                                                                                                                                                                        
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) +  ;
		      Repl(Chr(0), 3) + ;
		      Chr(2) + ;
		      Repl(Chr(0), 19)
		  Case m.cWindowMode = [MAX]
		    *  Maximize - use STARTF_USESHOWFLAG and value of 3                                                                                                                                                                                                        
		    cStartUpInfo = Chr(68) + ;
		      Repl(Chr(0), 43) + ;
		      Chr(1) +  ;
		      Repl(Chr(0), 3) + ;
		      Chr(3) + ;
		      Repl(Chr(0), 19)
		  Otherwise
		    *  Use default of application                                                                                                                                                                                                                              
		    cStartUpInfo = Chr(68) + Repl(Chr(0), 67)
		Endcase
		*  Do it!                                                                                                                                                                                                                                                   
		lResult = CrPr(  0, ;
		    m.cCommandLine, ;
		    0, 0, 0, 0, 0, ;
		    m.uFromDir, ;
		    @m.cStartUpInfo, ;
		    @m.cProcessInfo)
		*  Strip the handles from the PROCESS_INFORMATION structure and save in private properties                                                                                                                                                                  
		If m.lResult = 1
		  this.ParseProcessInfoStruc(m.cProcessInfo)
		  Return .T.
		Else
		  this.icErrorMessage = [Process Specified by icCommandLine could not be started]
		  Return .F.
		Endif
		
		
		
	ENDPROC

	PROCEDURE launchappandwait
		*  Invoke LaunchApp(), and then wait on the process to terminate before returning control                                                                                                                                                                    
		#Define cnINFINITE     0xFFFFFFFF
		#Define cnHalfASecond  500  && milliseconds
		#Define cnTimedOut    258  && 0x0102
		*  We need some API calls, declare here                                                                                                                                                                                                                      
		*  GetCurrentProcess returns the pseudohandle of the current process (ie VFP instance)                                                                                                                                                                       
		Local uResult
		
		Declare Integer GetCurrentProcess In WIN32API As GetCurrProc
		*  WaitForIdleInput waits until the application is instantiated and at it's event loop                                                                                                                                                                       
		Declare Integer WaitForInputIdle In WIN32API As WaitInpIdle ;
		  Integer nProcessHandle, ;
		  Integer nWaitForDuration
		*  WaitForSingleObject waits until the handle in parm 1 is signalled or the timeout period expires                                                                                                                                                           
		Declare Integer WaitForSingleObject In WIN32API As WaitOnAppExit ;
		  Integer hProcessHandle, ;
		  Integer dwTimeOut
		*  Save the Process handle if any and the result of LaunchApp                                                                                                                                                                                                
		*  Fire the app and save the process handle                                                                                                                                                                                                                  
		uResult = 0
		With This
		  .icErrorMessage = []
		  If .LaunchApp()
		    uResult = 1
		    *  It's been launched;  wait until we're idling along                                                                                                                                                                                                      
		    = WaitInpIdle(GetCurrProc(), cnINFINITE)
		    *  As long as the other process exists, wait for it                                                                                                                                                                                                        
		    Do While WaitOnAppExit(.inProcessHandle, cnHalfASecond) = cnTimedOut
		      *  Give us an out in case the other app hangs - let <Esc> terminate waits                                                                                                                                                                                 
		      Try
		        If Inkey() = 27
		          *  Still running but we aren't waiting - return a -1 as a warning                                                                                                                                                                                       
		          .icErrorMessage = [Process started but user did not wait on termination]
		          uResult = 0
		          Exit
		        Endif
		      Catch
		      Endtry
		    Enddo
		  Else
		    *  Return 0 to indicate failure                                                                                                                                                                                                                            
		    uResult = 0
		  Endif
		Endwith
		Return (m.uResult = 1)
		
		
	ENDPROC

	PROTECTED PROCEDURE parseprocessinfostruc
		*  Pull the Process and thread handles out of the PROCESSINFO structure
		Lparameter cProcessInfoStructure
		With This
		  .inProcessHandle = .ExtractDWORD(m.cProcessInfoStructure)
		  .inThreadHandle = .ExtractDWORD(Subst(m.cProcessInfoStructure, 5))
		Endwith
	ENDPROC

	PROTECTED PROCEDURE releasehandle
		*  This uses CloseHandle to release a handle of any type.  I didn't expose it,
		*  mostly so that people wouldn't accidentally mash up things they shouldn't when
		*  experimenting
		Lparameter nHandleToRelease
		Local nResult
		
		*  Use CloseHandle(), returns a BOOL;  0 = False
		Declare SHORT CloseHandle In Win32API As CloseHand Integer nHandleToClose
		If Type([nHandleToRelease]) = [N] And ! Isnull(m.nHandleToRelease)
		  nResult = CloseHand(m.nHandleToRelease)
		  This.icErrorMessage = Iif(m.nResult = 0, [CloseHandle() failed to close handle ] + Str(m.nHandleToRelease), [])
		Else
		  This.icErrorMessage = [Invalid handle passed to ReleaseHandle() invocation]
		  nResult = 0
		Endif
		Return (m.nResult = 1)
	ENDPROC

ENDDEFINE

DEFINE CLASS ozip AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: executecommand
		*m: getproperfilecase
		*m: unzip
		*m: zip
		*p: cerrormessage
		*p: cwindowmode
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cerrormessage = 
		cwindowmode = HID                                                            
		Height = 70
		Name = "ozip"
		Width = 202
		_memberdata = <VFPData>
			<memberdata name="unzip" display="UnZip"/>
			<memberdata name="zip" display="Zip"/>
			<memberdata name="getproperfilecase" display="GetProperFileCase"/>
			<memberdata name="executecommand" display="ExecuteCommand"/>
			<memberdata name="cerrormessage" display="cErrorMessage"/>
			<memberdata name="cwindowmode" display="cWindowMode"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE executecommand
		lparameters tcCommand, ;
		  tcFolder, ;
		  tcWindowMode, ;
		  tlNoWait
		local lcFolder, ;
		  lcCommand, ;
		  lnPos, ;
		  lcBatFile, ;
		  loAPI, ;
		  lcMessage, ;
		  lnResult, ;
		  llResult
		* Get default values for missing parameters.
		if vartype(tcFolder) <> 'C' or empty(tcFolder)
		  lcFolder = fullpath('')
		else
		  lcFolder = tcFolder
		endif vartype(tcFolder) <> 'C' or empty(tcFolder)
		if right(lcFolder, 1) = '\'
		  lcFolder = left(lcFolder, len(lcFolder) - 1)
		endif right(lcFolder, 1) = '\'
		* If the command contains a redirected output, which isn't supported by
		* API_AppRun, we'll put the command into a BAT file and execute that.
		lcCommand = tcCommand
		lnPos     = at('>', tcCommand)
		if lnPos > 0
		  lcBatFile = addbs(sys(2023)) + 'Execute.bat'
		  strtofile(tcCommand, lcBatFile)
		  lcCommand = '"' + fullpath(lcBatFile) + '"'
		endif lnPos > 0
		* Use API_AppRun to execute the command.
		*!*  loAPI = newobject('API_AppRun', 'API_AppRun.prg', '', lcCommand, lcFolder, ;
		*!*    evl(tcWindowMode, 'HID'))
		Local loAPI as oapi_apprun of mylib.vcx
		loAPI = NewObject('oapi_apprun', 'mylib.vcx', '', lcCommand, lcFolder, evl(tcWindowMode, 'HID'))
		do case
		  case not empty(loAPI.icErrorMessage)
		    lcMessage = loAPI.icErrorMessage
		  case tlNoWait and loAPI.LaunchApp()
		    lcMessage = ''
		  case tlNoWait
		    lcMessage = loAPI.icErrorMessage
		  case loAPI.LaunchAppAndWait()
		    lnResult  = nvl(loAPI.CheckProcessExitCode(), -1)
		    llResult  = lnResult = 0
		    lcMessage = iif(llResult, '', ;
		      evl(loAPI.icErrorMessage, 'The error code is ' + transform(lnResult)))
		  otherwise
		    lcMessage = loAPI.icErrorMessage
		endcase
		* Erase the BAT file.
		if lnPos > 0
		  erase (lcBatFile)
		endif lnPos > 0
		return lcMessage
		
		
	ENDPROC

	PROCEDURE getproperfilecase
		*==============================================================================
		* Function:      GetProperFileCase
		* Purpose:      Returns the specified file or folder name in the case as it
		*            exists on disk
		* Author:      Doug Hennig
		* Last revision:  06/26/2018
		* Parameters:    tcName   - the name of the file or folder
		*          tlFolder - .T. if the name is a folder
		* Returns:      the file or folder name in the correct case
		* Environment in:  Scripting.FileSystemObject can be instantiated
		*          if a public variable named __FSO exists, it may contain a
		*            reference to Scripting.FileSystemObject
		* Environment out:  a public variable named __FSO exist contains a reference to
		*            Scripting.FileSystemObject
		*==============================================================================
		lparameters tcName, tlFolder
		local loFSO, ;
		  llExists, ;
		  loFile, ;
		  lcName, ;
		  lcFolder, ;
		  loFolder
		try
		  if type('__FSO') = 'O'
		    loFSO = __FSO
		  else
		    loFSO = createobject('Scripting.FileSystemObject')
		    public __FSO
		    __FSO = loFSO
		  endif type('__FSO') = 'O'
		  if tlFolder
		    llExists = directory(tcName)
		  else
		    llExists = file(tcName)
		  endif tlFolder
		  do case
		    case llExists and tlFolder
		      loFile = loFSO.GetFolder(tcName)
		      lcName = addbs(loFile.Path)
		    case llExists
		      loFile = loFSO.GetFile(tcName)
		      lcName = loFile.Path
		    case '\' $ tcName
		      lcFolder = justpath(tcName)
		      loFolder = loFSO.GetFolder(lcFolder)
		      lcName   = addbs(loFolder.Path) + lower(justfname(tcName))
		    otherwise
		      lcName = lower(tcName)
		  endcase
		catch
		  lcName = lower(tcName)
		endtry
		return lcName
		
		
	ENDPROC

	PROCEDURE Init
		Declare Sleep In Win32API Integer nMilliseconds
	ENDPROC

	PROCEDURE unzip
		Lparameters tcZipFile, tcFolder
		Local loException As Exception
		Local lcCommand, lcFolder, lcMessage, lcZipFile, llResult, loFiles, loShell
		
		* Ensure we have valid parameters.
		Do Case
		  Case Vartype(tcZipFile) <> [C] Or Empty(tcZipFile)
		    This.cErrorMessage = [The zip file was not specified]
		  Case Vartype(tcFolder) <> [C] Or Empty(tcFolder)
		    This.cErrorMessage = [The folder was not specified]
		    * Ensure the file exists.
		  Case Not File(tcZipFile)
		    This.cErrorMessage = tcZipFile + [ does not exist]
		    * Create the extraction folder if necessary.
		  Otherwise
		    lcFolder = this.GetProperFileCase(Fullpath(tcFolder))
		    If Not Directory(m.lcFolder)
		      Try
		        Md (m.lcFolder)
		        llResult = .T.
		      Catch To m.loException
		        This.cErrorMessage = [Error creating ] + m.lcFolder + [: ] + ;
		          m.loException.Message
		      Endtry
		      If Not m.llResult
		        Return .F.
		      Endif Not m.llResult
		    Endif Not Directory(m.lcFolder)
		    * Try to use Shell.Application to extract files.
		    llResult  = .F.
		    lcZipFile = Fullpath(tcZipFile)
		    Try
		      loShell = Createobject([Shell.Application])
		      loFiles = m.loShell.NameSpace(m.lcZipFile).Items
		      If m.loFiles.Count > 0
		        m.loShell.NameSpace(m.lcFolder).CopyHere(m.loFiles, cnSHELL_YES_TO_ALL)
		        llResult = .T.
		      Endif m.loFiles.Count > 0
		    Catch To m.loException
		    Endtry
		    * If that failed, use PowerShell.
		    If Not m.llResult
		      lcCommand = [cmd /c %SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe ] + ;
		        [Microsoft.Powershell.Archive\Expand-Archive -Force ] + ;
		        [-Path '] + m.lcZipFile + [' ] + ;
		        [-DestinationPath '] + m.lcFolder + [']
		      lcMessage = this.ExecuteCommand(m.lcCommand, m.lcFolder, This.cWindowMode)
		      llResult  = Empty(m.lcMessage)
		      If Not m.llResult
		        This.cErrorMessage = m.lcMessage
		      Endif Not m.llResult
		    Endif Not m.llResult
		Endcase
		Return m.llResult
		
	ENDPROC

	PROCEDURE zip
		Lparameters tcFiles, tcZipFile, tlOverwrite
		Local loException As Exception
		Local loShell As [Shell.Application]
		Local lcCommand, lcFile, lcFiles, lcMessage, lcTarget, llOK, llResult, lnFiles, lnHandle, lnI
		Local loZipFile
		
		Local Array laFiles[1]
		
		#Define ccCRLF    Chr(13) + Chr(10)
		#Define ccCR    Chr(13)
		#Define ccLF    Chr(10)
		* Ensure we have valid parameters.
		Do Case
		  Case Vartype(tcFiles) <> [C] Or Empty(tcFiles)
		    This.cErrorMessage = [The files were not specified]
		  Case Vartype(tcZipFile) <> [C] Or Empty(tcZipFile)
		    This.cErrorMessage = [The zip file was not specified]
		    * Create an empty Zip file if we're supposed to, then try to use Shell.Application
		    * to add files to it.
		  Otherwise
		    lnFiles = Alines(laFiles, tcFiles, 1 + 4, ccCR, ccLF, [,])
		    lcFiles = []
		    For lnI = 1 To m.lnFiles
		      lcFile  = this.GetProperFileCase(Fullpath(m.laFiles[m.lnI]))
		      lcFiles = m.lcFiles + Iif(Empty(m.lcFiles), [], [,]) + ['] + m.lcFile + [']
		      If Not File(m.lcFile)
		        This.cErrorMessage = m.lcFile + [ does not exist]
		        Return .F.
		      Endif Not File(m.lcFile)
		    Next m.lnI
		    Try
		      lcTarget = this.GetProperFileCase(Fullpath(tcZipFile))
		      llOK     = .T.
		      If Not File(m.lcTarget) Or tlOverwrite
		        lnHandle = Fcreate(m.lcTarget)
		        If m.lnHandle > 0
		          Fclose(m.lnHandle)
		        Else
		          llOK = .F.
		        Endif m.lnHandle > 0
		      Endif Not File(m.lcTarget) ...
		      If m.llOK
		        loShell   = Createobject([Shell.Application])
		        loZipFile = m.loShell.NameSpace(m.lcTarget)
		        For lnI = 1 To m.lnFiles
		          lcFile = this.GetProperFileCase(Fullpath(m.laFiles[m.lnI]))
		          m.loZipFile.CopyHere(m.lcFile)
		          Do While m.loZipFile.Items.Count < m.lnI
		            Sleep(1000)
		          Enddo While m.loZipFile.Items.Count < m.lnI
		        Next m.lnI
		        llResult = .T.
		      Endif m.llOK
		    Catch To m.loException
		    Endtry
		    If Not m.llOK
		      This.cErrorMessage = [Cannot create ] + m.lcTarget + [.]
		      Return .F.
		    Endif Not m.llOK
		    * If that failed, use PowerShell.
		    If Not m.llResult
		      lcCommand = [cmd /c %SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe ] + ;
		        [Microsoft.Powershell.Archive\Compress-Archive ] + ;
		        [-Path @(] + m.lcFiles + [) ] + ;
		        [-DestinationPath '] + m.lcTarget + ['] + ;
		        Iif(tlOverwrite, [], [ -Update])
		      lcMessage = this.ExecuteCommand(m.lcCommand, Justpath(m.lcTarget), This.cWindowMode)
		      llResult  = Empty(m.lcMessage)
		      If Not m.llResult
		        This.cErrorMessage = m.lcMessage
		      Endif Not m.llResult
		    Endif Not m.llResult
		Endcase
		Return m.llResult
		
		
	ENDPROC

ENDDEFINE

DEFINE CLASS pg AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseIndex" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkInc" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFind" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: crecordsource_assign
		*m: dofiltergrid
		*m: editmemo
		*m: fontsize_assign
		*m: getgridwidth
		*m: getinputmask
		*m: getsortedstring		&& Sorts a string so that the longest words come first
		*m: hidecolumn
		*m: iscursor
		*m: istag
		*m: lcenter_assign
		*m: linputmask_assign
		*m: lreadonly_assign
		*m: lshowzero_assign
		*m: lzebra_assign
		*m: makecontrols
		*m: makeinputmask
		*m: makezebra
		*m: ngridwidth_access
		*m: nhighlightbackcolor_assign
		*m: nhighlightforecolor_assign
		*m: nzebracolor1_assign
		*m: nzebracolor2_assign
		*m: resolvemouse
		*m: setcaption
		*m: setdefaults
		*m: setgriddefaults
		*m: setproperties
		*m: sortgrid
		*m: visible_assign
		*p: calias
		*p: cback
		*p: ccursor
		*p: cmask
		*p: cmemo
		*p: cnosearchtext
		*p: cnulldisplay		&& Character(s) to show for null values
		*p: cnulldisplayold
		*p: crecordsource
		*p: csortfield
		*p: ctable
		*p: ctext
		*p: laskfortable
		*p: lautofit
		*p: lcenter
		*p: lcheckboxes
		*p: lenter
		*p: lfind
		*p: lincinprocess
		*p: lincrementalseek
		*p: linputmask
		*p: llocate
		*p: lmax
		*p: lnofind
		*p: lreadonly
		*p: lsetfocustofind
		*p: lshownulls
		*p: lshowzero
		*p: lzebra
		*p: ncolmemobackcolor
		*p: ncolmemodisabledbackcolor
		*p: ngridwidth
		*p: nheaderbackcolor
		*p: nheadersortablebackcolor
		*p: nheadersortedbackcolor
		*p: nhidelast
		*p: nhighlightbackcolor
		*p: nhighlightforecolor
		*p: nincstart
		*p: nselect
		*p: nzebracolor1
		*p: nzebracolor2
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		calias = 
		Caption = "ProGrid"
		cback = 
		ccursor = 
		cmask = !
		cmemo = <Memo>
		cnosearchtext = No text entered! All records are shown.
		cnulldisplay = 
		cnulldisplayold = 
		crecordsource = 
		csortfield = 
		ctable = 
		ctext = 
		DoCreate = .T.
		FontSize = 10
		Height = 1117
		laskfortable = .F.
		lcenter = .F.
		lcheckboxes = .F.
		Left = 8
		lenter = .F.
		lfind = .F.
		lincinprocess = .F.
		lincrementalseek = .F.
		linputmask = .F.
		llocate = .T.
		lmax = .F.
		lnofind = .F.
		lreadonly = .F.
		lsetfocustofind = .T.
		lshownulls = .F.
		lshowzero = .F.
		lzebra = .T.
		MinWidth = 450
		Name = "pg"
		ncolmemobackcolor = 0
		ncolmemodisabledbackcolor = 0
		ngridwidth = 0
		nheaderbackcolor = 0
		nheadersortablebackcolor = 0
		nheadersortedbackcolor = 0
		nhidelast = 0
		nhighlightbackcolor = (rgb(210,210,210))
		nhighlightforecolor = 0
		nincstart = 2
		nselect = 0
		nzebracolor1 = 16777215
		nzebracolor2 = 16777158
		ScrollBars = 2
		ShowTips = .T.
		Top = -2
		Visible = .T.
		Width = 1600
		_memberdata = <VFPData>
			<memberdata name="caption" display="Caption"/>
			<memberdata name="ccursor" display="cCursor"/>
			<memberdata name="cnosearchtext" display="cNoSearchText"/>
			<memberdata name="dofiltergrid" display="doFilterGrid"/>
			<memberdata name="getsortedstring" display="getSortedString"/>
			<memberdata name="lmax" display="lMax"/>
			<memberdata name="nselect" display="nSelect"/>
			<memberdata name="setproperties" display="setProperties"/>
			<memberdata name="calias" display="cAlias"/>
			<memberdata name="csortfield" display="cSortField"/>
			<memberdata name="ctable" display="cTable"/>
			<memberdata name="ctext" display="cText"/>
			<memberdata name="lcenter" display="lCenter"/>
			<memberdata name="lcenter_assign" display="lCenter_Assign"/>
			<memberdata name="lreadonly" display="lReadOnly"/>
			<memberdata name="lreadonly_assign" display="lReadOnly_Assign"/>
			<memberdata name="lshowzero" display="lShowZero"/>
			<memberdata name="lshowzero_assign" display="lShowZero_Assign"/>
			<memberdata name="lzebra" display="lZebra"/>
			<memberdata name="lzebra_assign" display="lZebra_Assign"/>
			<memberdata name="makeinputmask" display="makeInputMask"/>
			<memberdata name="nheaderbackcolor" display="nHeaderBackColor"/>
			<memberdata name="nheadersortablebackcolor" display="nHeaderSortableBackColor"/>
			<memberdata name="nheadersortedbackcolor" display="nHeaderSortedBackColor"/>
			<memberdata name="nzebracolor1" display="nZebraColor1"/>
			<memberdata name="nzebracolor1_assign" display="nZebraColor1_Assign"/>
			<memberdata name="nzebracolor2" display="nZebraColor2"/>
			<memberdata name="nzebracolor2_assign" display="nZebraColor2_Assign"/>
			<memberdata name="setcaption" display="setCaption"/>
			<memberdata name="sortgrid" display="sortGrid"/>
			<memberdata name="makezebra" display="makeZebra"/>
			<memberdata name="crecordsource" display="cRecordSource"/>
			<memberdata name="crecordsource_assign" display="cRecordSource_Assign"/>
			<memberdata name="visible" display="Visible"/>
			<memberdata name="visible_assign" display="Visible_Assign"/>
			<memberdata name="fontsize" display="FontSize"/>
			<memberdata name="fontsize_assign" display="FontSize_Assign"/>
			<memberdata name="getinputmask" display="getInputMask"/>
			<memberdata name="iscursor" display="isCursor"/>
			<memberdata name="istag" display="isTag"/>
			<memberdata name="linputmask" display="lInputMask"/>
			<memberdata name="linputmask_assign" display="lInputMask_Assign"/>
			<memberdata name="name" display="Name"/>
			<memberdata name="lautofit" display="lAutofit"/>
			<memberdata name="editmemo" display="editMemo"/>
			<memberdata name="makecontrols" display="makeControls"/>
			<memberdata name="cmemo" display="cMemo"/>
			<memberdata name="getgridwidth" display="getGridWidth"/>
			<memberdata name="ngridwidth" display="nGridWidth"/>
			<memberdata name="ngridwidth_access" display="nGridWidth_Access"/>
			<memberdata name="cmask" display="cMask"/>
			<memberdata name="nhighlightbackcolor" display="nHighlightBackColor"/>
			<memberdata name="nhighlightbackcolor_assign" display="nHighlightBackColor_Assign"/>
			<memberdata name="nhighlightforecolor" display="nHighlightForeColor"/>
			<memberdata name="nhighlightforecolor_assign" display="nHighlightForeColor_Assign"/>
			<memberdata name="minwidth" display="MinWidth"/>
			<memberdata name="hidecolumn" display="hideColumn"/>
			<memberdata name="resolvemouse" display="resolveMouse"/>
			<memberdata name="lshownulls" display="lShowNulls"/>
			<memberdata name="cnulldisplay" display="cNullDisplay"/>
			<memberdata name="cnulldisplayold" display="cNullDisplayOld"/>
			<memberdata name="lnofind" display="lNoFind"/>
			<memberdata name="lfind" display="lFind"/>
			<memberdata name="setdefaults" display="SetDefaults"/>
			<memberdata name="ncolmemobackcolor" display="nColMemoBackColor"/>
			<memberdata name="ncolmemodisabledbackcolor" display="nColMemoDisabledBackColor"/>
			<memberdata name="setgriddefaults" display="setGridDefaults"/>
			<memberdata name="lincrementalseek" display="lIncrementalSeek"/>
			<memberdata name="lincinprocess" display="lIncInProcess"/>
			<memberdata name="laskfortable" display="lAskForTable"/>
			<memberdata name="lenter" display="lEnter"/>
			<memberdata name="nhidelast" display="nHideLast"/>
			<memberdata name="llocate" display="lLocate"/>
			<memberdata name="nincstart" display="nIncStart"/>
			<memberdata name="lcheckboxes" display="lCheckboxes"/>
			<memberdata name="width" display="Width"/>
			<memberdata name="picture" display="Picture"/>
			<memberdata name="icon" display="Icon"/>
			<memberdata name="lsetfocustofind" display="lSetFocusToFind"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'chkInc' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 9, ;
		AutoSize = .F., ;
		Caption = "\<Inc. seek (*)", ;
		ControlSource = "thisform.lIncrementalSeek", ;
		Height = 17, ;
		Left = 1500, ;
		Name = "chkInc", ;
		Top = 24, ;
		Value = .F., ;
		Width = 83
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'chkUseIndex' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 9, ;
		AutoSize = .F., ;
		Caption = "\<Use index (!)", ;
		Height = 17, ;
		Left = 1500, ;
		Name = "chkUseIndex", ;
		Top = 7, ;
		Value = .F., ;
		Width = 87
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'grd' AS grid WITH ;
		Anchor = 15, ;
		Height = 862, ;
		HighlightBackColor = 192,192,255, ;
		HighlightForeColor = 0,0,0, ;
		HighlightStyle = 2, ;
		Left = 0, ;
		Name = "grd", ;
		TabIndex = 1, ;
		Themes = .F., ;
		Top = 60, ;
		Width = 1164
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'lblFind' AS label WITH ;
		Alignment = 1, ;
		Anchor = 3, ;
		Caption = "\<Find", ;
		Height = 21, ;
		Left = 4, ;
		Name = "lblFind", ;
		TabIndex = 8, ;
		Top = 15, ;
		Width = 45, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'txtFind' AS textbox WITH ;
		Anchor = 11, ;
		Height = 30, ;
		Left = 60, ;
		Name = "txtFind", ;
		TabIndex = 9, ;
		Top = 12, ;
		Width = 1428, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Activate
		this.lZebra = this.lZebra 
		If this.lFind 
		*!*			Keyboard '{ALT+F}' plain
		  this.txtFind.SetFocus()
		EndIf
	ENDPROC

	PROCEDURE crecordsource_assign
		lparameters tcRecordSource
		If !Empty(Justext(tcRecordSource)) && Alias
		   This.Grd.RecordSourceType = 0
		Else 
			this.Grd.RecordSourceType = 1    
		Endif
		This.cRecordSource = tcRecordSource
		this.cTable = JustStem(this.cRecordSource)
		ThisForm.setCaption()
	ENDPROC

	PROCEDURE Destroy
		Use in (Select(this.cCursor))
		Set Filter To 
		Pop Key 
	ENDPROC

	PROCEDURE dofiltergrid
		Lparameters tcText
		Local laFields[1], laFtypes[1], lcText, lcValue, lcWord, llFound, lnFields, lnRecord, lnWord, lnX
		lcText = Upper(Alltrim(m.tcText))
		If Len(m.lcText ) = 0 && or m.lcText == this.cMask
			this.txtFind.Value = ''
		*!*	   Wait Window Thisform.cNoSearchText
		   Select (this.cTable)
		   Set Filter To 
		   this.lZebra = .T.
		   this.Grd.SetFocus()
		   Return
		EndIf
		If !thisform.lIncrementalSeek 
			Wait Window 'Search in process...' nowait
		Endif
		lcCrlf = Chr(13)+Chr(10)
		Thisform.nSelect = Select()
		lnRec = Recno()
		Select 0
		Create Cursor (Thisform.cCursor ) (Record i)
		Index On Record Tag Record
		Select (Thisform.nSelect )
		Set Filter To
		lcPoint = Set("Point")
		Set Point To '.'
		lnFields = Afields(laFields)
		Dimension m.laFtypes(m.lnFields)
		For lnX = 1 To m.lnFields
		   laFtypes(m.lnX) = Vartype(Evaluate(Field(m.lnX)))
		EndFor
		For lnWord = 1 To Getwordcount(m.lcText)
		   lcWord = Getwordnum(m.lcText, m.lnWord)
		   If m.lnWord > 1
		      Set Relation To Recno() Into (Thisform.cCursor)
		      Set Filter To !Eof(Thisform.cCursor )
		   EndIf
		   If m.lnWord = 1 and ((Left(m.lcWord,1) = thisform.cMask and Len(m.lcWord) > 1) or !Empty(this.chkUseIndex.Value))
		   	If Left(m.lcWord,1) = thisform.cMask
			   	m.lcWord = Substr(m.lcWord ,2)
		   	Endif
		   	lnWordVal = Val(m.lcWord)
		   	lcCurDummy = 'cur_'+Sys(2015)
		   	lcSql = Textmerge('Select Cast(Recno() as i) as record from <<Alias()>> where ')
		   	lnTags = ATagInfo(laTags)
		   	For lnX = 1 to Tagcount()
		   		lcExpression = m.laTags(m.lnX,3)
		   		If '+'$m.lcExpression or '"'$m.lcExpression or !Empty(m.laTags(lnX,4))
		   			Loop
		   		EndIf
		   		m.lcType = Type('Evaluate(laTags(m.lnX,3))')
		    		Do Case
		   			Case InList(m.lcType ,'L','D','T','G','M','Q','W','Y')
		   				Loop
		   		   Case m.lcType = 'N' 
		   		   	If m.lnWordVal > 0
			   		   	m.lcSql = Textmerge( '<<m.lcSql>>; <<lcCrlf>> <<laTags(m.lnX,3)>> = <<m.lnWordVal>>')
			   		   Else
			   		   	loop
		   		   	Endif
		   		   Otherwise
		   		   	m.lcSql = Textmerge( '<<m.lcSql>>; <<lcCrlf>> <<laTags(m.lnX,3)>> = [<<m.lcWord>>]')
		   		EndCase
		   		If m.lnX < m.lnTags
		   			m.lcSql = m.lcSql + ' or '
		   		EndIf
		   	EndFor
		   	If Right(m.lcSql,4) = ' or '
		   		m.lcSql = Left(m.lcSql ,Len(m.lcSql)-4)
		   	Endif
		   	m.lcSql = Textmerge('<<m.lcSql>> into cursor <<m.lcCurDummy>> readwrite')
		   	_screen.AddProperty('sql',m.lcSql) 
		   	ExecScript(lcSql)
		   	If _tally>0
		   		Select (thisform.cCursor)
		   		Append from dbf(lcCurDummy)
		   		Use in (m.lcCurDummy)
		   	Endif
		   else
			   Scan
			      llFound = .F.
			      For lnX = 1 To m.lnFields
			         lcValue = Evaluate(Field(m.lnX))
			         Do Case
			            Case Inlist(Vartype(m.lcValue), [G], [L], [Q])
			               Loop
			            Case Vartype(m.lcValue) # [C]
			               lcValue = Transform(m.lcValue)
			            Otherwise
			         Endcase
			         lcValue = Upper(m.lcValue)
			         lnRecord = Recno()
			         If m.lcWord $ m.lcValue
			            If m.lnWord = 1
			               Insert Into (Thisform.cCursor) (Record) Values (m.lnRecord)
			            Endif
			            llFound = .T.
			            Exit
			         Endif
			      Endfor
			      If !m.llFound And m.lnWord > 1
			         Delete In (Thisform.cCursor)
			      Endif
			   EndScan
		   Endif
		   Select * From (Thisform.cCursor) Into Cursor (Thisform.cCursor) Readwrite Where !Deleted()
		   Index On Record Tag Record
		   Select (Thisform.nSelect)
		EndFor
		If !thisform.lIncrementalSeek 
			Wait clear
		Endif
		Set Point To m.lcPoint 
		Set Relation To Recno() Into (Thisform.cCursor )
		Set Filter To !Eof(Thisform.cCursor )
		Thisform.lZebra = .F.
		*Go Top
		If thisform.lLocate
			Locate
		Else
			Go m.lnRec 
		Endif
		*!*	Endif !this.lIncrementalSeek
		this.grd.Refresh()
		*!*	If thisform.lIncrementalSeek 
		*!*	*!*		thisform.txtFind.SetFocus()
		*!*	else	
		*!*		Thisform.Grd.Refresh()
		*!*		Thisform.Grd.SetFocus()
		*!*	Endif
		
	ENDPROC

	PROCEDURE editmemo
		Local lcField
		Local laEvents[1], loHeader
		Local laDummy[1], lnHeight, lnWidth, lnX
		
		Aevents( laEvents, 0 )
		m.loHeader = m.laEvents[ 1 ]
		m.lcField = m.loHeader.Parent.ControlSource
		m.lnHeight = Alines(laDummy, Evaluate(m.lcField))
		m.lnWidth = 1
		For m.lnX = 1 To m.lnHeight
		  If Len(m.laDummy(m.lnX)) > m.lnWidth
		    m.lnWidth = Len(m.laDummy(m.lnX))
		  Endif
		Endfor
		m.lnWidth = Min(m.lnWidth, 200)
		m.lnHeight = Min(m.lnHeight + 5, 25)
		lcText = Evaluate( m.lcField)
		Define Window loWindow From 1, 1 Size m.lnHeight, m.lnWidth Font This.FontName, This.FontSize;
		  Title Justext(m.lcField) Close Float Grow
		Move Window loWindow Center
		If Thisform.lReadOnly
		  If !Empty(m.lcText)
		    Modify Memo (m.lcField) Window loWindow Noedit
		  Endif
		Else
		  Modify Memo (m.lcField) Window loWindow Nowait
		Endif
		
	ENDPROC

	PROCEDURE fontsize_assign
		lparameters tFontSize
		If m.tFontSize < 6
		  m.tFontSize = _screen.FontSize 
		Endif
		This.FontSize = tFontSize
		this.SetAll('fontsize',m.tFontSize)
		this.Grd.AutoFit()
		this.AutoCenter = .T.
		this.Width = this.nGridWidth 
		this.AutoCenter = .T.
		
	ENDPROC

	PROCEDURE getgridwidth
		lnWidth = this.Grd.GridLineWidth 
		lnLineWidth = this.Grd.GridLineWidth
		For lnX = 1 to this.Grd.ColumnCount
			If this.Grd.Columns(lnX).visible 
				m.lnWidth = m.lnWidth + this.Grd.Columns(m.lnX).width
				If this.Grd.GridLines>1
					m.lnWidth = m.lnWidth + m.lnLineWidth 
				Endif
			Endif
		EndFor
		If this.Grd.DeleteMark 
			m.lnWidth = m.lnWidth + 10
		EndIf
		If this.Grd.RecordMark
			m.lnWidth = m.lnWidth + 8
		EndIf
		If this.Grd.ScrollBars>1
			m.lnWidth = m.lnWidth + Sysmetric(5) + 2*m.lnLineWidth 
		EndIf
		Return m.lnWidth + 2 	
	ENDPROC

	PROCEDURE getinputmask
		Lparameters taDummy, tnElement
		Local lcMask, lcMaster, lcType, lnDecimals, lnInteger, lnWidth
		lcType = m.taDummy(m.tnElement, 2)
		lcMask = []
		Do Case
		   Case m.lcType = [I] && Integer
		      lcMask = [99 999 999 999]
		   Case m.lcType = [Y] && Currency
		      lcMask = [999 999 999 999 999.999]
		   Case m.lcType = [N] && Numeric
		      lnWidth = m.taDummy(m.tnElement, 3)
		      lnDecimals = m.taDummy(m.tnElement, 4)
		      If m.lnDecimals > 0
		         lnInteger = m.lnWidth - m.lnDecimals - 1
		      Else
		         lnInteger = m.lnWidth
		      Endif
		      lcMaster = [999 999 999 999]
		      Do Case
		         Case m.lnInteger >= 10
		            lcMask = Right(m.lcMaster, m.lnInteger + 3)
		         Case m.lnInteger >= 7
		            lcMask = Right(m.lcMaster, m.lnInteger + 2)
		         Case m.lnInteger >= 4
		            lcMask = Right(m.lcMaster, m.lnInteger + 1)
		         Otherwise
		            lcMask = Right(m.lcMaster, m.lnInteger)
		      Endcase
		      If m.lnDecimals > 0
		         lcMask = m.lcMask + [.] + Replicate([9], m.lnDecimals)
		      Endif
		Endcase
		lcMask = chrtran(lcMask,' ,',Set("Separator")+Set("Point"))
		Return m.lcMask
		
	ENDPROC

	PROCEDURE getsortedstring		&& Sorts a string so that the longest words come first
		Parameters tcText
		Local laDummy[1], lcReturn, lnWord, lnX
		lnWord = Getwordcount(m.tcText )
		Dimension m.laDummy(m.lnWord, 2)
		For lnX = 1 To m.lnWord
		   laDummy(m.lnX, 1) = Getwordnum(m.tcText, m.lnX )
		   laDummy(m.lnX, 2) = Len(m.laDummy(m.lnX, 1))
		Endfor
		Asort(m.laDummy, 2, 0, 1)
		lcReturn = []
		For lnX = 1 To m.lnWord
		   lcReturn = m.lcReturn + [ ] + m.laDummy(m.lnX, 1)
		Endfor
		Return Alltrim(m.lcReturn )
	ENDPROC

	PROCEDURE hidecolumn
		Local laEvents[1], loHeader As Header
		Local lnWidth
		lnWidth = 15
		Aevents( laEvents, 0 )
		If laEvents(1).Baseclass = 'Header'
			loHeader = laEvents[ 1 ]
			If loHeader.Parent.Width = m.lnWidth
			   loHeader.Parent.AutoFit()
			   this.grd.LockColumns = 0
			Else
			   loHeader.Parent.Width = m.lnWidth
			EndIf
			This.Resize()
		Endif
		
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcParameter
		*A: Ask for table if none selected
		*C: Show checkboxes incseek and index
		*E: Exit with Enter
		*F: Activate Find on startup
		*I: Incremental seek
		*M: "nice" numbers
		*N: Hide Find option (same as f)
		*S: Incremental seek starts after x=number of S's characters
		*U: Autofit
		*W: ReadWrite
		*Z: Hide zero values
		*0: (numeric): Incremental seek starts at first character
		*1: Standard modal
		Push Key clear 
		If Pcount()= 0 and Vartype(_screen.lParameters) = 'L' and _screen.lParameters && For interactive testing
			If Empty(Alias())
				Use kundtest In Select('kundtest')
				Select kundtest
			Endif Empty(Alias())
			lnParCount = 1
			tcParameter = 'FI'
		Else 
			m.lnParCount = Pcount()
		EndIf
		ThisForm.SetDefaults()
		If m.lnParCount > 0
			this.lAskForTable = 'A'$Upper(m.tcParameter) 
			this.lCheckboxes = 'C'$Upper(m.tcParameter)
			this.lEnter  = 'E'$Upper(m.tcParameter)
			this.lFind = 'F'$Upper(m.tcParameter)
			this.lIncrementalSeek = 'I'$Upper(m.tcParameter)
			this.lNoFind = 'N'$Upper(m.tcParameter)
			this.lReadOnly = !'W'$Upper(m.tcParameter)
			this.lShowZero = !'Z'$Upper(m.tcParameter)
			this.nHideLast = Occurs('L',Upper(m.tcParameter))
			this.lInputMask = 'M'$Upper(m.tcParameter)
			this.lAutofit = 'U'$Upper(m.tcParameter)
			If '0'$m.tcParameter && Number
				this.nIncStart = 0
			EndIf
			If 'S'$Upper(m.tcParameter)
				this.nIncStart = Occurs('S',Upper(m.tcParameter))
			Endif
		Endif
		Do case 
			Case m.lnParCount = 0
			Case '1' $ m.tcParameter && Standard modal
				this.lIncrementalSeek = .T.
				this.lEnter = .T.
				this.lInputMask = .T.
				this.lAutofit = .T.
		*!*  	Case this.lNoFind   && Hide Find option
		*!*  		this.grd.Top = 0
		*!*  *!*			this.grd.Refresh()
		*!*  		this.txtFind.Visible = .F.
		*!*  		this.lblFind.Visible = .F.
			Case this.lFind && Activate Find 
		Endcase
		If this.lNoFind && and .f.   && Hide Find option
		*!*    Set Step On 
		*!*      this.grd.Refresh()
		    this.txtFind.Visible = .F.
		    this.lblFind.Visible = .F.
		    this.grd.Top = 1
		    On Key Label ESC Keyboard '{CTRL+F4}' plain 
		    On Key Label Enter Keyboard '{CTRL+F4}' plain 
		Endif
		
		If this.lEnter && Enter exits
			this.lIncrementalSeek = .T.
			this.chkInc.Visible = .F.
			this.chkUseIndex.Visible = .F.
			this.lFind = .T.
		Endif
			
		If _vfp.StartMode = 0 && Design mode
		Else
			this.Width = Sysmetric(1)/2
			this.Height = Sysmetric(2)/2
		Endif
		This.AutoCenter = .T.
		llSuccess = .T.
		If Empty(Alias())
			If this.lAskForTable 
				lcTable = GetFile('dbf')
				If Empty(m.lcTable)
					m.llSuccess = .F.
				Else 
					Select Select(JustStem(m.lcTable))
					Use (lcTable)
		*!*				Return .f. && TBFix 
				EndIf
			Else 
				m.llSuccess = .F.
			EndIf
			If !m.llSuccess 
				messagebox( 'No table is selected!',0+16)
				Return .F.
			Endif
		EndIf
		this.cRecordSource = Alias()
		Go top in (this.cRecordSource)
		this.grd.RecordSource = this.cRecordSource 
		If IsReadonly()
			this.lReadOnly = .T.
			this.Grd.DeleteMark = .F.
		Endif
		
		If this.lAutofit 
			this.Grd.AutoFit()
		Endif
		this.makeControls()
		this.getGridWidth()
		
		this.cNullDisplayOld = Set("Nulldisplay")
		*!*  On Key Label ESC Keyboard '{CTRL+F4}' plain
		this.cCursor = 'Cur_' + Sys(2015)
		this.Resize()
		this.AutoCenter = this.AutoCenter 
	ENDPROC

	PROCEDURE iscursor
		Return (justpath(dbf(alias())) = sys(2023)) and JustExt(Dbf(Alias())) = 'TMP'
	ENDPROC

	PROCEDURE istag
		Lparameters tcTagName, tcTable 
		*-- Passed the name of an index tag returns true if it is a tag for the specified table. Uses table in the current work area if no table name is passed.
		  LOCAL ARRAY laTags[1]
		  LOCAL llRetVal
		  *** Did we get a tag name?
		  IF TYPE( 'tcTagName' ) # 'C'
		    *** Error - must pass a Tag Name
		    ERROR '9000: Must Pass a Tag Name when calling ISTAG()'
		    RETURN .F.
		  ENDIF
		  *** How about a table alias?
		  IF TYPE( 'tcTable' ) = 'C' AND ! EMPTY( tcTable )
		      *** Get all open indexes for the specified table
		      ATagInfo( laTags, "", tcTable )
		  ELSE
		      *** Get all open indexes for the current table
		      ATagInfo( laTags, "" )
		  ENDIF
		
		  *** Do a Case Insensitive, Exact=ON, Scan of the first column of array
		  *** Return Whether the Tag is Found or not
		  RETURN ( ASCAN( laTags, tcTagName, -1, -1, 1, 7 ) > 0 )
	ENDPROC

	PROCEDURE lcenter_assign
		lparameters tlCenter
		If m.tlCenter 
			this.Left = (Sysmetric(1) - this.Width)/2
			this.Top = (Sysmetric(2) - this.Height)/2
		Endif
		This.lCenter = tlCenter
		
	ENDPROC

	PROCEDURE linputmask_assign
		lparameters tlInputMask
		This.lInputMask = tlInputMask
		this.setProperties()
		
	ENDPROC

	PROCEDURE Load
		thisform.setGridDefaults() 
		
		
	ENDPROC

	PROCEDURE lreadonly_assign
		lparameters tlReadOnly
		This.lReadOnly = tlReadOnly
		this.setProperties()
	ENDPROC

	PROCEDURE lshowzero_assign
		lparameters tlShowZero
		This.lShowZero = tlShowZero
		this.setProperties()
	ENDPROC

	PROCEDURE lzebra_assign
		lparameters tlZebra
		This.lZebra = tlZebra
		this.setProperties()
	ENDPROC

	PROCEDURE makecontrols
		Local laDummy[1], lnFields, lnX
		Local loCol As Column, loChk As Checkbox
		Local lcCol as column, lcField, lcName
		Local loControl as CheckBox 
		m.lnFields = Afields(laDummy)
		For m.lnX = 1 To m.lnFields
		  m.lcField = Field(m.lnX)
		  m.lcCol = Textmerge([thisform.Grd.Columns(<<m.lnX >>)])
		  If Inlist(Type(m.lcField), [L], [M])
		    m.loCol = Evaluate(m.lcCol)
		    Do Case
		      Case Type(m.lcField) = [L]
		        m.lcName = [chk]
		        m.loCol.AddObject(m.lcName, [CheckBox])
		        m.loControl = Evaluate(m.lcCol + [.] + m.lcName)
		        m.loControl.Caption = []
		        m.loCol.CurrentControl = m.lcName
		        m.loCol.Alignment = 2
		      Case Type(m.lcField) = [M] 
		        m.loCol.Alignment = 2
		        thisform.cback = Textmerge('iif(Empty(Evaluate("<<this.Grd.RecordSource>>.<<m.lcField>>")),<<thisform.nColMemoDisabledBackColor>>,<<thisform.nColMemoBackColor>>)')
		        m.loCol.DynamicBackColor = this.cback
						BindEvent(m.loCol.text1 ,"Click",thisform,"editMemo",1)  
		      Otherwise && Won't happen, just in case...
		    Endcase
		    m.loCol.Sparse = .F.
		  EndIf
		EndFor
		thisform.grd.ColumnCount = Max(thisform.grd.ColumnCount - thisform.nHideLast, 1)
		
	ENDPROC

	PROCEDURE makeinputmask
		Local laDummy[1], lcMask, lnFields, lnX
		lnFields = Afields(laDummy)
		For lnX = 1 To this.Grd.ColumnCount && m.lnFields
			   lcMask = This.Getinputmask(@m.laDummy, m.lnX)
			   If !Empty( m.lcMask )
			   	this.Grd.Columns(lnX).InputMask = m.lcMask
			   Endif
			Endfor
		
	ENDPROC

	PROCEDURE makezebra
		If this.lZebra and Empty(Set("Order"))
			lcText = Textmerge([IIF(Recno()%2 = 0, <<thisform.nZebraColor1>>, <<thisform.Nzebracolor2>> )]) 
		Else
			lcText = ''
		EndIf
		For lnX = 1 to thisform.Grd.ColumnCount 
			With this.Grd.Columns(lnX)
				If Empty(.DynamicBackColor)
					.DynamicBackColor = m.lcText 
				Endif
			Endwith
		Endfor
		
	ENDPROC

	PROCEDURE ngridwidth_access
		return this.getGridWidth()
		
	ENDPROC

	PROCEDURE nhighlightbackcolor_assign
		lparameters tnHighlightBackColor
		This.nHighlightBackColor = tnHighlightBackColor
		this.setProperties()
	ENDPROC

	PROCEDURE nhighlightforecolor_assign
		lparameters tnHighlightForeColor
		This.nHighlightForeColor = tnHighlightForeColor
		this.setProperties ()
	ENDPROC

	PROCEDURE nzebracolor1_assign
		lparameters tnZebraColor1
		This.nZebraColor1 = tnZebraColor1
		this.setProperties()
	ENDPROC

	PROCEDURE nzebracolor2_assign
		lparameters tnZebraColor2
		This.nZebraColor2 = tnZebraColor2
		this.setProperties()
	ENDPROC

	PROCEDURE Release
		Set Nulldisplay To this.cNullDisplayOld
		Select (this.cRecordSource)
		Set Filter To 
		On Key Label ESC 
		
	ENDPROC

	PROCEDURE Resize
		Local lnGridWidth
		lnGridWidth = This.nGridWidth
		
		If This.Width > lnGridWidth
		   This.Width = lnGridWidth
		Endif
		
		
	ENDPROC

	PROCEDURE resolvemouse
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		Do Case
		   Case nButton = 1 && LeftClick
				thisform.sortGrid()
		   Case nButton = 2 and nShift = 0 && RightClick
				thisform.hideColumn()
		   Case nButton = 2 and nShift = 1 &&RightClick + shift
		   Otherwise
		Endcase
	ENDPROC

	PROCEDURE setcaption
		If this.isCursor()
			this.Caption = Proper(Alias())
		Else
			This.Caption = Proper(Juststem(This.cRecordSource))
		EndIf
		this.cAlias = this.Caption 
	ENDPROC

	PROCEDURE setdefaults
		this.lAskForTable = .F.
		this.lNoFind = .F.
		this.lReadOnly = .F.
		this.lShowZero = .F.
		this.lFind = .F.
		this.lIncrementalSeek = .F.
		this.lEnter = .F.
		this.nHideLast = 0
		*Note thisform.Load calls setGridDefaults() 
	ENDPROC

	PROCEDURE setgriddefaults
		this.nHighlightBackColor = Rgb(210,210,210) 
		this.nHighlightForeColor = 0
		this.nColMemoBackColor = Rgb(127,255,127)
		this.nColMemoDisabledBackColor = Rgb(240,240,240)
		this.nHeaderSortableBackColor = Rgb(255,255,220)
		this.nHeaderSortedBackColor = Rgb(220,255,220) 
		this.nHeaderBackColor =  RGB(255,220,220) 
	ENDPROC

	PROCEDURE setproperties
		*!*	ThisForm.MakeZebra()
		If thisform.lShowNulls
			Set Nulldisplay To 
		Else
			Set Nulldisplay To thisform.cNullDisplay
		Endif
		If PemStatus(this,'grd',5) and PemStatus(this.Grd,'column1',5)
			* Vartype(this.grd) = 'O' and Lower(this.Grd.BaseClass) = 'grid'
			If PemStatus(this,'grd',5)
				If this.lShowZero 
					this.Grd.SetAll('format','','column')
				Else
					this.Grd.SetAll('format','Z','column')
				EndIf
				this.Grd.readOnly = Nvl(this.lReadOnly,.F.)
				this.Grd.DeleteMark = !this.lReadOnly and !IsReadonly()
				If this.lInputMask
					this.makeInputMask()
				Else 
					this.Grd.SetAll('InputMask','','column')	
				EndIf
				this.grd.HighlightBackColor = this.nHighlightBackColor 
				this.grd.HighlightForeColor = this.nHighlightForeColor 
			Endif
			ThisForm.MakeZebra()
		Endif
	ENDPROC

	PROCEDURE Show
		LPARAMETERS nStyle
		If thisform.lFind 
		*!*    this.txtFind.SetFocus()
		*!*  		Keyboard '{ALT+F}' plain
		EndIf
		
	ENDPROC

	PROCEDURE sortgrid
		Local laEvents[ 1 ], loHeader, lcField, loColumn, lcSortOrder, loControl as Header 
		Local llFoundColumn, llAllowCellSelection, lnRecNo
		Local lcTable
		
		*** First of all, see which column fired off this event
		Aevents( laEvents, 0 )
		loHeader = laEvents[ 1 ]
		If Vartype( loHeader ) = [O]
		   *** First See if a ControlsSource was set for the column
		   With loHeader.Parent
		      lcField = []
		      If Not Empty( .ControlSource )
		         *** Cool. Use it to decide how to sort the grid
		         If Not Empty( .ControlSource ) And ( [.] $ .ControlSource ) And Not( [(] $ .ControlSource )
		            lcField = Justext( .ControlSource )
		         Endif
		      Endif
		   Endwith
		   *** we have a field - let's see if it already has a sort order set
		   *** if it does, it will have the appropriate picture in the header
		   lcSortOrder = []
		   If Not Empty( loHeader.Picture )
		      lcSortOrder = Iif( Lower( Justfname( loHeader.Picture ) ) == [up.bmp], [], [DESC] )
		   Else
		      *** See if there is a visual cue on any of the other grid
		      *** column headers and remove it if there is
		      For Each loColumn In This.Grd.Columns
		         For Each loControl In loColumn.Controls
		            If Lower( loControl.BaseClass ) == [header]
		               If Not Empty( loControl.Picture )
		                  llFoundColumn = .T.
		                  loControl.Picture = []
		                  loControl.FontBold = .F.
		                  If loControl.BackColor = this.nHeaderSortedBackColor 
		                  	loControl.BackColor = this.nHeaderSortableBackColor 
		                  Endif
		               Endif
		            Endif
		         Endfor
		         If llFoundColumn
		            Exit
		         Endif
		      Endfor
		   Endif
		
		   *** if we have a field - let's sort
		   If Not Empty( lcField )
		      *** There seems to be a refresh issue here
		      *** because even though the data is in the cursor
		      *** it is not showing up in the grid after the sort
		      *** and it looks like it is related to AllowCellSelection being .F.
		      llAllowCellSelection = This.Grd.AllowCellSelection
		      This.Grd.AllowCellSelection = .F.
		      This.Grd.Refresh()
		      Keyboard [{CTRL+TAB}]
		
		      *** Check to see if the tag exists assume
		      *** that if there is a tag on this field, it has the same name as the field
		      lcTable = Juststem(This.Grd.RecordSource)
		      If This.IsTag( lcField, m.lcTable  )
		         lnRecNo = Recno( m.lcTable )
		         *** Go ahead and set the order for the table
		         Select ( lcTable)
		         If Empty(m.lcSortOrder) 
			         Set Order To ( lcField ) 
			      Else
			         Set Order To ( lcField ) DESCENDING 
		         Endif
		*!*	         This.Grd.SetFocus()
		         If lnRecNo # 0
		            Go lnRecNo In ( lcTable )
		         Endif
		         *** And set the visual cues on the header
		         loHeader.Picture = Iif( !Empty( lcSortOrder ), [..\images\up.bmp], [..\images\down.bmp] )
		         loHeader.FontBold = .T.
		         loHeader.BackColor = this.nHeaderSortedBackColor 
		         This.Grd.AllowCellSelection = llAllowCellSelection
		*!*	         Endif
				Else
					Set Order to 
		      EndIf
		   Endif
		Endif 
		*!*	If this.lAutofit
		*!*		this.grd.AutoFit()
		*!*	Endif
		this.makeZebra()
		this.Grd.Refresh()
		If this.lSetFocusToFind
		  thisform.txtFind.SetFocus()
		  Keyboard '{BACKSPACE}' plain
		Endif
		
	ENDPROC

	PROCEDURE Unload
		If this.WindowType = 1 and !Empty(thisform.cRecordSource)
			Return Recno(Alias())
		Endif
		On Key Label ESC 
	ENDPROC

	PROCEDURE visible_assign
		lparameters tVisible
		This.Visible = tVisible
		this.Grd.SetFocus()
	ENDPROC

	PROCEDURE chkInc.InteractiveChange
		this.Parent.txtFind.SetFocus()
	ENDPROC

	PROCEDURE chkInc.LostFocus
		this.Parent.txtFind.Refresh()
	ENDPROC

	PROCEDURE chkInc.Refresh
		this.Visible = thisform.lCheckboxes
	ENDPROC

	PROCEDURE chkUseIndex.InteractiveChange
		this.Parent.txtFind.SetFocus()
	ENDPROC

	PROCEDURE chkUseIndex.Refresh
		this.Visible = thisform.lCheckboxes 
	ENDPROC

	PROCEDURE grd.Init
		With this.Parent 
		*!*		this.Top = 0
			this.Left = 0
			this.Width = .Width
			this.Height = .Height - 45
		EndWith
		*!*	ThisForm.setGridDefaults()
		For lnX = 1 to this.ColumnCount
			If thisform.isTag(Justext(this.Columns(lnX).controlsource), thisform.cAlias )
				this.Columns(lnX).header1.backcolor = thisform.nHeaderSortableBackColor 
			Else
				this.Columns(lnX).header1.backcolor = thisform.nHeaderBackColor
			Endif
			BindEvent(this.Columns(lnX).header1,'mousedown',thisform,'resolveMouse')	
		EndFor
		this.Refresh()
		
	ENDPROC

	PROCEDURE grd.Refresh
		if thisform.lNoFind 
			this.Top = 0
			this.Height = thisform.Height 
		Else
			this.Top = 45
		endif		
	ENDPROC

	PROCEDURE grd.Resize
		if thisform.lNoFind 
			this.Top = 0
			this.Height = thisform.Height 
		Else
			this.Top = 45
		endif		
		*!*	If thisform.lMax 
		*!*		lnDiff = 0
		*!*	Else
		*!*		lnDiff = 45
		*!*	Endif
		*!*	this.Height = thisform.Height - m.lnDiff 
		
	ENDPROC

	PROCEDURE lblFind.Refresh
		this.Enabled = !thisform.lMax 
	ENDPROC

	PROCEDURE txtFind.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		lnSelstart = this.SelStart 
		llGrid = .F.
		NoDefault 
		Do case
			Case m.nKeyCode = 5 and m.nShiftAltCtrl = 0 && Up
				Try 
					Skip -1
			catch
		
				Endtry
				m.llGrid = .T.
			Case m.nKeyCode = 24 and m.nShiftAltCtrl = 0 && Down
				Try 
				  Skip 1
				catch
				EndTry
		
				m.llGrid = .T.
			Case m.nKeyCode = 18 and m.nShiftAltCtrl = 0 && PgUp
				try
					Skip -50
				Catch
					Go top
				Endtry
				m.llGrid = .T.
			Case m.nKeyCode = 3 and m.nShiftAltCtrl = 0 && PgDn
				try
					Skip 50
				Catch
					Go bott
				Endtry
				m.llGrid = .T.
			Case m.nKeyCode = 29 and m.nShiftAltCtrl = 2 && CtrlHome
				Go top
				m.llGrid = .T.
			Case m.nKeyCode = 23 and m.nShiftAltCtrl = 2 && CtrlEnd
				Go bott
				m.llGrid = .T.
		*!*    Case m.nKeyCode = 127 && Backspace
		*!*      DoDefault(m.nKeyCode,m.nShiftAltCtrl)
		*!*      thisform.doFilterGrid(this.Value)
			Case m.nKeyCode = 13 and m.nShiftAltCtrl = 0 && Enter
				If thisform.lEnter 
					thisform.Release
				else
					thisform.lIncInProcess = .F.
					thisform.doFilterGrid(this.Value)
		*!*				thisform.Grd.SetFocus()
				this.SetFocus()
				Endif
			Case Chr(m.nKeyCode)='*' and m.nShiftAltCtrl = 1
				thisform.lIncrementalSeek = !thisform.lIncrementalSeek 
				thisform.chkInc.Refresh() 
				this.Refresh()
		  Case m.nKeyCode = 27 && Escape
		    thisform.Release()
			Case Chr(m.nKeyCode)='!'
				thisform.chkUseIndex.Value = !thisform.chkUseIndex.Value 
			Case thisform.lIncrementalSeek
				DoDefault(m.nKeyCode, m.nShiftAltCtrl ) 
					lnSelstart = this.SelStart 
				If Len(Trim(this.Value))>thisform.nIncStart
					thisform.lIncInProcess = .T.
				EndIf
				If thisform.lIncInProcess 
					thisform.doFilterGrid(this.value)
				Endif
					this.SelStart = m.lnSelstart 
				this.SetFocus()
			Otherwise 
				DoDefault(m.nKeyCode, m.nShiftAltCtrl)
		Endcase
		
		If m.llGrid 
			thisform.Grd.Refresh()
			this.SetFocus()
		Endif
		
	ENDPROC

	PROCEDURE txtFind.Refresh
		this.Enabled = !thisform.lMax 
		If thisform.lIncrementalSeek 
			this.BackColor = RGB(255,255,128)
		Else
			this.BackColor = RGB(255,255,255)
		Endif thisform.lIncrementalSeek
		
	ENDPROC

ENDDEFINE

DEFINE CLASS sidekick AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblSidekick" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: addextension
		*m: addlinesandtext
		*m: addoption
		*m: arrayscan
		*m: browsealltools
		*m: browsehotkeys
		*m: changesidekickfile
		*m: checkorcreatesidekickfile
		*m: closeopenedtables
		*m: createbindevent
		*m: createcommentline
		*m: createes
		*m: createno
		*m: createqmark
		*m: createsidekickcursor
		*m: createusesyntax
		*m: cutandgivemessage
		*m: cutcurrentline
		*m: decodetimestamp
		*m: dir2dt
		*m: dobrow
		*m: dounzip
		*m: dozip
		*m: dropfieldifempty
		*m: editcustomtool
		*m: findcommand
		*m: finddiroptions
		*m: findedoptions
		*m: findfile
		*m: findfunction
		*m: findparameters
		*m: findskoptions
		*m: findswitch
		*m: findvalueinstring
		*m: fixpath
		*m: getadditionalfiles
		*m: getallfiles
		*m: getdatafromgrid
		*m: getdatafromurl
		*m: getdescript
		*m: geteditsourcecode
		*m: getextensioncursor
		*m: getfieldcount
		*m: getfilelisttoprocess		&& Pass a comma delimited file list, return list with corresponding files added. Pass .T: to include secondary files (.bak, .err e.t.c.)
		*m: getfilesinpath
		*m: getheader
		*m: gethelptopics
		*m: getlastcharacter
		*m: getlastfile
		*m: getlastword
		*m: getlineno
		*m: getlinestoprocess
		*m: getmemosize
		*m: getmethdfromprg
		*m: getnextfile
		*m: getnextproject
		*m: getnumberedline
		*m: getrandomtext
		*m: getrecordsindbf
		*m: getsidekickfile
		*m: getsortabledate		&& Returns YYMMDD format from date
		*m: getthorfiles
		*m: givemessage
		*m: handledescription
		*m: handlemrutable
		*m: highlightcurrentline
		*m: insertmethod
		*m: insertresult
		*m: listallcustomtools
		*m: listdescript
		*m: listfiles
		*m: listopentables
		*m: listprojects
		*m: listusedtables
		*m: makedodefault
		*m: makefieldpicker
		*m: makeloremtext
		*m: makerandowtext
		*m: makesktestarea
		*m: makestringfromarray
		*m: modifyform
		*m: notes
		*m: oeditorwininit
		*m: ozipinit
		*m: processsidekickfile
		*m: readclasslibs
		*m: readregistryoption
		*m: readsettings
		*m: removedoublecharacter
		*m: removeprocendproc
		*m: replacecurrentline
		*m: restoreselection
		*m: returnunknowncommand
		*m: runed
		*m: runprogram
		*m: runsidekickline
		*m: scanallwindows
		*m: setstepon
		*m: setupgrid
		*m: setupregistry
		*m: shellx
		*m: showcase
		*m: showcurrentpath
		*m: tryexecscript
		*m: tryexecute
		*m: writecurrentline
		*p: cbackupfolder		&& Name of folder for "deleted" files
		*p: cclip
		*p: ccommand
		*p: ccommandoriginal
		*p: ccommentstring
		*p: ccursor
		*p: cdefaultcommand
		*p: cdescriptionmask1
		*p: cdescriptionmask2
		*p: cdisplaycase
		*p: cerrormessage
		*p: cexact
		*p: cextensionlist
		*p: cfilter
		*p: clowercommand
		*p: clowerparameter
		*p: cmrutable
		*p: coption
		*p: cparameter
		*p: cparameteroriginal
		*p: cparcedtext
		*p: cpathreturned
		*p: cpoint
		*p: cprogram
		*p: crun
		*p: csearchtext
		*p: csidekickdef
		*p: csidekickfile
		*p: csidekickhelp
		*p: cskfile		&& Prefix for Sidekick extensions
		*p: ctableselected
		*p: ctabletokeepopen		&& Table NOT to close on exit
		*p: ctitle
		*p: cunzipfolder		&& Default folder to unzip into
		*p: cversion
		*p: cziptarget		&& Default name for zip target, if none is specified
		*p: laddextraextensions
		*p: lcomment
		*p: lnobrowse
		*p: lnointerface
		*p: lnomessage		&& If true, no message is given if Esc is pressed from grid
		*p: lnoselectonexit
		*p: lskcomment		&& True for commented lines, so that the line is not deleted
		*p: lthorfolders
		*p: ltidy		&& Try for moving selected files to backup folder
		*p: nfilesize
		*p: nfontsize
		*p: nhandle
		*p: nlineno
		*p: nmaxdescriptline
		*p: nnextlength		&& Length of numeric extension for automatically incremented file names, like panzip_00001 where value is 5
		*p: nselect
		*p: nselend
		*p: nselstart
		*p: ntimeout		&& Timeout in milliseconds, used for messageboxes
		*p: nvalcommand
		*p: nwindowtype
		*p: nzipdelay		&& Delay necessary so that oZip has time to create file
		*p: oeditor
		*p: oeditorwin
		*p: oeditorwin_def
		*p: oeditor_def
		*p: ogrid
		*p: oregistry
		*p: ozip
		*a: ainuse[1,0]
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	*<PropValue>
		cbackupfolder = BU?
		cclip = 
		ccommand = 
		ccommandoriginal = 
		ccommentstring = 
		ccursor = curSKTemp
		cdefaultcommand = 
		cdescriptionmask1 = * Description:
		cdescriptionmask2 = *
		cdisplaycase = Lower                                                          
		cerrormessage = 
		cexact = 
		cextensionlist = 
		cfilter = 
		clowercommand = 
		clowerparameter = 
		cmrutable = 
		coption = 
		cparameter = 
		cparameteroriginal = 
		cparcedtext = 
		cpathreturned = 
		cpoint = .                                                              
		cprogram = Sidekick
		crun = 
		csearchtext = 
		csidekickdef = 
		csidekickfile = 
		csidekickhelp = 
		cskfile = sk_                                                            
		ctableselected = 
		ctabletokeepopen = 
		ctitle = 
		cunzipfolder = PanUnzip                                                       
		cversion = 
		cziptarget = Panzip_                                                        
		Height = 406
		laddextraextensions = .F.
		lcomment = .F.
		lnobrowse = .F.
		lnointerface = .F.
		lnomessage = .F.
		lnoselectonexit = .F.
		lskcomment = .F.
		lthorfolders = .F.
		ltidy = .F.
		Name = "sidekick"
		nfilesize = 0
		nfontsize = 10
		nhandle = 0
		nlineno = 0
		nmaxdescriptline = 15
		nnextlength = 4
		nselect = 0
		nselend = 0
		nselstart = 0
		ntimeout = 3000
		nvalcommand = 0
		nwindowtype = 0
		nzipdelay =          0.1
		oeditor = .NULL.
		oeditorwin = .NULL.
		oeditorwin_def = execscript (_Screen.cThorDispatcher, 'class= editorwin from pemeditor')
		oeditor_def = Execscript(_Screen.cThorDispatcher, [class= HighlightedText from Thor_Proc_HighlightedText.PRG])
		ogrid = 
		oregistry = 
		ozip = 
		Width = 675
		_memberdata = <VFPData>
			<memberdata name="oeditorwin_def" display="oEditorWin_Def"/>
			<memberdata name="oeditor_def" display="oEditor_Def"/>
			<memberdata name="findvalueinstring" display="FindValueInString"/>
			<memberdata name="findfunction" display="FindFunction"/>
			<memberdata name="findparameters" display="FindParameters"/>
			<memberdata name="findfile" display="FindFile"/>
			<memberdata name="findcommand" display="FindCommand"/>
			<memberdata name="ogrid" display="oGrid"/>
			<memberdata name="setupgrid" display="SetupGrid"/>
			<memberdata name="setupregistry" display="SetupRegistry"/>
			<memberdata name="restoreselection" display="RestoreSelection"/>
			<memberdata name="getdatafromgrid" display="GetDataFromGrid"/>
			<memberdata name="shellx" display="ShellX"/>
			<memberdata name="addlinesandtext" display="AddLinesAndText"/>
			<memberdata name="createcommentline" display="CreateCommentLine"/>
			<memberdata name="createes" display="CreateES"/>
			<memberdata name="createno" display="CreateNO"/>
			<memberdata name="createqmark" display="CreateQmark"/>
			<memberdata name="cutcurrentline" display="CutCurrentLine"/>
			<memberdata name="editcustomtool" display="EditCustomTool"/>
			<memberdata name="getallfiles" display="GetAllFiles"/>
			<memberdata name="getdatafromurl" display="GetDataFromURL"/>
			<memberdata name="getdescript" display="GetDescript"/>
			<memberdata name="geteditsourcecode" display="GetEditSourceCode"/>
			<memberdata name="getfilesinpath" display="GetFilesInPath"/>
			<memberdata name="getheader" display="GetHeader"/>
			<memberdata name="getlastword" display="GetLastWord"/>
			<memberdata name="getlineno" display="GetLineNo"/>
			<memberdata name="getlinestoprocess" display="GetLinesToProcess"/>
			<memberdata name="getmemosize" display="GetMemoSize"/>
			<memberdata name="getnextproject" display="GetNextProject"/>
			<memberdata name="getnumberedline" display="GetNumberedLine"/>
			<memberdata name="getrandomtext" display="GetRandomText"/>
			<memberdata name="getrecordsindbf" display="GetRecordsInDBF"/>
			<memberdata name="getthorfiles" display="GetThorFiles"/>
			<memberdata name="highlightcurrentline" display="HighlightCurrentLine"/>
			<memberdata name="insertmethod" display="InsertMethod"/>
			<memberdata name="insertresult" display="InsertResult"/>
			<memberdata name="listdescript" display="ListDescript"/>
			<memberdata name="listfiles" display="ListFiles"/>
			<memberdata name="listprojects" display="ListProjects"/>
			<memberdata name="getmethdfromprg" display="GetMethdFromPrg"/>
			<memberdata name="readclasslibs" display="ReadClassLibs"/>
			<memberdata name="removeprocendproc" display="RemoveProcEndproc"/>
			<memberdata name="replacecurrentline" display="ReplaceCurrentLine"/>
			<memberdata name="returnunknowncommand" display="ReturnUnknownCommand"/>
			<memberdata name="runed" display="RunEd"/>
			<memberdata name="runprogram" display="RunProgram"/>
			<memberdata name="scanallwindows" display="ScanAllWindows"/>
			<memberdata name="showcase" display="ShowCase"/>
			<memberdata name="tryexecute" display="TryExecute"/>
			<memberdata name="writecurrentline" display="WriteCurrentLine"/>
			<memberdata name="browsealltools" display="BrowseAllTools"/>
			<memberdata name="browsehotkeys" display="BrowseHotKeys"/>
			<memberdata name="tryexecscript" display="TryExecScript"/>
			<memberdata name="handledescription" display="HandleDescription"/>
			<memberdata name="cdescriptionmask1" display="cDescriptionMask1"/>
			<memberdata name="cdescriptionmask2" display="cDescriptionMask2"/>
			<memberdata name="createbindevent" display="CreateBindEvent"/>
			<memberdata name="makeloremtext" display="MakeLoremText"/>
			<memberdata name="makerandowtext" display="MakeRandowText"/>
			<memberdata name="coption" display="cOption"/>
			<memberdata name="finddiroptions" display="FindDirOptions"/>
			<memberdata name="makedodefault" display="MakeDoDefault"/>
			<memberdata name="makefieldpicker" display="MakeFieldPicker"/>
			<memberdata name="removedoublecharacter" display="RemoveDoubleCharacter"/>
			<memberdata name="cfilter" display="cFilter" favorites="True"/>
			<memberdata name="dozip" display="DoZip"/>
			<memberdata name="gethelptopics" display="GetHelpTopics"/>
			<memberdata name="getlastfile" display="GetLastFile"/>
			<memberdata name="getnextfile" display="GetNextFile"/>
			<memberdata name="getadditionalfiles" display="GetAdditionalFiles"/>
			<memberdata name="ozipinit" display="oZipInit"/>
			<memberdata name="getfilelisttoprocess" display="GetFilelistToProcess"/>
			<memberdata name="getextensioncursor" display="GetExtensionCursor"/>
			<memberdata name="dir2dt" display="Dir2dt"/>
			<memberdata name="getlastcharacter" display="GetLastCharacter"/>
			<memberdata name="oeditorwininit" display="oEditorWinInit"/>
			<memberdata name="addextension" display="AddExtension"/>
			<memberdata name="makestringfromarray" display="MakeStringFromArray"/>
			<memberdata name="givemessage" display="GiveMessage"/>
			<memberdata name="getsortabledate" display="GetSortableDate"/>
			<memberdata name="dounzip" display="DoUnzip"/>
			<memberdata name="readregistryoption" display="ReadRegistryOption"/>
			<memberdata name="cutandgivemessage" display="CutAndGiveMessage"/>
			<memberdata name="readsettings" display="ReadSettings"/>
			<memberdata name="changesidekickfile" display="ChangeSidekickFile"/>
			<memberdata name="createsidekickcursor" display="CreateSidekickCursor"/>
			<memberdata name="checkorcreatesidekickfile" display="CheckOrCreateSidekickFile"/>
			<memberdata name="findskoptions" display="FindSKOptions"/>
			<memberdata name="getsidekickfile" display="GetSidekickFile"/>
			<memberdata name="makesktestarea" display="MakeSKTestArea"/>
			<memberdata name="processsidekickfile" display="ProcessSidekickFile"/>
			<memberdata name="runsidekickline" display="RunSidekickLine"/>
			<memberdata name="findswitch" display="FindSwitch"/>
			<memberdata name="notes" display="Notes"/>
			<memberdata name="addoption" display="AddOption"/>
			<memberdata name="setstepon" display="SetStepOn"/>
			<memberdata name="modifyform" display="ModifyForm"/>
			<memberdata name="listusedtables" display="ListUsedTables"/>
			<memberdata name="listallcustomtools" display="ListAllCustomTools"/>
			<memberdata name="dropfieldifempty" display="DropFieldIfEmpty"/>
			<memberdata name="decodetimestamp" display="DecodeTimeStamp"/>
			<memberdata name="closeopenedtables" display="CloseOpenedTables"/>
			<memberdata name="arrayscan" display="ArrayScan"/>
			<memberdata name="cmrutable" display="cMRUTable"/>
			<memberdata name="findedoptions" display="FindEdOptions"/>
			<memberdata name="handlemrutable" display="HandleMRUTable"/>
			<memberdata name="dobrow" display="DoBrow"/>
			<memberdata name="cdefaultcommand" display="cDefaultCommand"/>
			<memberdata name="showcurrentpath" display="ShowCurrentPath"/>
			<memberdata name="fixpath" display="FixPath"/>
			<memberdata name="listopentables" display="ListOpenTables"/>
			<memberdata name="lnomessage" display="lNoMessage"/>
			<memberdata name="cskfile" display="cSKFile"/>
			<memberdata name="ctabletokeepopen" display="cTableToKeepOpen"/>
			<memberdata name="getfieldcount" display="GetFieldCount"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'lblSidekick' AS label WITH ;
		Caption = "Sidekick", ;
		FontSize = 12, ;
		ForeColor = 255,0,0, ;
		Height = 37, ;
		Left = 12, ;
		Name = "lblSidekick", ;
		Top = 12, ;
		Width = 169
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE addextension
		Lparameters tcString, tcItem, tcSource
		
		Local lcNewFile, lcString
		lcString = m.tcString
		lcNewFile = Forceext(m.tcSource, m.tcItem)
		Do Case
		  Case m.tcItem + [,] $ m.tcString
		  Case [,] + m.tcItem $ m.tcString
		  Case !File(m.lcNewFile)
		  Case Empty(m.tcString)
		    lcString = m.tcItem
		  Otherwise
		    lcString = Rtrim(m.tcString, 0, [,]) + [,] + m.tcItem
		Endcase
		Return m.lcString
	ENDPROC

	PROCEDURE addlinesandtext
		Local lnMemo
		
		lnMemo = Set([Memowidth])
		Set Memowidth To 8192
		Scan For Inlist(Lower(Justext(Filename)), [prg], [txt], [h], [sk])
		  Try
		    Replace Text With Filetostr(Alltrim(FullName))
		    Replace LineS With Memlines(Text)
		  Catch
		  Endtry
		Endscan
		Set Memowidth To m.lnMemo
		Index On LineS Tag LineS
		
		
	ENDPROC

	PROCEDURE addoption
		Lparameters tcCharacter
		m.tcCharacter = Evl(m.tcCharacter,'')
		Do case 
		  Case Left(m.tcCharacter,1) == '-' and Len(m.tcCharacter)=2
		    m.tcCharacter = Substr(m.tcCharacter,2)
		    this.cOption = Chrtran(this.cOption,m.tcCharacter,'')
		  Case !m.tcCharacter $ this.cOption 
		    this.cOption = this.cOption + m.tcCharacter
		Endcase
		
	ENDPROC

	PROCEDURE arrayscan
		lparameters taArray, ;
		 tuValue, ;
		 tnColumn, ;
		 tlNotExact, ;
		 tlCase
		external array taArray
		local lnColumn, ;
		 lnFlags, ;
		 lnRows, ;
		 lnColumns, ;
		 lnRow
		#define cnCASE_SENS 0
		#define cnCASE_INSENS 1
		#define cnEXACT_OFF 4
		#define cnEXACT_ON 6
		#define cnRETURN_ROW 8
		lnColumn = iif(vartype(tnColumn) = 'N', tnColumn, 1)
		lnFlags = iif(tlNotExact, cnEXACT_OFF, cnEXACT_ON) + ;
		 iif(tlCase, cnCASE_SENS, cnCASE_INSENS) + cnRETURN_ROW
		lnRows = alen(taArray, 1)
		lnColumns = alen(taArray, 2)
		lnRow = ascan(taArray, tuValue, -1, -1, lnColumn, lnFlags)
		*** WORKAROUND FOR BUG IN VFP: with return row flag set, return value is 1 too
		*** high if the search column is the last one
		if lnRow > 0 and lnColumn > 1 and lnColumn = lnColumns and (lnRow > lnRows or ;
		 taArray[lnRow, lnColumn] <> tuValue)
		 lnRow = lnRow - 1
		endif lnRow > 0 ...
		return lnRow
	ENDPROC

	PROCEDURE browsealltools
		#Define ccTool         'Browse all Thor Tools'
		Local lcDesc, lcDestAlias, lcHotkey, lcProg, llExcludeNotUsed, lnSelect
		
		Local Array laDummy[1]
		
		llExcludeNotUsed = Execscript(_Screen.cThorDispatcher, [Get Option=], ccTool, ccTool)
		lcDestAlias = [curHotKeys]
		Select 0
		Wait Window 'Wait while Sidekick processes files!' at 10,25 nowait noclear
		Execscript(_Screen.cThorDispatcher, [Thor_Proc_GetHotKeyDefs], m.lcDestAlias, m.llExcludeNotUsed )
		Select Distinct Cast(Ltrim(Descript) As c(100)) As Descript, Chrtran(HotKey, [-], [+]) As HotKey, Cast([] As c(10)) As sortkey, PRGName, StatusBar From (m.lcDestAlias);
		  Into Cursor (m.lcDestAlias ) Where Left(Descript, 1) # [ ] And Substr(Descript, 3, 1) # [-];
		  Readwrite
		Scan
		  lcHotkey = HotKey
		  Select Recno() From (_Screen.Cthorfolder + [\source\hotkeys])  Hotkeys Where Hotkeys.Key = Substr(m.lcHotkey, 1 + Rat([+], m.lcHotkey ), 10) Into Array laDummy
		  If _Tally > 0
		    Replace sortkey With Padl(m.laDummy, 2, [ ]) + m.lcHotkey
		  Endif
		Endscan
		Select HotKey, Descript, PRGName From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Readwrite
		lcDesc = []
		lcHotkey = []
		Scan
		  If Lower(Descript) == m.lcDesc And Lower(HotKey) = m.lcHotkey
		    Delete
		  Endif
		  lcDesc = Lower(Descript)
		  lcHotkey = Lower(HotKey)
		EndScan
		If !Empty(this.cparameter)
		  For lnX = 1 to GetWordCount(this.cparameter)
		    lcWord = GetWordNum(this.cparameter, m.lnX)
		    Select * From (m.lcDestAlias ) Into Cursor (m.lcDestAlias ) Readwrite where m.lcWord  $ Lower( descript + '|' + prgname)
		  Endfor
		Endif
		Select * From (m.lcDestAlias ) Into Cursor (m.lcDestAlias ) Readwrite order by descript Where !Deleted()
		Index On HotKey Tag HotKey
		Index On Upper(Descript) Tag Descript
		Set Order To 
		Go top
		Wait clear
		lcProg = this.GetDataFromGrid([Thor tools], [prgname], 1)
		Use
		If !Empty(m.lcProg)
		  Execscript(_Screen.cThorDispatcher, m.lcProg)
		Endif
		
		
	ENDPROC

	PROCEDURE browsehotkeys
		#Define ccTool         'Browse all Thor Tools'
		Local lcDestAlias, lcHotkey, lcProg, llExcludeNotUsed, lnSelect
		
		Local Array laDummy[1]
		
		llExcludeNotUsed = Execscript(_Screen.cThorDispatcher, [Get Option=], ccTool, ccTool)
		lcDestAlias = [curHotKeys]
		Select 0
		Execscript(_Screen.cThorDispatcher, [Thor_Proc_GetHotKeyDefs], m.lcDestAlias, m.llExcludeNotUsed )
		Select Distinct Cast(Descript As c(100)) As Descript, Chrtran(HotKey, [-], [+]) As HotKey, Cast([] As c(10)) As sortkey, PRGName, StatusBar From (m.lcDestAlias);
		  Where !Empty(HotKey ) And Substr(Descript, 3, 1) # [-] Into Cursor (m.lcDestAlias ) ;
		  Readwrite
		Scan
		  lcHotkey = HotKey
		  Select Recno() From (_Screen.Cthorfolder + [\source\hotkeys])  Hotkeys Where Hotkeys.Key = Substr(m.lcHotkey, 1 + Rat([+], m.lcHotkey ), 10) Into Array laDummy
		  Replace sortkey With Padl(m.laDummy, 2, [ ]) + m.lcHotkey
		Endscan
		Select Distinct HotKey, Descript, PRGName, sortkey From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Order By sortkey Readwrite
		Select HotKey, Descript, PRGName From (m.lcDestAlias) Into Cursor (m.lcDestAlias) Readwrite
		Index On Lower(HotKey) Tag HotKey
		Index On Lower(Descript) Tag Descript
		Set Order To
		lcProg = this.GetDataFromGrid([Thor tools], [prgname], 1)
		Use
		If !Empty(m.lcProg)
		  Execscript(_Screen.cThorDispatcher, m.lcProg)
		Endif
		If !this.lSKComment 
		  this.CutCurrentLine()
		Endif
		
		
	ENDPROC

	PROCEDURE changesidekickfile
		Local lcContent, lcCurrent, lcDescript, lcFile, lcFilename, lcParameter, lcText, lnFiles, lnLines
		Local lnX
		
		Local Array laDummy[1]
		Local Array laFiles[1]
		lcFile =  This.cSidekickFile
		lcParameter = Substr(This.cCommand, 2)
		lcParameter = Evl(m.lcParameter, This.cParameter)
		If Inlist(m.lcParameter, [*], [-], [+], [/] )
		  lnFiles = Adir(laFiles, [*.sk])
		  Do Case
		    Case m.lnFiles = 0
		      lcFile = [sidekick.sk]
		    Case m.lnFiles = 1
		      lcFile = m.laFiles(1, 1)
		    Otherwise
		      Select 0
		      Create Cursor curSKFiles (Current c(6), Filename c(25), Date T, Size i, LineS i, Descript c(50), Content m)
		      For lnX = 1 To m.lnFiles
		        lcFilename = Trim(Lower(m.laFiles(m.lnX, 1)))
		        If m.lcFilename == Lower(This.cSidekickFile)
		          lcCurrent = [Now ->]
		        Else
		          lcCurrent = []
		        Endif
		        lcContent = Filetostr(m.laFiles(m.lnX, 1))
		        lnLines = Alines(laDummy, m.lcContent)
		        lcDescript = This.GetDescript(m.laFiles(m.lnX, 1))
		        Insert Into curSKFiles (Current, Filename, Date, Size, LineS, Descript, Content) ;
		          Values (m.lcCurrent, Lower(m.laFiles(m.lnX, 1)), dir2dt(m.laFiles(m.lnX, 4), m.laFiles(m.lnX, 3)), m.laFiles(m.lnX, 2), m.lnLines, m.lcDescript, m.lcContent )
		      Endfor
		      Index On Filename Tag Filename
		      Index On Date Tag Date
		      Set Order To Date Descending
		      lcFile = This.GetDataFromGrid(Textmerge([New <<this.cProgram>> file (current is <<this.cSidekickFile >>):]), [Filename])
		  Endcase
		Else
		  If !Empty(This.cParameter)
		    lcFile = Forceext(This.cParameter, [sk])
		  Endif
		  If !File(m.lcFile)
		    If This.GiveMessage([Specified file "] + m.lcFile + [" doesn't exist, create empty file?], 4, [File not found!]) = 6
		      Text To m.lcText Noshow Textmerge Pretext 7
		          Default project: 0
		          *************************
		      Endtext
		      Strtofile(m.lcText, m.lcFile )
		      Modify Command (m.lcFile) Nowait
		    Else
		      lcFile = []
		    Endif
		  Endif
		Endif
		If !Empty(m.lcFile)
		  This.cSidekickFile = m.lcFile
		  ExecScript(_Screen.cThorDispatcher, "Set Option=", 'SidekickFile', 'SideKick', m.lcFile  )
		*!*    Strtofile(This.cSidekickFile, This.cSidekickDef )
		Endif
		This.CutAndGiveMessage(Textmerge([Active "<<this.cProgram>>" file is <<This.cSidekickFile>>]), 64, This.cProgram, this.nTimeOut )
		
		
	ENDPROC

	PROCEDURE checkorcreatesidekickfile
		Local lcText
		If File(this.cSidekickFile )
		  Return .T.
		Else
		  If this.GiveMessage(Textmerge([Specified file "<<this.cSidekickFile>>" doesn't exist, create empty file?]), 4, [File not found!]) = 6
		    Text To m.lcText Noshow Textmerge Pretext 7
		        Default project: 0
		        *************************
		    Endtext
		    Strtofile(m.lcText, this.cSidekickFile )
		    Modify Command (this.cSidekickFile ) Nowait
		  Endif
		  Return .F.
		Endif
		
		
	ENDPROC

	PROCEDURE closeopenedtables
		Local lcTable, lnTables, lnX
		
		Local Array laTablesOpen[1]
		
		If Vartype(This.aInUse(1)) = [L]
		  Return
		EndIf
		Use in (Select(this.cCursor))
		
		lnTables = Aused(laTablesOpen)
		For lnX = 1 To m.lnTables
		  lcTable = m.laTablesOpen(m.lnX, 1)
		  If !Empty(m.lcTable);
		      And !(m.lcTable == Upper(This.cTableSelected));
		      And Ascan(This.aInUse,  m.lcTable, -1, -1, 1, 7) = 0;
		      and ! Lower(m.lcTable) == this.cTableToKeepOpen 
		    Use In (m.lcTable)
		  Endif
		EndFor
		
		
	ENDPROC

	PROCEDURE createbindevent
		#Define crlf Chr(13)+Chr(10)
		Local lcText, lcWord1, lcWord2
		
		lcWord1 = Getwordnum(This.cParameter, 1, [, ])
		lcWord2 = Getwordnum(This.cParameter, 2, [, ])
		If Empty(m.lcWord1) Or Empty(m.lcWord2) Or ![.] $ m.lcWord1 Or ![.] $ m.lcWord2
		  this.GiveMessage([syntax: BE object1.event1,object2.event2], 0 + 64, [Invalid Parameters(s)], 5000)
		Else
		  lcText = Textmerge([Bindevent(<<Juststem(lcWord1)>>, "<<Justext(lcWord1)>>", <<Juststem(lcWord2)>>, "<<Justext(lcWord2)>>")])
		  This.ReplaceCurrentLine(m.lcText + crlf)
		Endif
	ENDPROC

	PROCEDURE createcommentline
		Local lcReturn, lcString, lcX, lnMax, lnX
		
		lnX = This.FindValueInString(This.cCommand )
		lnMax = 250
		lcX = Transform(m.lnX)
		lcString = Left(This.cCommand, At(Transform(m.lnX), This.cCommand ) - 1)
		lnX = Min(m.lnX, m.lnMax )
		Do Case
		  Case Len(m.lcString) > 2 And Right(m.lcString, 1) = [*]
		    lcString = Substr(This.cCommand, 2, Len(m.lcString) - 2)
		    lcReturn = [*] + Replicate(m.lcString, Int( (m.lnX - 2) / Len(m.lcString))) + [*]
		  Case Len(m.lcString) = 2 And [:] $ m.lcString
		    lcReturn = Replicate([her], m.lnX)
		  Otherwise
		    lcReturn = Replicate(m.lcString, Min(m.lnX / Len(m.lcString), m.lnMax ))
		Endcase
		This.ReplaceCurrentLine(m.lcReturn)
		
		
	ENDPROC

	PROCEDURE createes
		#Define crlf Chr(13)+Chr(10)
		Local lcCallerName, lcCommand, lcFullName, lcProject, lcText, llClip, llNewProject, llTest
		Local lnCallerHandle, lnCallerType, lnEdType, lnLength, lnProject, loWindows
		
		lcText = This.cParameter
		lnCallerType = This.nWindowType
		If m.lnCallerType > 0
		  lcCallerName = Lower(This.oEditorWin.GetTitle())
		  lcFullName = Fullpath(m.lcCallerName)
		Endif
		lnCallerHandle = This.nHandle
		If m.lnCallerType < 0 Or (m.lnCallerType = 0 And Empty(m.lcCallerName))
		  Wait Window [Not legal from this window] At 10, 25 Timeo 5
		  Return
		Endif
		lnProject = 0
		loWindows = This.oEditorWin.GetOpenWindows()
		llTest = Pemstatus(_Screen, [lTest], 5) And _Screen.lTest
		llClip = .T.
		lnEdType = 1
		llNewProject = .F.
		Do Case
		  Case Inlist( m.lnCallerType, 1, 2) And Pemstatus(_Screen, [cSidekickfile], 5) And m.lcCallerName = Lower(This.cSidekickFile)
		    lnEdType = 4 && Only number, Ed syntax
		    Do Case
		      Case Left(m.lcText, 1) = [+] && find next project
		        lnProject = This.GetNextProject()
		        lcText = Substr(m.lcText, 2)
		        If Empty(Left(m.lcText, 1))
		          lcProject = Getwordnum(m.lcText, 1)
		          lcText = []
		        Else
		          lcProject = Getwordnum(m.lcText, 2)
		          lcText = Getwordnum(m.lcText, 1)
		        Endif
		        llNewProject = .T.
		      Case Val(m.lcText) > 0
		        lnProject = Int(Val(m.lcText))
		        lnLength = Len(Transform(m.lnProject))
		        lcText = Substr(m.lcText, m.lnLength + 1 )
		      Otherwise
		        lnProject = -1
		    Endcase
		    Do Case
		      Case Inlist(Lower(m.lcText), [x], [editsourcex], [edx], [ex])
		        lnEdType = 3
		      Case Inlist(Lower(m.lcText), [s], [editsource], [eds], [es])
		        lnEdType = 1
		      Case Inlist(Lower(m.lcText), [e], [es])
		        lnEdType = 2
		    Endcase
		    lcCommand  = This.ScanAllWIndows(m.loWindows, m.lnCallerHandle, m.lnProject, m.lnEdType)
		    This.oEditorWin.SelectWindow(m.lnCallerHandle)
		    This.CutCurrentLine()
		    If m.llNewProject
		      lcProject = Evl(m.lcProject, [New project])
		      lcProject = Inputbox([Type new project name: ], [], m.lcProject)
		      lcProject = Evl(m.lcProject, [New project])
		      lcCommand = [#] + Transform(m.lnProject) + [ ] + m.lcProject + crlf + crlf + m.lcCommand
		    Endif
		    If !Empty(m.lcCommand) And This.GiveMessage([Paste the following code:] + crlf + m.lcCommand, 4 + 64, [Current file is ] + This.cSidekickFile ) = 6
		      This.WriteCurrentLine(m.lcCommand)
		    Else
		      Wait Window At 10, 25 [Operation cancelled!] Timeout 2
		    Endif
		  Case m.lnCallerType >= 0
		    Do Case
		      Case [s] $ Lower(m.lcText) Or [s] $ This.cOption
		        lnEdType = 1
		      Case [e] $ Lower(m.lcText) Or [e] $ This.cOption
		        lnEdType = 2
		      Case [x] $ Lower(m.lcText) Or [x] $ This.cOption
		        lnEdType = 3
		      Case [n] $ Lower(m.lcText)
		        lnEdType = 4
		    Endcase
		    If Left(Lower(m.lcText), 3) = [all]
		      lcCommand  = This.ScanAllWIndows(m.loWindows, m.lnCallerHandle, m.lnProject, m.lnEdType)
		      This.oEditorWin.SelectWindow(m.lnCallerHandle)
		      This.CutCurrentLine()
		      If !Empty(m.lcCommand) And  This.GiveMessage([Paste the following code:] + crlf + m.lcCommand, 4 + 64, [Current file is ] + This.cSidekickFile ) = 6
		        This.WriteCurrentLine(m.lcCommand)
		      Else
		        Wait Window At 10, 25 [Operation cancelled!] Timeout 2
		      Endif
		    Else
		      If m.lnCallerType > 0
		        lcCommand = This.GetEditSourceCode(m.lnCallerHandle, m.lnEdType, [])
		        This.CutCurrentLine()
		        If !Empty(m.lcCommand)
		          If This.GiveMessage( [Copy this code to the clipboard?] + crlf + m.lcCommand, 4 + 32, [Generated code!]) = 6
		            This.cClip = m.lcCommand
		          Else
		            Wait Window At 10, 25 [Operation cancelled!] Timeout 2
		          Endif
		        Endif
		      Endif
		    Endif
		  Case Empty(m.lcCallerName)
		    This.GiveMessage( [Select a program or text file, or a method, first!], 0 + 48, [Not applicable from here!], 3000)
		  Otherwise
		    This.GiveMessage(ccCanNotUse, 0 + 48, [This function only works in code windows!], 3000)
		Endcase
		This.oEditorWin.SelectWindow(m.lnCallerHandle)
		
		
	ENDPROC

	PROCEDURE createno
		#Define Stripextension 'BIZ,$$$'
		#Define ccCursor 'CurObjects'
		
		Local lcClass, lcClassFilter, lcClassInfo, lcClassLib, lcExact, lcFilter, lcNewText, lcParameter
		Local lcPasteText, lcPrefix, lcSource, lcText, lcVariable, llClipboard, llMethod, llPartOfClass
		Local llPartOfClasslib, llRefresh, lnClasses, lnHits, lnI, lnSelect, lnX, ltTimestamp
		
		lcExact = Set([Exact])
		lnSelect = Select()
		lcFilter = []
		lcParameter = This.cParameter
		lcClassFilter = Getwordnum(m.lcParameter, 2, [= ])
		lcParameter = Getwordnum(m.lcParameter, 1, [= ] )
		If Empty(m.lcClassFilter)
		  lcClassFilter = Evl(m.lcParameter, [lo])
		  lcParameter = []
		Endif
		llMethod = [.] $ m.lcParameter
		
		If m.llMethod
		  lcPrefix = Getwordnum(m.lcParameter, 1, [.])
		  lcVariable = Getwordnum(This.cParameterOriginal, 2, [.])
		Else
		  lcPrefix = []
		  If Empty(m.lcParameter)
		    lcVariable = m.lcClassFilter && []
		  Else
		    lcVariable = This.cParameterOriginal
		  Endif
		Endif
		
		If ![o] $ This.cOption
		  This.GetFilesInPath([vcx], [curdummy])
		  If Reccount([curdummy]) > 0
		    Create Cursor (ccCursor) (Classname c(50), LibName c(240), Timestamp T, Classinfo c(254) )
		    Select curDummy
		    Scan
		      lcSource = Trim(curDummy.Fname)
		      Use In Select([tempsource])
		      Use (m.lcSource) Again In 0 Alias tempsource
		      Select tempsource
		      Scan For reserved1 == [Class] And !Deleted()
		        lcClass = tempsource.ObjName
		        lcClassLib = m.lcSource
		        ltTimestamp = This.DecodeTimeStamp(tempsource.Timestamp)
		        If  ! [r] $ This.cOption
		          lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(Sys(2014, m.lcClassLib, Curdir()))
		        Else
		          lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(m.lcClassLib)
		        Endif
		        Insert Into (ccCursor) (Classname, LibName, Classinfo, Timestamp) Values (;
		            This.ShowCase( tempsource.ObjName), This.ShowCase(m.lcSource), m.lcClassInfo, m.ltTimestamp )
		      Endscan
		      Use In tempsource
		    Endscan
		    Use In curDummy
		  Endif
		  Select (ccCursor)
		  lnClasses = Reccount()
		
		
		  Do Case
		    Case (Left(m.lcClassFilter, 1) == [*] Or Right(m.lcClassFilter, 1) == [*]) And Len(m.lcClassFilter) > 1
		      If Getwordcount(This.cParameter) = 1
		        lcFilter = Chrtran(m.lcClassFilter, [*], [])
		        lcVariable = [lo] + Proper(m.lcFilter)
		      Endif
		      Select * From (ccCursor) Where m.lcFilter $ Classname Into Cursor (ccCursor) Readwrite Order By 1, 2
		      *!*        Select * From (ccCursor) Where Substr(m.lcClassFilter, 2) $ Classname Into Cursor (ccCursor) Readwrite Order By 1, 2
		    Case Getwordcount(This.cParameter ) = 2
		      lcVariable = Getwordnum(This.cParameterOriginal, 1)
		      lcFilter = Getwordnum(This.cParameter, 2)
		      Select * From (ccCursor) Where m.lcFilter $ Classname Into Cursor (ccCursor) Readwrite Order By 1, 2
		    Case Empty(This.cParameter );
		        Or This.cParameter == [*];
		        Or m.lcClassFilter == [*];
		        Or Empty(m.lcParameter)
		      Select * From (ccCursor) Into Cursor (ccCursor) Readwrite Order By 1, 2
		    Otherwise
		      Select * From (ccCursor) Where m.lcClassFilter = Classname  Into Cursor (ccCursor) Readwrite Order By 1, 2
		  Endcase
		  lnHits = Reccount()
		Else
		  Private llNoProject
		  llPartOfClass = [*] $ m.lcClassFilter
		  llRefresh = [!] $ m.lcClassFilter
		  llPartOfClasslib = [+] $ m.lcClassFilter
		  llClipboard = [-] $ m.lcClassFilter
		  lcClassFilter = Chrtran(m.lcClassFilter, [*!+-], [])
		
		  lcParameter = Evl(m.lcParameter, [*]) && TB
		
		  Do Case
		    Case m.llMethod And Len(m.lcClassFilter) = 0
		      This.GiveMessage([Illegal input!], 0, [], 5000)
		      Return
		  Endcase
		  Set Exact Off
		  llNoProject = Type([_vfp.activeproject.name]) = [U] Or Empty(_vfp.ActiveProject.Name)
		  lcNewText = []
		  Do Case
		    Case m.llNoProject
		      This.readClassLibs()
		    Case m.llRefresh Or !Pemstatus(_vfp, [noClasses], 5) Or Empty(_vfp.noClasses);
		        Or !Pemstatus(_vfp, [noLenClasses], 5) Or _vfp.noLenClasses = 1
		      lnClasses = This.readClassLibs()
		    Otherwise
		      lnClasses = _vfp.noLenClasses
		  Endcase
		  lcClassFilter = Lower(m.lcClassFilter)
		  Do Case
		    Case Type([_vfp.activeproject.name]) = [U] And !Pemstatus(_vfp, [noProject], 5)
		      AddProperty(_vfp, [noProject], [])
		    Case !Pemstatus(_vfp, [noProject], 5)
		      AddProperty(_vfp, [noProject], _vfp.ActiveProject.Name)
		  Endcase
		  Do Case
		    Case m.llNoProject
		      _vfp.Noproject = []
		      lnClasses = This.readClassLibs()
		    Case m.llRefresh
		      If Type([_vfp.activeproject.name]) = [C]
		        _vfp.Noproject = _vfp.ActiveProject.Name
		      Endif
		      This.readClassLibs()
		    Case Type([_vfp.activeproject.name]) # [U] And !_vfp.Noproject == _vfp.ActiveProject.Name
		      _vfp.Noproject = _vfp.ActiveProject.Name
		      This.readClassLibs()
		  Endcase
		  If m.lnClasses > 1
		    Select 0
		    Create Cursor (ccCursor) (Classname c(50), LibName c(240), Classinfo c(254) )
		    Index On LibName Tag LibName
		    Index On Classname Tag Classname
		    lnHits = 0
		    For lnI = 1 To _vfp.noLenClasses
		      lcClassLib  = _vfp.noClasses(m.lnI, 2)
		      lcClass     = _vfp.noClasses(m.lnI, 1)
		      Do Case
		        Case m.llPartOfClass And Len(m.lcClassFilter) > 0 And m.lcClassFilter $ Lower(m.lcClass)
		        Case m.llPartOfClasslib And Len(m.lcClassFilter) > 0 And;
		            (m.lcClassFilter $ Lower(m.lcClass) Or m.lcClassFilter $ Lower(m.lcClassLib))
		        Case Len(m.lcClassFilter) > 0 And m.lcClass = Lower(m.lcClassFilter)
		        Case Empty(This.cParameter) && or m.lcParameter == [*] && TBCheck
		        Case This.cParameter == [*]
		        Otherwise
		          Loop
		      Endcase
		      lnHits = m.lnHits + 1
		      If ! [r] $ This.cOption
		        lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(Sys(2014, m.lcClassLib, Curdir()))
		      Else
		        lcClassInfo = This.ShowCase(m.lcClass) + [|] + This.ShowCase(m.lcClassLib)
		      Endif
		      Insert Into (ccCursor) (Classname, LibName, Classinfo) Values (This.ShowCase(m.lcClass), This.ShowCase(Sys(2014, m.lcClassLib)), m.lcClassInfo )
		    Endfor
		    Go Top
		  Endif
		Endif
		If Reccount() = 0
		  Wait Window [No match found] At 10, 25 Timeout 2
		  Return
		Endif
		If [n] $ This.cOption && Newest first
		  Select * From (ccCursor) Into Cursor (ccCursor) Order By Classname, Timestamp Desc Readwrite
		Endif
		
		lcClassInfo =  This.GetDataFromGrid([Pick a class], [Classinfo], 1)
		If Empty(m.lcClassInfo)
		  Return
		Endif
		If m.lnHits > 0
		  lcClassInfo = Alltrim(Evaluate(ccCursor + [.ClassInfo]))
		  lcClass  = Getwordnum (m.lcClassInfo, 1, [|])
		  lcClassLib     = Getwordnum (m.lcClassInfo, 2, [|])
		  lcPasteText = []
		  If Empty(m.lcVariable) Or Right(m.lcVariable, 1) = [*]
		    lcVariable = [lo] + Proper(Juststem(m.lcClass))
		    For lnX = 1 To Getwordcount(Stripextension, [,])
		      lcText = Getwordnum(Stripextension, m.lnX, [,])
		      If Lower(Right(m.lcVariable, Len(m.lcText))) == Lower(m.lcText)
		        lcVariable = Left(m.lcVariable, Len(m.lcVariable) - Len(m.lcText))
		        Exit
		      Endif
		    Endfor
		  Endif
		  If m.llMethod
		    If ! [r] $ This.cOption
		      lcPasteText = m.lcPrefix + [.NewObject('] + m.lcVariable + [','] + Juststem(m.lcClass) + [', '] + Alltrim(m.lcClassLib) + [')]
		    Else
		      lcPasteText = m.lcPrefix + [.NewObject('] + m.lcVariable + [','] + Juststem(m.lcClass) + [', '] + Justfname (m.lcClassLib) + [')]
		    Endif
		  Else
		    If ! [r] $ This.cOption
		      If This.nWindowType # 0
		        lcPasteText = [Local ] + m.lcVariable + [ as ] + m.lcClass + [ of ] + Alltrim(m.lcClassLib) + crlf
		      Endif
		      lcPasteText = m.lcPasteText + m.lcVariable + [ = NewObject('] + Juststem(m.lcClass) + [', '] + Alltrim(m.lcClassLib) + [')]
		    Else
		      If This.nWindowType = 0
		        lcPasteText = m.lcPasteText + m.lcVariable + [ = NewObject('] + Juststem(m.lcClass) + [', '] + m.lcClassLib + [')]
		      Else
		        lcPasteText = [Local ] + m.lcVariable + [ as ] + m.lcClass + [ of ] + Justfname (m.lcClassLib) + crlf
		        lcPasteText = m.lcPasteText + m.lcVariable + [ = NewObject('] + Juststem(m.lcClass) + [', '] + Justfname (m.lcClassLib) + [')]
		      Endif
		    Endif
		  Endif
		  If m.llClipboard
		    _Cliptext = Iif(Empty(m.lcPrefix), m.lcVariable, m.lcPrefix + [.] + m.lcVariable)
		  Endif
		  If This.nWindowType # 0
		    lcPasteText = m.lcPasteText + crlf
		  Endif
		  This.oEditorWin.Paste(m.lcPasteText)
		Else
		  This.GiveMessage([No match found!], 0 + 48, [], 5000)
		Endif
		If m.lcExact = [ON]
		  Set Exact On
		Endif
		Select (m.lnSelect)
		Return
		
		
	ENDPROC

	PROCEDURE createqmark
		Lparameters tldbo
		Local lcReturn
		lcParameter = this.cParameter 
		If Empty(m.lcParameter )
		  m.lcParameter = Substr(this.cCommand , 3)
		EndIf
		If Left(m.lcParameter,1) = '='
		  m.lcParameter = Substr(m.lcParameter,2)
		Endif
		If Empty(m.lcParameter ) Or Getwordcount(m.lcParameter ) > 1
		  Return
		Endif
		If m.tldbo
		  lcReturn = Textmerge([DebugOut '<<Strtran( m.lcParameter ,'m.','') >>', <<m.lcParameter >>])
		Else
		  lcReturn = Textmerge([?'<<Strtran( m.lcParameter ,'m.','') >>', <<m.lcParameter >>])
		Endif
		this.ReplaceCurrentLine(m.lcReturn)
	ENDPROC

	PROCEDURE createsidekickcursor
		Local lcAsk, lcDesc, lcFile, lcProg, lcSelect, lcSidekickOptions, lcTrigger, lcURL, lcVar, lcWindow
		Local lnLines, lnX
		
		Local Array laSidekickChoices[1]
		
		lcSidekickOptions = This.GetHelpTopics()
		lcSelect = Select()
		Select 0
		Create Cursor curSidekick (Trigger c(12), Descript c(50),  Window c(2), Ask c(25),  url c(100))
		
		lnLines = Alines(m.laSidekickChoices, m.lcSidekickOptions )
		For lnX = 1 To m.lnLines
		  lcWindow = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 1, [|]))
		  Do Case
		    Case Left(m.lcWindow, 1) = [*]
		      Loop
		    Case m.lcWindow = [a]
		    Case This.nWindowType = 0 And [c] $ m.lcWindow && Command window
		    Case This.nWindowType > 0 And [e] $ m.lcWindow && Modify window/file
		    Case This.nWindowType >= 10 And [f] $ m.lcWindow && Form or class window
		    Case This.nWindowType < 0 And [m] $ m.lcWindow && Menu version
		    Otherwise
		      Loop
		  Endcase
		  lcTrigger = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 2, [|]))
		  If m.lcTrigger = [<blank>]
		    lcTrigger = [ <blank>]
		  Endif
		  lcDesc = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 3, [|]))
		  lcAsk = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 5, [|]))
		  lcURL = Alltrim(Getwordnum( m.laSidekickChoices(m.lnX), 4, [|]))
		  Do Case
		    Case Left(m.lcURL, 2) = [sk] And [ #] $ m.lcURL
		      lcURL = Strtran(m.lcURL, [#], [.md#])
		      lcURL = Textmerge([<<this.cSidekickHelp>>blob/master/documents/<<m.lcURL>>])
		    Case Left(m.lcURL, 2) = [sk]
		      lcURL = Forceext(m.lcURL, [md])
		      lcURL = Textmerge([<<this.cSidekickHelp>>blob/master/documents/<<m.lcURL>>])
		    Case m.lcURL = [<default>]
		      lcURL = Textmerge([<<this.cSidekickHelp>>])
		    Case m.lcURL = [<ver>]
		      lcDesc = [Version: ] + This.cVersion
		      lcURL = Textmerge([<<this.cSidekickHelp>>/blob/master/Change%20Log.md])
		  Endcase
		
		
		  Insert Into curSidekick (Trigger, Descript, Ask, url) Values (m.lcTrigger, m.lcDesc, m.lcAsk, m.lcURL )
		Endfor
		Select Trigger, Descript, url, Ask From curSidekick Into Cursor curSidekick Readwrite
		Index On Lower(Descript) Tag Descript
		Index On Trigger Tag Trigger
		If [x] $ This.cOption
		  Browse Normal
		Endif
		lcProg = This.GetDataFromGrid(Textmerge([<<this.cProgram>> "commands", Ctrl+Enter opens url]), [trigger], 1)
		lcAsk = Alltrim(Ask)
		
		Use
		Select (m.lcSelect)
		If Getwordnum(m.lcProg, 1) # [0]
		  lcProg = Getwordnum( m.lcProg, 1)
		Endif
		If !Empty(m.lcProg)
		  Do Case
		    Case Lower(m.lcAsk) == [na]
		      lcProg = []
		    Case m.lcProg = [<blank>]
		      lcProg = [menu] && [ed]
		    Case m.lcProg = [2-9999]
		      lcProg = Alltrim(Inputbox(m.lcAsk), [Empty for list])
		      m.lcProg = Evl(m.lcProg,'*')
		    Case m.lcProg = [0 <file>]
		      lcFile = Alltrim(Inputbox(m.lcAsk, [Specify .sk file name!]))
		      If Empty(m.lcFile)
		        This.GiveMessage([No Sidekick file is specified!], 0 + 48)
		        Return
		      Endif
		      lcFile = Forceext(m.lcFile, [sk])
		      lcProg = [0 ] + m.lcFile
		    Case m.lcProg = [?=]
		      lcVar = Alltrim(Inputbox(m.lcAsk, [Value is required!]))
		      If Empty(m.lcVar)
		        This.GiveMessage([No variable given], 0 + 48)
		        Return
		      Endif
		      lcProg = m.lcProg + m.lcVar
		    Case Lower(m.lcAsk) = [filename or url:]
		      lcProg = m.lcProg + [ ] + Inputbox(m.lcAsk, [Enter a value or press Enter for list!])
		    Case !Empty(m.lcAsk)
		      lcProg = m.lcProg + [ ] + Inputbox(m.lcAsk, [Value is required!])
		    Case Inlist(Lower(m.lcProg), [sk], [sked], [eval])
		      lcProg = m.lcProg + [ ] + Inputbox([Name of file:], [Empty gives picklist])
		  Endcase
		  If This.lSKComment
		    lcProg = [*] + m.lcProg
		  Endif
		  *!*    lo = Newobject([sidekick], [tools\procs\thor_proc_sidekick.vcx] )
		  *!*    m.lo.Init(m.lcProg)
		  *!*    this.Init(m.lcProg)
		  If !Empty(m.lcProg)
		    Execscript(_Screen.cThorDispatcher, [thor_tool_sidekick], m.lcProg )
		  Else
		    This.GiveMessage([This command is not available via Help menu!])
		  Endif
		Endif
		If This.lSKComment
		  This.CutCurrentLine()
		Endif
		
		
	ENDPROC

	PROCEDURE createusesyntax
		Local lcCursorfiles, lcDBF, lcFullName, lcMessage, lcTable, lcText, llListfiles, lnPos
		
		lcCursorfiles = This.cCursor
		llListfiles = .T.
		Do Case
		  Case File(This.cParameter)
		    llListfiles = .F.
		  Case [.dbf] $ This.cParameter
		    This.cParameter = Strtran(This.cParameter, [.dbf], [])
		  Case [.d] $ This.cParameter
		    This.cParameter = Strtran(This.cParameter, [.d], [])
		  Case [.vcx] $ This.cParameter
		    This.AddOption([v])
		    This.cParameter = Strtran(This.cParameter, [.vcx], [])
		  Case [.vc] $ This.cParameter
		    This.AddOption([v])
		    This.cParameter = Strtran(This.cParameter, [.vc], [])
		  Case [.v] $ This.cParameter
		    This.AddOption([v])
		    This.cParameter = Strtran(This.cParameter, [.v], [])
		  Case [.scx] $ This.cParameter
		    This.AddOption([s])
		    This.cParameter = Strtran(This.cParameter, [.scx], [])
		  Case [.sc] $ This.cParameter
		    This.AddOption([s])
		    This.cParameter = Strtran(This.cParameter, [.sc], [])
		  Case [.s] $ This.cParameter
		    This.AddOption([s])
		    This.cParameter = Strtran(This.cParameter, [.s], [])
		Endcase
		If This.nWindowType # 0 And ([s] $ This.cOption Or [v] $ This.cOption)
		  Return
		Endif
		Do Case
		  Case [u] $ This.cOption Or This.cParameter == [-]
		    This.AddOption([-b])
		    This.AddOption([u])
		    lcMessage = [List if tables in use:]
		  Otherwise
		    lcMessage = [Pick a table to use:]
		Endcase
		If [c] $ This.cOption Or [u] $ This.cOption
		  If This.ListUsedTables()
		    lcMessage = [Pick a table to close:]
		    this.lNoMessage = .T.
		    lcDBF = This.GetDataFromGrid(m.lcMessage, [fullname], 0)
		    If Lastkey() = 27
		      m.lcDBF = ''
		    Endif
		  Else
		    This.GiveMessage([No tables are currently in use], , , This.nTimeOut )
		  Endif
		Else
		  If m.llListfiles
		    lcDBF = This.ListFiles([dbf])
		  Else
		    lcDBF = This.cParameter
		  Endif
		Endif
		If Vartype(m.lcDBF) = [C] And !Empty(m.lcDBF)
		  This.lNoSelectOnExit = .T.
		  If m.llListfiles
		    lcTable = Trim(Juststem(Evaluate(m.lcCursorfiles + [.fullname])))
		    lcFullName = Trim(Evaluate(m.lcCursorfiles + [.fullname]))
		  Else
		    lcTable = Juststem(m.lcDBF)
		    lcFullName = m.lcDBF
		  Endif
		  lcFullName = This.FixPath( m.lcFullName )
		  This.cTableSelected = m.lcTable
		  Do Case
		    Case This.cCommand = [sf]
		*!*          Select  from <<this.FixPath(lcFullName)>>
		
		      Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		        Select  from <<StrExtract(this.FixPath(lcFullName),'','.')>>
		      Endtext
		      lnPos = This.oEditorWin.nCurrentLineStart
		      This.ReplaceCurrentLine(m.lcText )
		      This.oEditorWin.SetInsertionPoint(m.lnPos + 7)
		    Case [u] $ This.cOption
		      Select Trim(Evaluate(This.cCursor + [.alias]))
		      This.GiveMessage(Trim(Evaluate(This.cCursor + [.alias])) + [ is selected], , , This.nTimeOut )
		    Case [c] $ This.cOption and !Empty(m.lcDBF)
		      Use In Select(Trim(Evaluate(This.cCursor + [.alias])))
		      This.GiveMessage(Trim(Evaluate(This.cCursor + [.alias])) + [ is closed], , , This.nTimeOut )
		    Otherwise
		      If This.nWindowType = 0
		        Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		          * Select Select("<<m.lcTable>>" )
		          * Use "<<m.lcFullName>>"
		        Endtext
		        Select Select(m.lcTable )
		        If Select([query]) > 0 And  Lower(Juststem(Dbf(Select([query])))) = Lower(m.lcTable)
		          Use In Query
		        Endif
		
		        Use (m.lcFullName )
		        This.CutCurrentLine()
		        This.ReplaceCurrentLine(m.lcText + Chr(13))
		        If [b] $ This.cOption
		          This.GetDataFromGrid(Dbf(), [Field(1)], ,.F.)
		        Else
		          Return
		        Endif
		      Else
		        If ! [s] $ This.cOption And ! [v] $ This.cOption && Len(This.cOption) = Len(Chrtran(This.cOption, [sv], []))   && Empty(This.cOption)
		          Text To m.lcText Noshow Textmerge Pretext 1 + 2 + 4
		            Use "<<m.lcFullName>>" in Select("<<m.lcTable>>")
		          Endtext
		          This.ReplaceCurrentLine(m.lcText)
		        Endif
		      Endif
		  Endcase
		Else
		  If ! 'c' $ this.cOption 
		    This.GiveMessage([No files matches], , , 3000)
		  Endif
		  Return .T.
		
		Endif
		
	ENDPROC

	PROCEDURE cutandgivemessage
		Lparameters tcMessage, tnDialog, tcTitle, tnTimeOut
		If this.nWindowType = 0
		  this.CutCurrentLine()
		Endif
		this.GiveMessage(tcMessage, tnDialog, tcTitle, tnTimeOut)
	ENDPROC

	PROCEDURE cutcurrentline
		Local lcClip, lcText
		
		If !This.lNoInterface
		  If Vartype(This.oEditorWin) # [O]
		    This.oEditorWinInit()
		  Endif
		  lcClip = _Cliptext
		  This.HighlightCurrentLine()
		  If This.nWindowType < 0
		    Return []
		  Endif
		  This.oEditorWin.Copy()
		  lcText = _Cliptext
		  _Cliptext = m.lcClip
		  This.oEditorWin.Cut()
		  Return m.lcText
		Endif
		
		
		
	ENDPROC

	PROCEDURE decodetimestamp
		Parameter tnStamp
		
		#Define SecondsMask 15  && 00001111
		#Define MinutesMask 63  && 00111111
		#Define HoursMask   31  && 00011111
		#Define DaysMask    31  && 00011111
		#Define MonthsMask  15  && 00001111
		#Define YearsMask   63  && 00111111
		
		#Define SecondsOffset 1  && Note this is a LEFT shift, not RIGHT
		#Define MinutesOffset 5
		#Define HoursOffset   11
		#Define DaysOffset    16
		#Define MonthsOffset  21
		#Define YearsOffset   25
		
		#Define fMonth       Bitand(Bitrshift(tnStamp,MonthsOffset ),MonthsMask)
		#Define fDay         Bitand(Bitrshift(tnStamp,DaysOffset   ),DaysMask)
		#Define fYear   1980+Bitand(Bitrshift(tnStamp,YearsOffset  ),YearsMask)
		#Define fHour        Bitand(Bitrshift(tnStamp,HoursOffset  ),HoursMask)
		#Define fMinute      Bitand(Bitrshift(tnStamp,MinutesOffset),MinutesMask)
		#Define fSecond      Bitand(Bitlshift(tnStamp,SecondsOffset),SecondsMask)
		Local ltReturn
		
		ltReturn = Iif(m.tnStamp = 0, {//::}, ;
		    Datetime(fYear, fMonth, fDay, fHour, fMinute, fSecond))
		Return m.ltReturn
	ENDPROC

	PROCEDURE Destroy
		this.CloseOpenedTables()
		Do case 
		  case !Empty(this.cTableToKeepOpen)
		    Select (this.cTableToKeepOpen)
		  Case !this.lNoSelectOnExit 
		    Select (this.nSelect)    
		Endcase
		
		If this.cExact = 'ON'
		  Set Exact On 
		EndIf
		Set Point To this.cPoint 
		
	ENDPROC

	PROCEDURE dir2dt
		Lparameters tcTime, ttDate
		Local lnDay, lnHour, lnMin, lnMonth, lnSec, lnYear
		
		lnSec = Val(Strextract(m.tcTime, [:], [], 2))
		lnMin = Val(Strextract(m.tcTime, [:], [:], 1))
		lnHour = Val(Strextract(m.tcTime, [], [:]))
		lnDay = Day(m.ttDate)
		lnMonth = Month(m.ttDate)
		lnYear = Year(m.ttDate)
		Return Datetime(m.lnYear, m.lnMonth, m.lnDay, m.lnHour, m.lnMin, m.lnSec)
	ENDPROC

	PROCEDURE dobrow
		Lparameters tcValues
		Local lcParameter, lcProcess
		Local loPg as pg of tools\procs\thor_proc_sidekick.vcx
		If !Empty(Dbf())
		  tcValues = Evl(m.tcValues, [])
		  If 'w' $ this.cOption 
		    m.tcValues = m.tcValues + 'W'
		  Endif
		  lcParameter = [10UZF] + m.tcValues
		  lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		  loPg = Newobject([pg], m.lcProcess, [], m.lcParameter)
		  lopg.FontSize = this.nFontSize 
		  If 'w' $ this.cOption 
		    lopg.Caption = lopg.Caption + ' (Read/write)'
		  Else 
		    lopg.Caption = lopg.Caption + ' (R/O)'
		  Endif
		  m.loPg.Show(1)
		Endif
		
		
	ENDPROC

	PROCEDURE dounzip
		Local lcZipFile, lcTargetFolder, llOK
		
		lcZipFile = GetWordNum(this.cParameter,1)
		lcTargetFolder = GetWordNum(this.cParameter,2)
		
		If Vartype(This.oZip) # [O]
		  This.oZipInit()
		EndIf
		If m.lcZipFile = '?' or Empty(m.lcZipFile)
		  m.lcZipFile = this.ListFiles('.zip')
		Endif
		
		If Empty(m.lcZipFile) 
		  This.GiveMessage([You must specify a zip file!])
		  Return .F.
		Endif
		If Empty(Justext(m.lcZipFile))
		  lcZipFile = Forceext(m.lcZipFile, [.zip])
		Endif
		lcTargetFolder = Evl(m.lcTargetFolder, this.cUnzipFolder)
		llOK = .T.
		lcNew = 'already existing'
		If !Directory(m.lcTargetFolder)
		  Try
		    Md (m.lcTargetFolder)
		    m.lcNew = 'new'
		  Catch
		    llOK = .F.
		    This.GiveMessage([Can't create folder ] + m.lcTargetFolder)
		  Endtry
		Endif
		If !File(m.lcZipFile)
		  This.GiveMessage([No file called ] + m.lcZipFile)
		  llOK = .F.
		Endif
		If !m.llOK
		  Return .T.
		Else
		  If !This.oZip.Unzip(m.lcZipFile, m.lcTargetFolder)
		    this.GiveMessage(this.oZip.cErrorMessage)
		  Else
		    this.GiveMessage(m.lcZipFile + ' is unzipped into ' + m.lcNew + ' folder ' + m.lcTargetFolder)
		  Endif
		Endif 
		
	ENDPROC

	PROCEDURE dozip
		Local lcDestination, lcFileList, lcFiles, lcFolder, lcText, llSuccess, lnFails, lnFiles, lnLines
		Local lnX
		
		Local Array laDummy[1]
		
		If Vartype(This.oZip) # [O]
		  This.oZipInit()
		Endif
		This.cParameter = Evl(This.cParameter, [?])
		lcFiles = Getwordnum(This.cParameter, 1)
		lcDestination = Getwordnum(This.cParameter, 2)
		If !This.lTidy
		  lcDestination = Forceext(m.lcDestination, [zip])
		  If Empty(m.lcDestination)
		    lcDestination = This.GetLastFile(Forceext(This.cZipTarget, [.zip]))
		    lcDestination = This.GetNextFile(m.lcDestination, This.nNextLength)
		  Endif
		  Do Case
		    Case  Inlist(This.GetLastCharacter(m.lcDestination), [!], [*])
		      lcDestination = Juststem(Chrtran( m.lcDestination, [*!], []))
		      lcDestination = This.GetLastFile(Forceext(m.lcDestination, [zip]))
		      lcDestination = This.GetNextFile(m.lcDestination, This.nNextLength)
		    Case This.GetLastCharacter(m.lcDestination) = [?]
		      lcDestination = Chrtran(m.lcDestination, [?], []) + This.GetSortableDate()
		  Endcase
		Endif
		If m.lcFiles # [?] And Empty(Getwordnum(This.cParameter, 2)) And ![,] $ m.lcFiles And (Empty(Justext(m.lcFiles)) Or Lower(Justext(m.lcFiles)) = [zip]) And !File(m.lcFiles)
		  lcDestination = Forceext(m.lcFiles, [.zip])
		  lcFiles = []
		Endif
		lcFiles = Evl(m.lcFiles, [?])
		Do Case
		  Case [?] $ m.lcFiles
		    If This.lTidy
		      *!*        this.AddOption('x')
		      This.lAddExtraExtensions = .T.
		    Endif
		    lcFiles = Chrtran(m.lcFiles, [?], [])
		    This.cFilter = [Include]
		    lcFiles = This.ListFiles(m.lcFiles )
		  Case Len(m.lcFiles) # Len(Chrtran(m.lcFiles,'*',''))
		*!*      [ *] $ m.lcFiles does not work, bug in BeautifyX!!!
		    lnFiles = Adir(laDummy, m.lcFiles)
		    If m.lnFiles > 0
		      lcFolder = Justpath(m.lcFiles)
		      lcFiles = Lower(This.MakeStringFromArray(@m.laDummy, m.lcFolder ))
		    Else
		      This.GiveMessage( [No match found], 0 + 48 )
		    Endif
		  Otherwise
		Endcase
		If !Empty(m.lcFiles)
		  lcFileList = This.GetFilelistToProcess(Lower(m.lcFiles))
		Endif
		If !Empty(m.lcFileList)
		  lcText = [added]
		  If !This.lTidy
		    lnLines = Alines(m.laDummy, m.lcFileList, 0, [,])
		    lnFails = 0
		    For lnX = 1 To m.lnLines
		      Wait Window [Zipping ] + m.laDummy(m.lnX) At 10, 25 Time This.nZipDelay
		      If !This.oZip.Zip(m.laDummy(m.lnX), m.lcDestination)
		        This.GiveMessage(This.oZip.cErrorMessage, 48, [Fail!])
		        lnFails = m.lnFails + 1
		      Else
		        If [d] $ This.cOption
		          Erase (m.laDummy(m.lnX))
		          lcText = [moved]
		        Endif
		      Endif
		    Endfor
		
		    This.CutAndGiveMessage(Textmerge([<<m.lnLines - m.lnFails>> files <<m.lcText>> to file <<m.lcDestination >>]), ,;
		        Textmerge([<<this.cProgram>> zip utility]), This.nTimeOut)
		  Else
		    lcDestination = Evl(m.lcDestination, Alltrim(This.cBackupFolder))
		    If This.GetLastCharacter(m.lcDestination) = [?]
		      lcDestination = Strtran(m.lcDestination, [?], This.GetSortableDate())
		    Endif
		    llSuccess = .T.
		    If !Directory(m.lcDestination )
		      Try
		        Md (m.lcDestination )
		      Catch
		        This.GiveMessage([Can't create folder ] + m.lcDestination, 16, [Something went wrong])
		        llSuccess = .F.
		      Endtry
		    Endif
		    If !m.llSuccess
		      Return
		    Endif
		    lnLines = Alines(m.laDummy, m.lcFileList, 0, [,])
		    lnFails = 0
		    For lnX = 1 To m.lnLines
		      Wait Window [Moving ] + m.laDummy(m.lnX) At 10, 25 Time This.nZipDelay
		      Try
		        Rename (m.laDummy(m.lnX)) To Forcepath( m.laDummy(m.lnX), m.lcDestination )
		      Catch
		        This.GiveMessage([Can't move file ] + m.laDummy(m.lnX))
		        lnFails = m.lnFails + 1
		      Endtry
		    Endfor
		    This.CutAndGiveMessage(Textmerge([<<m.lnLines - m.lnFails>> files moved to folder <<m.lcDestination >>]), ,;
		        Textmerge([<<this.cProgram>> move utility]), This.nTimeOut)
		  Endif
		Else
		  This.CutAndGiveMessage([Nothing to do!], , , This.nTimeOut)
		Endif
		Return
		
		
	ENDPROC

	PROCEDURE dropfieldifempty
		Lparameters tcCursor, tcField, tnIndex
		Local Array laDummy[1]
		
		tnIndex = Evl(m.tnIndex, 0)
		If !Empty(Field(m.tcField, m.tcCursor))
		  Select (m.tcCursor)
		  llDrop = .T.
		  Scan 
		    If !Empty(Evaluate(m.tcField))
		      m.llDrop = .F.
		      Exit
		    Endif
		  Endscan
		  If m.llDrop  && m.laDummy = 0
		    Alter Table (m.tcCursor) Drop Column (m.tcField)
		  Else
		    Do Case
		      Case m.tnIndex = 1
		        ExecScript(Textmerge('Index on <<m.tcField>> tag <<m.tcField >>'))  
		      Case m.tnIndex = 2
		        ExecScript(Textmerge('Index on Upper(<<m.tcField>>) tag <<m.tcField >>'))  
		    Endcase
		  Endif
		Endif
		
	ENDPROC

	PROCEDURE editcustomtool
		Local lcCursor, lcDescript, lcFile, lcMessage, lcProg, lcProgFile, lnSelect, lnTools
		If [z] $ This.cOption
		  Set Step On
		Endif
		lcProg = This.cParameter
		If This.cCommand = [!!] And Len(This.cCommand ) > 2
		  lcProg = Substr(This.cCommand, 3)
		Endif
		If !Lower(m.lcProg) = this.cSKFile 
		  lcProg = this.cSKFile + m.lcProg
		Endif
		lcProgFile = Forceext(m.lcProg, [prg])
		If !Empty(m.lcProg) And !m.lcProg == this.cSKFile 
		  If File(m.lcProgFile)
		    Modify Command (m.lcProgFile) Nowait
		  Else
		    This.GiveMessage([File ] + m.lcProgFile + [ is not found!], 0 + 48, [Nothing to do])
		  Endif
		Else
		  lnSelect = Select()
		  lcCursor = [curCustom]
		  lnTools = This.GetFilesInPath([prg], m.lcCursor )
		  Select Cast(Lower(Substr(Juststem(Fname), 4)) As c(30)) As Program, FileSize, Filedate, Cast([] As c(100)) As Descript, Fname;
		    From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where Lower(Left(Juststem(Fname), 3)) = this.cSKFile 
		  If _Tally = 0
		    lcMessage = [No tool matching ] + this.cSKFile + [ found]
		    This.GiveMessage(m.lcMessage, 0 + 48, [No custom tool defined])
		  Else
		    Scan
		      lcFile = Alltrim(Fname)
		      lcDescript = This.GetDescript(m.lcFile )
		      If !Empty( m.lcDescript )
		        Replace Descript With m.lcDescript
		      Endif
		    Endscan
		    Go Top
		    lcProg = This.GetDataFromGrid(Textmerge([My "<<this.cProgram>>" extensions to edit:]), [fname], 1)
		    Use
		    Select (m.lnSelect)
		    If !Empty(m.lcProg)
		      Modify Command (m.lcProg) Nowait
		    Endif
		    If !This.lSKComment
		      This.CutCurrentLine()
		    Endif
		  Endif
		Endif
	ENDPROC

	PROCEDURE findcommand
		If Inlist(This.nWindowType, 0, 1)
		  This.cParcedText = Trim(This.cParcedText, 0, Chr(10), Chr(13))
		  If Getwordnum(This.cParcedText, 1) == This.cCommentString
		    This.cParcedText = Ltrim(Substr(This.cParcedText, Len(This.cCommentString) + 1))
		  Endif
		
		  If Getwordcount(This.cParcedText) = 1 And This.FindValueInString(Getwordnum(This.cParcedText, 1)) = 0
		    Do While Left(This.cParcedText, 1) == [*] And This.nWindowType = 1 And ![:] $ Getwordnum(This.cParcedText, 1)
		      This.cParcedText = Ltrim(Substr(This.cParcedText, 2))
		    Enddo
		  Endif
		  If This.cTitle = This.cSidekickFile
		    Do Case
		      Case Empty(Chrtran(Getwordnum(This.cParcedText, 1), [*], []))  And This.FindValueInString(Getwordnum(This.cParcedText, 2)) > 0
		        This.cParcedText = Strextract(This.cParcedText, [ ], [], 2)
		      Case Getwordcount(This.cParcedText) > 1 And This.FindValueInString(Getwordnum(This.cParcedText, 1)) > 0
		        This.cParcedText = Strextract(This.cParcedText, [ ], [], 1)
		      Otherwise
		    Endcase
		  Endif
		  If Isdigit(Getwordnum(This.cParcedText, 1)) And This.cTitle = This.cSidekickFile
		    This.cParcedText = Ltrim(Substr(This.cParcedText, Len(Getwordnum(This.cParcedText, 1)) + 1))
		  Endif
		EndIf
		lcParced = Lower(this.cParcedText)
		If 'no'$m.lcParced and GetWordNum(m.lcParced,1) # 'no' and ('=no ' $ m.lcParced or '= no' $ m.lcParced)
		  this.cParcedText = 'no ' + GetWordNum(m.lcParced,1,'= ') + '=' + GetWordNum(m.lcParced,3,'= ')
		EndIf
		If m.lcParced == 'ed'
		  this.cParcedText = 'ed *'
		Endif
		
		This.cCommand = Getwordnum(This.cParcedText, 1)
		This.nValCommand = This.FindValueInString(This.cCommand )
		This.cCommand = Trim(This.cCommand, 0, Chr(13), Chr(10))
		
		This.cCommandOriginal = This.cCommand
		This.cCommand = Lower(This.cCommand)
		
	ENDPROC

	PROCEDURE finddiroptions
		Local lcParameter, llSuccess
		
		lcParameter = []
		If This.nWindowType <= 1
		  llSuccess = .T.
		  Do Case
		    Case Inlist(Left(This.cCommand, 3), [+++])
		      lcParameter = Substr(This.cCommand, 4)
		      This.AddOption([e])
		    Case Inlist(Left(This.cCommand, 2), [++])
		      lcParameter = Substr(This.cCommand, 3)
		      This.AddOption([a])
		    Case This.nWindowType = 0 And Inlist(Left(This.cCommand, 1), [+])
		      lcParameter = Substr(This.cCommand, 2)
		    Case Inlist(Left(This.cCommand, 2), [dr])
		      lcParameter = Substr(This.cCommand, 3)
		    Otherwise
		      llSuccess = .F.
		  Endcase
		Endif
		lcParameter = Evl(m.lcParameter, This.cParameter)
		If ! m.llSuccess && Or Val(m.lcParameter) > 0
		  Return .F.
		Else
		  Wait Window 'Wait while Sidekick processes files!' at 10,25 nowait noclear  
		  This.ListFiles(m.lcParameter)
		Endif
		
		
	ENDPROC

	PROCEDURE findedoptions
		Local llSuccess
		
		llSuccess = .T.
		If This.cCommand == [??]
		  This.cCommand = [ed?]
		Endif
		Do Case
		  Case This.nWindowType = 0 And This.cCommand == [ed?] And [w] $ This.cOption
		    Use (This.cMRUTable) In Select(This.cMRUTable)
		    Select (This.cMRUTable)
		    This.DoBrow([W])
		    Use In Select(This.cMRUTable)
		  Case This.nWindowType > 0 And This.cCommand == [ed+] Or (This.cCommand == [ed] And This.cParameter == [+])
		    This.HandleMRUTable([Add])
		  Case This.nWindowType > 0 And This.cCommand == [ed-] Or (This.cCommand == [ed] And This.cParameter == [-])
		    This.HandleMRUTable([Delete])
		  Case This.cCommand == [ed?] Or (This.cCommand == [ed] And [?] $ This.cParameter)
		    If [?] $ This.cParameter
		      This.cParameter = Chrtran(This.cParameter, [?], [])
		    Endif
		    This.HandleMRUTable([List])
		  Case This.cCommand == [ed] And !Empty(This.cParameter) And This.cParameter # [0] And Val(This.cParameter) = 0
		    If This.cParameter # [*]
		      This.AddOption([a])
		    Endif
		    This.ListFiles(This.cParameter)
		  Case This.cCommand == [ed] And (Empty(This.cParameter) Or This.cParameter == [*])
		    *!*      this.AddOption('a')
		    This.ListFiles([*])
		  Case This.cCommand == [ed] And This.cParameter = Transform(Val(This.cParameter))
		    If This.cParameter = [0]
		      Modify Command (This.cSidekickFile ) Nowait
		    Else
		      This.GetLinesToProcess(Val(This.cParameter))
		    Endif
		  Otherwise
		    llSuccess = .F.
		Endcase
		Return m.llSuccess
	ENDPROC

	PROCEDURE findfile
		Lparameters tcFile, tcFilter
		Local lcFile, lcPath, lcReturn, lnFiles, lnX
		
		Local Array laFiles[1]
		
		If Empty(m.tcFilter)
		  tcFilter = ['dbf','vcx','scx','prg','txt','sk']
		Endif
		lcPath = Justpath(m.tcFile)
		lcFile = []
		lcReturn = []
		Do Case
		  Case Adir(laFiles, m.tcFile) = 1
		    lcFile = m.tcFile
		  Case !Empty(m.lcPath)
		    If Empty(Justext(m.tcFile))
		      lnFiles = Adir(laFiles, Forceext(m.tcFile, [*]))
		      If m.lnFiles > 1
		        For lnX = 1 To m.lnFiles
		          If Inlist(Lower(Justext(m.laFiles(m.lnX, 1))),&tcFilter)
		            lcFile = m.laFiles(m.lnX, 1)
		            Exit
		          Endif
		        Endfor
		      Endif
		    Else
		    Endif
		  Otherwise
		    Wait Window [some other case... Must be handled]
		Endcase
		If !Empty(m.lcFile)
		*!*    lcReturn = Fullpath(Forcepath(m.lcFile, m.lcPath))
		  lcReturn = this.FixPath(m.lcFile)
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE findfunction
		Local lcParameter
		
		If _Screen.lTest &&or .t.
		  Set Step On
		Endif
		*!*  If Empty(this.cCommand)
		*!*    lcCommand = InputBox('Type command:','Sidekick', this.cDefaultCommand ,0,'','<>')
		*!*    If m.lcCommand = '<>' && Cancel
		*!*      Return
		*!*    Else 
		*!*      this.cCommand = Alltrim(Lower(m.lcCommand))
		*!*    Endif
		*!*  Endif
		Do Case
		  Case This.FindSKOptions()
		  Case Left(This.cCommand, 1) = [*] And This.nValCommand > 0 And Empty(This.cParameter)
		    This.CreateCommentLine()
		  Case Left(This.cCommand, 1) = [*] And Val(This.cParameter) > 0 And This.cParameter == Transform(This.cParameter)
		    This.cCommand = This.cCommand + This.cParameter
		    This.cParameter = []
		    This.CreateCommentLine()
		  Case File([sk_] + This.cCommand + [.prg])
		    lcProg = [sk_] + This.cCommand
		    If Empty(this.cParameter)
		      Do (m.lcProg)
		    Else
		      Do (m.lcProg) with this.cParameter 
		    Endif
		  Case This.FindDirOptions()
		  Case This.FindEdOptions()
		  Case Inlist(This.cCommand, [th], [thor], [tool], [tools])
		    This.BrowseAllTools()
		  Case Inlist(This.cCommand, [hotkeys], [hk])
		    This.BrowseHotKeys()
		  Case Left(This.cCommand, 4) = [http]
		    This.RunEd(This.cParcedText)
		  Case Left(This.cParameter, 4) = [http]
		    This.RunEd(This.cParameterOriginal )
		  Case Inlist(This.cCommand, [ver], [version])
		    This.CutAndGiveMessage([Version: ] + This.cVersion, 64, This.cProgram )
		  Case Inlist(This.cCommand, [desc], [description], [descript], [de])
		    This.HandleDescription()
		  Case This.cCommand = [--] Or This.cCommand = [tidy]
		    This.lTidy = .T.
		    This.DoZip()
		  Case Inlist(This.cCommand, [menu]) ;
		      Or (This.nWindowType > 0 And This.cCommand == [ed] And Empty(This.cParameter));
		      Or (This.cCommand == [?] And Empty(This.cParameter))
		    This.CreateSidekickCursor()
		  Case This.cCommand = [zip]
		    This.DoZip()
		  Case This.cCommand = [unzip]
		    This.DoUnzip()
		  Case This.cCommand = [help]
		    This.RunEd(This.cSidekickHelp )
		  Case This.cCommand == [mf]
		    This.ModifyForm()
		  Case This.cCommand == [no]
		    This.CreateNo()
		  Case This.cCommand == [ec] And [C] = Vartype(This.cClip )
		    This.TryExecScript()
		  Case Left(This.cCommand, 2) == [?=] And (Len(This.cCommand) > 2 Or !Empty(This.cParameter ))
		    This.CreateQmark()
		  Case Left(This.cCommand, 2) == [db] And (Len(This.cCommand) > 2 Or !Empty(This.cParameter ))
		    This.CreateQmark(.T.)
		  Case This.cCommand == [es]
		    This.CreateES()
		  Case Inlist(This.cCommand, [path], [pa])
		    This.ShowCurrentPath()
		
		  Case This.cCommand == [us] Or (This.cCommand == [use] And This.nWindowType = 0)
		    This.CreateUseSyntax()
		  Case This.cCommand == [lo]
		    This.ListOpenTables()
		  Case This.cCommand == [sf]
		    This.CreateUseSyntax()
		  Case This.cCommand == [cl]
		    This.AddOption([c])
		    This.CreateUseSyntax()
		  Case This.nWindowType > 0 And (Inlist(This.cCommand, [insert], [ins]) Or This.cCommand = [+])
		    This.InsertMethod()
		  Case Inlist(This.cCommand, [=], [eval])
		    This.InsertResult()
		  Case Inlist(This.cCommand, [hk], [hotkeys])
		    This.BrowseHotKeys()
		  Case Inlist(This.cCommand, [th], [thor], [tools], [tool])
		    This.BrowseAllTools()
		  Case This.cCommand = [!!] Or This.cCommand == [sked]
		    This.EditCustomTool()
		  Case (This.cCommand = [!] Or This.cCommand == [sk]) And Left(This.cParcedText, 1) # [*]
		    This.ListAllCustomTools()
		  Case Inlist(This.cCommand, [.], [,], [ta], [test])
		    This.MakeSKTestArea()
		  Case This.cCommand == [0] And Empty(This.cParameter)
		    This.CutCurrentLine()
		    Modify Command (This.cSidekickFile ) Nowait
		  Case This.cCommand == [0?]  Or (This.cCommand == [0] And This.cParameter = [?])
		    This.CutAndGiveMessage(Textmerge([Active "<<this.cProgram>>" file is <<this.cSidekickFile>>]), 64, This.cProgram )
		  Case This.cCommand == [0*] Or This.cCommand == [**] Or (This.cCommand = [0] And Inlist(This.cParameter, [*], [-], [+], [/]))
		    This.ChangeSidekickFile()
		  Case Inlist(This.cCommand, [*], [pr], [proj], [project]) And This.nWindowType = 0
		    This.ListProjects()
		  Case This.cCommand == [0] And Getwordnum(This.cParameter, 1) # This.cRun
		    This.ChangeSidekickFile()
		  Case This.nWindowType > 0;
		      And (This.cCommand = [#];
		        Or Left(This.cCommand, 4) = [#inc];
		        Or Left(This.cCommand, 3) = [inc])
		    This.GetHeader()
		  Case This.cCommand == [br] And !Empty(Dbf())
		    This.DoBrow()
		    *!*      This.GetDataFromGrid(Dbf(), [Field(1)], ,.F.)
		  Case This.cCommand = [be]
		    This.CreateBindEvent()
		  Case This.cCommand = [rt]
		    This.MakeRandowText()
		  Case Inlist(This.cCommand, [lor], [lorem])
		    This.MakeLoremText()
		  Case This.cCommand = [fp]
		    This.MakeFieldPicker()
		  Case This.cCommand == [-] And This.nWindowType = 0
		    This.ProcessSidekickFile()
		  Case Isdigit(This.cCommand) And This.cCommand = Transform(Val(This.cCommand )) And Empty(This.cParameter ) And This.nWindowType = 0
		    This.GetLinesToProcess(Val(This.cCommand))
		  Case Isdigit(This.cCommand ) And This.cCommand = Transform(Val(This.cCommand )) And !Empty(This.cParameter ) And Inlist(This.nWindowType, 1, 2)
		    This.RunEd(This.cParameter)
		  Case This.cCommand = [dd] And This.nWindowType = 10
		    This.MakeDoDefault()
		  Case Isdigit(This.cCommand ) And This.cCommand = Transform(Val( This.cCommand )) And !Empty( This.cParameter) ;
		      And Inlist(Getwordnum( This.cParameter, 1), [do], This.cRun ) And  Inlist(This.nWindowType, 1, 2)
		    If Getwordnum(This.cParameter, 1) = This.cRun
		      lcParameter = Strextract(This.cParameter, This.cRun, [])
		    Else
		      lcParameter = This.cParameter
		    Endif
		    If This.TryExecute( )
		      Return
		    Endif
		  Case Left(This.cCommand, 1) = [*] And Isdigit(Substr(This.cCommand, 2, 1)) And Getwordnum(This.cParameter, 1) = This.cRun
		    Try
		      Execscript(Substr(This.cParameter, 4))
		    Catch
		      This.ReturnUnknownCommand()
		    Endtry
		  Case Left(This.cParcedText, 1) = [*] And Isdigit(Getwordnum(This.cParameter, 1)) And Getwordnum(This.cParameter, 2) = This.cRun
		    Try
		      Execscript(Substr(This.cParameter, Len(Getwordnum( This.cParameter, 1)) + 6))
		    Catch
		      This.ReturnUnknownCommand()
		    Endtry
		  Otherwise
		
		    Try
		      Execscript(This.cParcedText)
		    Catch
		      Wait Window [Nothing to do!] At 10, 25
		    Endtry
		Endcase
	ENDPROC

	PROCEDURE findparameters
		If InList(this.cCommand,'eval','=')
		  Return
		Endif
		This.cParameter = Ltrim(Strextract(this.cParcedText , this.cCommand , [], 1, 1))
		If At([&] + [&], This.cParameter) > 0
		  This.cParameter = Trim(Strextract(This.cParameter, [], [&] + [&]))
		Endif
		If Left(This.cParameter, 1) = [(]
		  This.cParameter = Lower(This.FindFile(Evaluate(This.cParameter)))
		Endif
		this.cParameterOriginal = Trim(this.cParameter,0, Chr(13), Chr(0))
		this.cParameterOriginal = Chrtran(this.cParameterOriginal,'|',' ')
		this.cParameter = Lower(this.cParameterOriginal)
		
		
	ENDPROC

	PROCEDURE findskoptions
		If Inlist(This.nWindowType, 1, 2) And Lower(Justext(This.cTitle)) = [sk]
		  Do Case
		    Case Isdigit(This.cCommand ) And This.cCommand = Transform(Val(This.cCommand )) And !Empty(This.cParameter )
		      This.RunEd(This.cParameter)
		    Case this.cCommand = this.cCommentString and Isdigit(This.cParameter ) And This.cParameter = Transform(Val(This.cParameter)) And GetWordCount(This.cParameter )>1
		      This.RunEd(StrExtract( This.cParameter,' ','',1))
		    Case .F.
		    Otherwise
		      Return .F.
		  EndCase
		Else 
		  Return .f.  
		Endif
	ENDPROC

	PROCEDURE findswitch
		#define ccDummy ''
		this.cParcedText = Strtran(this.cParcedText,'//',ccDummy)
		lnX = 1
		Do while .t.
		  lnPos = At('/', this.cParcedText ,m.lnX )
		  If lnPos > 0
		    lcCharacter = Substr(this.cParcedText,m.lnPos+1,1 )
		    Do case
		      Case Empty(m.lcCharacter)
		        exit 
		      Case IsAlpha(m.lcCharacter) 
		        If InList(Substr(this.cParcedText,m.lnPos +2,1), ' ','/') or Len(this.cParcedText)=m.lnPos + 1
		          this.AddOption(m.lcCharacter)
		          this.cParcedText = Strtran(this.cParcedText ,'/'+m.lcCharacter,'')
		        Else 
		          m.lnX = m.lnX + 1 
		        Endif
		      case m.lcCharacter == '-'
		        If InList(Substr(this.cParcedText,m.lnPos +3,1), ' ','/') or Len(this.cParcedText)=m.lnPos + 2
		          m.lcCharacter = Substr(this.cParcedText,m.lnPos+2,1 )
		          this.AddOption('-' + m.lcCharacter)
		          this.cParcedText = Strtran(this.cParcedText,'/-'+m.lcCharacter,'')
		        Else 
		          m.lnX = m.lnX + 1 
		        Endif
		    EndCase 
		  Else 
		    exit
		  Endif
		EndDo
		this.cParcedText = Strtran(this.cParcedText ,ccDummy,'//')
		
		
	ENDPROC

	PROCEDURE findvalueinstring
		Lparameters tcText
		Local lnReturn, lnX
		
		lnReturn = 0
		For lnX = 1 To Len(Trim(m.tcText))
		  If Val(Substr(m.tcText, m.lnX, 1)) > 0
		    lnReturn = Val(Substr(m.tcText, m.lnX))
		    Exit
		  Endif
		Endfor
		Return Int(m.lnReturn)
		
		
	ENDPROC

	PROCEDURE fixpath
		Lparameters tcFile
		Do Case
		  Case [f] $ This.cOption
		    tcFile = Fullpath(m.tcFile)
		  Case [j] $ This.cOption
		    tcFile = Justfname( m.tcFile)
		  Case [r] $ This.cOption or This.cPathReturned = [r] && relative
		    tcFile = Sys(2014, m.tcFile)
		  Case This.cPathReturned = [f] && full
		    tcFile = Fullpath(m.tcFile)
		  Otherwise && no path
		    tcFile = Justfname(m.tcFile)
		Endcase
		Return m.tcFile
	ENDPROC

	PROCEDURE getadditionalfiles
		Lparameters tcSource
		Local lcExtension, lnX
		
		Local Array laDummy[1]
		This.GetExtensionCursor()
		lcExtension = Lower(Justext(m.tcSource))
		This.cExtensionList = m.lcExtension
		
		If  !This.lAddExtraExtensions
		  Select ext1, extra From curExtensions Where ext2 = m.lcExtension And !extra Into Array laDummy
		Else
		  Select ext1, extra From curExtensions Where ext2 = m.lcExtension Into Array laDummy
		Endif
		If _Tally > 0
		  lcExtension = m.laDummy
		  This.cExtensionList = This.AddExtension(This.cExtensionList, m.lcExtension, m.tcSource  )
		Endif
		Select ext2 From curExtensions Where ext1 = m.lcExtension And !extra Into Array laDummy
		If _Tally > 0
		  For lnX = 1 To Alen(m.laDummy, 1)
		    This.cExtensionList = This.AddExtension(This.cExtensionList, m.laDummy(m.lnX), m.tcSource )
		  Endfor
		Endif
		Select ext2 From curExtensions Where ext1 = m.lcExtension And extra = This.lAddExtraExtensions Into Array laDummy
		If _Tally > 0
		  For lnX = 1 To Alen(m.laDummy, 1)
		    This.cExtensionList = This.AddExtension(This.cExtensionList, m.laDummy(m.lnX) ,m.tcSource )
		  Endfor
		EndIf
		
		Return this.cExtensionList  
		
	ENDPROC

	PROCEDURE getallfiles
		Lparameters tcDirectory, laFiles, tcMask
		
		Local lcFile, lcOldDir, lnCount, lnLen, lnMax
		
		Local Array laTemp[1, 5]
		m.tcMask = Evl(m.tcMask,'*.*')
		lcOldDir = Fullpath(Curdir())
		 
		If Empty(m.tcDirectory)
		  tcDirectory = m.lcOldDir
		Endif
		Set Default To (m.tcDirectory)
		= Adir(laTemp, [*.*], [AHRSD], 1)
		lnMax = Alen(m.laTemp, 1)
		For lnCount = 1 To m.lnMax
		  lcFile = Alltrim(m.laTemp(m.lnCount, 1))
		  If !(m.lcFile == [.]) And !(m.lcFile == [..])
		    If [D] $ m.laTemp(m.lnCount, 5)
		      this.GetAllFiles(Addbs(m.tcDirectory + m.lcFile), @m.laFiles)
		    Else
		      lnLen = Alen(m.laFiles)
		      If !Empty(m.laFiles(m.lnLen))
		        Dimension m.laFiles(m.lnLen + 1)
		        lnLen = m.lnLen + 1
		      Endif
		      laFiles(m.lnLen) = m.tcDirectory + m.lcFile
		    Endif
		  Endif
		Endfor
		Set Default To (m.lcOldDir)
		Return Alen(m.laFiles, 1)
		
		
	ENDPROC

	PROCEDURE getdatafromgrid
		Lparameters tcCaption, tcReturnField, tnHideColumns, tlModeless, tcPGParameter
		Local loPg As pg Of pg.vcx
		Local lcCurrent, lcF3, lcF4, lcF5, lcFilter, lcHideColumns, lcParameter, lcProcess, lcReturn
		Local lnModeless
		
		tcCaption = Evl(m.tcCaption, [Testing])
		tcReturnField = Evl(m.tcReturnField, Field(1))
		tnHideColumns = Evl(m.tnHideColumns, 0)
		lnModeless = Iif(Empty(m.tlModeless), 1, 2)
		tcPGParameter = Evl(m.tcPGParameter, [])
		lcReturn = []
		If !Empty(Dbf())
		  If Reccount() = 1
		    If Vartype(Evaluate(m.tcReturnField)) = [N]
		      lcReturn = Trans(Evaluate(m.tcReturnField))
		    Else
		      lcReturn = Alltrim(Evaluate(m.tcReturnField))
		    Endif
		    Return m.lcReturn
		  Else
		
		    lcHideColumns = Replicate([L], Evl(m.tnHideColumns, 0))
		    lcParameter = [1U] + m.lcHideColumns + m.tcPGParameter
		    lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		    loPg = Newobject([pg], m.lcProcess, [], m.lcParameter)
		    loPg.FontSize = This.nFontSize
		    loPg.Caption = Alltrim(m.tcCaption)
		    loPg.nIncStart = 0
		    loPg.lShowZero = .F.
		    loPg.Icon = Home(4) + [icons\misc\face02.ico]
		    Push Key
		    If !Empty(Field([url]))
		      Declare Integer ShellExecute In shell32.Dll ;
		        Integer hndWin, String cAction, String cFileName, ;
		        String cParams, String cDir, Integer nShowWin
		      On Key Label CTRL+Enter ShellExecute(0, [open], url, [], [], 1)
		    Endif
		    Do Case
		      Case !Empty(This.cFilter) And Lower(This.cFilter) = [include]
		        loPg.Caption = [Select File(s) for processing. Ctrl+Space = select, F3 = select all, F4 = undo all, F5 = reverse]
		        lcFilter = Trim(This.cFilter)
		        Text To m.lcF3 Noshow Textmerge Pretext 1 + 2 + 4
		          lnRecno = Recno()
		          try
		            Replace all <<m.lcFilter>> with .t.
		          Catch
		          endtry
		          Go lnRecno
		        Endtext
		        Text To m.lcF4 Noshow Textmerge Pretext 1 + 2 + 4
		          lnRecno = Recno()
		          try
		            Replace all <<m.lcFilter>> with .f.
		          Catch
		          endtry
		          Go lnRecno
		        Endtext
		        Text To m.lcF5 Noshow Textmerge Pretext 1 + 2 + 4
		          lnRecno = Recno()
		          try
		            Replace all <<m.lcFilter>> with !<<m.lcFilter >>
		          Catch
		          endtry
		          Go lnRecno
		        Endtext
		        On Key Label F2 Replace (m.lcFilter) With !(Evaluate(m.lcFilter))
		        On Key Label CTRL+Spacebar Replace (m.lcFilter) With !(Evaluate(m.lcFilter))
		        On Key Label F3 Execscript(m.lcF3)
		        On Key Label F4 Execscript(m.lcF4)
		        On Key Label F5 Execscript(m.lcF5)
		        *!*        Case this.cCommand == 'lu'
		        *!*          On Key Label 
		    Endcase
		    *!*      Set Step On 
		    m.loPg.Show(m.lnModeless )
		    If m.lnModeless = 2
		      Read Events
		    Endif
		    Pop Key
		    If Lastkey() = 27 And ! This.lNoMessage  && Escape
		      lcReturn = []
		      This.GiveMessage([Nothing selected!], , , This.nTimeOut)
		    Else
		      If !Inlist(Lastkey(), 97, 33) And !Empty(m.tcReturnField)
		        If !Empty(This.cFilter)
		          lcCurrent = Trim(Evaluate(m.tcReturnField))
		          Scan For Evaluate(This.cFilter)
		            lcReturn = m.lcReturn + Trim(Evaluate(m.tcReturnField)) + [,]
		          Endscan
		          If !Empty(m.lcReturn)
		            lcReturn = Trim(m.lcReturn, [,])
		          Else
		            lcReturn = m.lcCurrent
		          Endif
		        Endif
		        If Empty(m.lcReturn)
		          If Vartype(Evaluate(m.tcReturnField)) = [N]
		            lcReturn = Trans(Evaluate(m.tcReturnField))
		          Else
		            lcReturn = Alltrim(Evaluate(m.tcReturnField))
		          Endif
		        Endif
		      Endif
		    Endif
		  Endif
		Else
		  This.GiveMessage( [No table or cursor is selected], 0 + 48, [Sidekick grid])
		Endif
		Return Alltrim( m.lcReturn)
		
		
	ENDPROC

	PROCEDURE getdatafromurl
		Lparameters tcUrlName
		Local lcRetVal, lhInternetSession, lhUrlFile, llOk, lnBytesRead, lnOK, lsAgent, lsReadBuffer
		
		Declare Integer InternetOpen In wininet.Dll String sAgent, ;
		  Integer lAccessType, String sProxyName, ;
		  String sProxyBypass, Integer lFlags
		Declare Integer InternetOpenUrl In wininet.Dll ;
		  Integer hInternetSession, String sUrl, String sHeaders,;
		  Integer lHeadersLength, Integer lFlags, Integer lContext
		Declare Integer InternetReadFile In wininet.Dll Integer hfile, ;
		  String @sBuffer, Integer lNumberofBytesToRead, Integer @lBytesRead
		Declare short InternetCloseHandle In wininet.Dll Integer hInst
		#Define INTERNET_OPEN_TYPE_PRECONFIG 0
		#Define INTERNET_OPEN_TYPE_DIRECT 1
		#Define INTERNET_OPEN_TYPE_PROXY 3
		#Define SYNCHRONOUS 0
		#Define INTERNET_FLAG_RELOAD 2147483648
		#Define CR Chr(13)
		* what application is using Internet services?
		lsAgent = [VPF 5.0]
		lhInternetSession = InternetOpen( m.lsAgent, INTERNET_OPEN_TYPE_PRECONFIG, ;
		    [], [], SYNCHRONOUS)
		* debugging line - uncomment to see session handle
		* WAIT WINDOW "Internet session handle: " + LTRIM(STR(hInternetSession)) 
		If m.lhInternetSession = 0
		  Wait Window [Internet session cannot be established] Time 2
		  Return .Null.
		Endif
		lhUrlFile = InternetOpenUrl( m.lhInternetSession, m.tcUrlName, [], 0, ;
		    INTERNET_FLAG_RELOAD, 0)
		* debugging line - uncomment to see URL handle 
		* WAIT WINDOW "URL Handle: " + LTRIM(STR(hUrlFile))
		If m.lhUrlFile = 0
		  Wait Window [URL cannot be opened] Timeout 5
		  Return .Null.
		Endif
		lcRetVal = []
		llOk = .T.
		Do While m.llOk
		  * set aside a big buffer
		  lsReadBuffer = Space(32767)
		  lnBytesRead = 0
		  lnOK = InternetReadFile( m.lhUrlFile, @m.lsReadBuffer, Len(m.lsReadBuffer), @m.lnBytesRead)
		  If ( m.lnBytesRead > 0 )
		    lcRetVal = m.lcRetVal + Left( m.lsReadBuffer, m.lnBytesRead )
		  Endif
		  * error trap - either a read failure or read past eof()
		  llOk = ( m.lnOK = 1 ) And ( m.lnBytesRead > 0 )
		Enddo
		* close all the handles we opened
		InternetCloseHandle( m.lhUrlFile )
		InternetCloseHandle( m.lhInternetSession )
		* return the URL contents
		Return m.lcRetVal
		
		
	ENDPROC

	PROCEDURE getdescript
		Lparameters tcFile
		Local lcContents, lcDescript, lnHandle, lnX1
		lnHandle = Fopen(m.tcFile )
		lcDescript = []
		For lnX1 = 1 To this.nMaxDescriptLine 
		  lcContents = Fgets(m.lnHandle)
		  If Occurs(this.cDescriptionMask1 , m.lcContents) > 0
		    lcDescript = Alltrim(Strextract(m.lcContents, this.cDescriptionMask1 , this.cDescriptionMask2 ))
		    Exit
		  Endif
		Endfor
		Fclose(m.lnHandle)
		Return m.lcDescript
	ENDPROC

	PROCEDURE geteditsourcecode
		Lparameters tnHandle, tnEdType, tcPrefix
		Local lcClassName, lcFilename, lcMethod, lcName, lcObject, lcObjectPath, lcReturn, lcType, llTest
		Local lnHandle, lnLineNo, lnWindowType, loE, loFile, loObject, loTools
		#define crlf Chr(13)+Chr(10)
		tcPrefix = Evl(m.tcPrefix, [])
		tnHandle = Evl(m.tnHandle, Val(_Cliptext))
		Store [] To m.lcMethod, m.lcObjectPath, m.lcClassName
		Store 0 To m.lnLineNo, m.lnHandle
		llTest = Pemstatus(_Screen, [lTest], 5) And _Screen.lTest
		loE = Execscript(_Screen.cThorDispatcher, [Thor_Proc_EditorWin])
		m.loE.SelectWindow(m.tnHandle)
		lnWindowType = m.loE.FindWindow()
		loTools = Execscript (_Screen.cThorDispatcher, [class= tools from pemeditor])
		loObject = m.loTools.GetCurrentObject(.F.)
		If m.lnWindowType > 0
		  lnLineNo = m.loE.GetLineNumber() + 1
		Endif
		loFile = m.loTools.GetCurrentFileName()
		If Vartype(m.loFile) = [L] And .F. && Now, what was this for? :-)
		  Wait Window At 10, 25 [warning]
		  Return []
		Endif
		lnHandle = m.loE.nHandle
		lnVersion = 0
		Do Case
		  Case m.lnWindowType = 0
		    Wait Window ccCanNotUse Timeout 2
		    Return
		  Case Inlist(m.lnWindowType, 1, 2) && Program or file
		    lcFilename = Fullpath(m.loE.GetTitle())
		    If  Left(m.lcFilename, 7) = [PROGRAM] And Empty(Justext(m.lcFilename)) && Modi Comm, not saved
		      Return
		    EndIf
		    m.lcFilename = this.FixPath(m.lcFilename)
		  Otherwise && Method
		    loObject = m.loTools.GetThis()
		    lcObject = [loObject]
		    m.lcFilename = this.FixPath(m.loFile.Filename)
		    If m.lnHandle > 0
		      lcMethod = m.loE.GetTitle()
		    Endif
		    Do While .T.
		      If Inlist(Type(m.lcObject), [U], [L])
		        Exit
		      EndIf
		      If Lower(JustExt(m.lcFilename)) = 'vcx' and Evaluate(m.lcobject+'.parent.baseclass') = 'Form' And Evaluate(m.lcobject+'.parent.parent.baseclass') = [Formset]
		        If PemStatus(Evaluate(m.lcobject + '.parent'),'buffermode',5) && vcx form
		          m.lnVersion = 1
		          m.lcClassName = Evaluate(m.lcObject + '.parent.name')
		        Else && vcx container
		          m.lnVersion = 2
		          m.lcClassName = Evaluate(m.lcObject + '.name')
		        Endif
		        Exit
		      Endif
		      lcName = Evaluate(m.lcObject + [.name])
		      If Empty(m.lcMethod)
		        lcMethod = m.lcName
		      Endif
		      If Empty(m.lcObjectPath)
		        lcObjectPath = m.lcName
		      Else
		        lcObjectPath = m.lcName + [.] + m.lcObjectPath
		      Endif
		      lcObject = m.lcObject + [.parent]
		      If Type(m.lcObject + [.parent]) = [U]
		        Exit
		      Endif
		    EndDo
		    If Empty(m.lcClassName)
		      lcClassName = Strextract(m.lcObjectPath, [], [.])
		      lcClassName = Evl(m.lcClassName, m.lcObjectPath)
		    Endif
		    If [.] $ m.lcObjectPath and m.lnVersion # 2
		      lcObjectPath = Strextract(m.lcObjectPath, [.]) && remove first element which is the classname
		    Endif
		Endcase
		Do Case
		  Case Empty(m.lcMethod) And !Inlist(m.lnWindowType, 1, 2)
		    lcReturn = []
		  Case Inlist(Lower(Justext(m.lcFilename)), [txt], [h])
		    lcReturn = Textmerge([<<m.tcPrefix >><<m.lcFilename >>])
		  Case Inlist(m.tnEdType, 2, 4) && Ed or no Ed
		    If m.tnEdType = 4
		      lcType = []
		      If [ ] $ m.lcFilename
		        lcFilename = ['] + m.lcFilename + [']
		      Endif
		    Else
		      lcType = [Ed ]
		    Endif
		    If Occurs([.], m.lcObjectPath) = 0 && Object directly on form
		      lcObjectPath = Juststem(m.lcObjectPath)
		    Endif
		    If !Empty(m.lcObjectPath)
		      If m.lcClassName # m.lcObjectPath
		        lcObjectPath = m.lcClassName + [.] + m.lcObjectPath
		      Endif
		      If [.] $ m.lcMethod && and m.loObject.baseclass = 'Form'
		        lcMethod = Justext(m.lcMethod)
		      Endif
		      Text To m.lcReturn Noshow Textmerge Pretext 1 + 2 + 4
		      <<m.tcPrefix>><<m.lcType >><<m.lcFilename >>.<<m.lcObjectPath >>.<<m.lcMethod>>
		      Endtext
		    Else
		      lcReturn = m.tcPrefix + m.lcType + m.lcFilename
		        If !Empty(m.lcMethod)
		          m.lcReturn = m.lcReturn + '.' + m.lcMethod 
		        Endif
		    Endif
		    If m.lnLineNo > 0
		      lcReturn = m.lcReturn + [:] + Transform(m.lnLineNo)
		    Endif
		  Case m.tnEdType = 1 && EditSource
		    If !Empty(m.lcMethod) And !Empty(m.lcObjectPath ) And m.lcClassName # m.lcObjectPath
		      lcMethod = m.lcObjectPath + [.] + Justext(m.lcMethod )
		    Endif
		    Text To m.lcReturn Noshow Textmerge Pretext 1 + 2 + 4
		      EditSource('<<m.lcFilename>>', <<m.lnLineNo >>,'<<m.lcClassName>>','<<m.lcMethod>>')
		    Endtext
		  Case m.tnEdType = 3 && EditSourceX
		    If !Empty(m.lcMethod) And !Empty(m.lcObjectPath )
		      lcMethod = m.lcObjectPath + [.] + Justext(m.lcMethod )
		    Endif
		    Text To m.lcReturn Noshow Textmerge Pretext 1 + 2 + 4
		      EditSourceX('<<m.lcFilename>>', '<<m.lcClassName>>','<<m.lcMethod>>',<<m.lnLineNo >>)
		    EndText
		  Otherwise && File|class|method|lineno
		    Text To m.lcReturn  Noshow Textmerge Pretext 1+2+4
		      <<m.lcFilename >> <<m.lcClassName >> <<m.lcMethod >> <<m.lnLineNo >>
		    EndText  
		Endcase
		Return Alltrim(m.lcReturn)
		
		
	ENDPROC

	PROCEDURE getextensioncursor
		Local lcExtensions, lnLines, lnSelect, lnX
		
		Local Array laDummy[1]
		
		If Select([curextensions]) = 0
		  Text To m.lcExtensions Noshow Textmerge Pretext 1 + 2 + 4
		  dbf | cdx |
		  dbf | fpt |
		  scx | sct |
		  vcx | vct |
		  pjx | pjt |
		  lbx | lbt |
		  frx | frt |
		  dbc | dct |
		  dbc | dcx |
		  mnx | mnt |
		  qpr | qpx | *
		  spr | spx | *
		  mpr | mpx | *
		  dbf | db2 | *
		  vcx | vc2 | *
		  scx | sc2 | *
		  lbx | lb2 | *
		  frx | fr2 | *
		  pjx | pj2 | *
		  dbc | dc2 | *
		  mnx | mn2 | *
		  prg | fxp | *
		  prg | err | *
		  prg | bak | *
		  Endtext
		  lnSelect = Select()
		  Select 0
		  Create Cursor curExtensions (ext1 c(3), ext2 c(3), extra l)
		  lnLines = Alines(laDummy, m.lcExtensions, 1 + 4)
		  For lnX = 1 To m.lnLines
		    Insert Into curExtensions (ext1, ext2, extra) Values (;
		        Alltrim(Lower(Getwordnum(m.laDummy(m.lnX), 1, [|]))),;
		        Alltrim(Lower(Getwordnum(m.laDummy(m.lnX), 2, [|]))),;
		        !Empty(Alltrim(Getwordnum(m.laDummy(m.lnX), 3, [|]))))
		  Endfor
		  Select (m.lnSelect)
		Endif
		
	ENDPROC

	PROCEDURE getfieldcount
		Lparameters tcFileDBF
		If Lower(Justext(m.tcFileDBF)) = [dbf]
		  lnArea = Select(1)
		  Use (m.tcFileDBF) Again In (m.lnArea ) 
		  lnFields = Fcount(m.lnArea)
		  Use in (m.lnArea)
		Else 
		  m.lnFields = 0
		EndIf
		Return m.lnFields 
		
	ENDPROC

	PROCEDURE getfilelisttoprocess		&& Pass a comma delimited file list, return list with corresponding files added. Pass .T: to include secondary files (.bak, .err e.t.c.)
		Lparameters tcFiles
		
		Local lcFile, lcFileList, lcMoreExtensions, lnX, lnY
		lcFileList = []
		
		For lnX = 1 To Getwordcount(m.tcFiles, [,])
		  lcMoreExtensions = []
		  lcFile = Getwordnum(m.tcFiles, m.lnX, [,])
		  If ADir(lDummy,m.lcFile ) = 0
		    this.GiveMessage( m.lcFile + [ is not found!], 48, [Wrong name?])
		    Loop
		  Else
		    lcMoreExtensions = This.GetAdditionalFiles(m.lcFile)
		  EndIf
		  If !Getwordnum(m.tcFiles, m.lnX, [,])$m.lcFileList 
		    lcFileList = m.lcFileList + Getwordnum(m.tcFiles, m.lnX, [,]) + [,]
		  Endif
		  If !Empty(m.lcMoreExtensions)
		    For lnY = 1 To Getwordcount(m.lcMoreExtensions, [,])
		      lcNew = Forceext(m.lcFile, Getwordnum(m.lcMoreExtensions, m.lnY, [,]))
		      If !m.lcNew $ m.lcFileList 
		        lcFileList = m.lcFileList + m.lcNew  + [,]
		      Endif
		    Endfor
		    lcFileList = Rtrim(m.lcFileList, 0, [,])
		  EndIf
		  If Right(m.lcFileList,1) # ','
		    m.lcFileList = m.lcFileList + ','
		  Endif
		Endfor
		lcFileList = Trim(m.lcFileList, 0, [,])
		Return m.lcFileList
		
	ENDPROC

	PROCEDURE getfilesinpath
		Lparameters tcMask, tcCursor
		Local lcFileSkel, ldDate, lnFiles, lnFolders, lnRecords, lnSelect, lnSize, lnX, lnX2
		
		Local Array laDummy[1]
		Local Array laFolders[1]
		lnSelect = Select()
		tcCursor = Evl(m.tcCursor, this.cCursor) && [curFiles])
		Select 0
		Create Cursor (m.tcCursor) (Fname c(240), Filedate D, FileSize i)
		tcMask = Evl(m.tcMask, [prg])
		lnFolders = Alines(laFolders, Set([Path]), 1 + 4, [;], [,])
		For lnX = 0 To m.lnFolders
		  If m.lnX = 0
		    lcFileSkel = [*.] + m.tcMask
		  Else
		    lcFileSkel = Alltrim(m.laFolders(m.lnX)) + [\*.] + m.tcMask
		  Endif
		  lnFiles = Adir(laDummy, m.lcFileSkel)
		  If m.lnFiles > 0
		    For lnX2 = 1 To m.lnFiles
		      lnSize = m.laDummy(m.lnX2, 2)
		      ldDate = m.laDummy(m.lnX2, 3)
		      If m.lnX = 0
		        Insert Into (m.tcCursor) (Fname, Filedate, FileSize) Values (m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Else
		        Insert Into (m.tcCursor) (Fname, Filedate, FileSize) Values (Trim(m.laFolders(m.lnX)) + [\] + m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Endif
		    Endfor
		  Endif
		Endfor
		lnRecords = Reccount()
		Select (m.lnSelect)
		Return m.lnRecords
		
		
	ENDPROC

	PROCEDURE getheader
		Local lcClip, lcCursorfiles, lcParameter, lcText
		
		Local Array laHeaders[1]
		Local Array laList[1]
		
		lcCursorfiles = This.cCursor
		#Define ccCR Chr(13)
		lcParameter = This.cParameter
		If This.cCommand = [#] And Len(This.cCommand) > 1
		  lcParameter = Substr(This.cCommand, 2)
		Endif
		lcClip = _Cliptext
		Select 0
		If this.GetFilesInPath([H], m.lcCursorfiles) = 0
		  _Cliptext = _Screen.cClip
		  Return
		EndIf
		Select (m.lcCursorfiles) 
		*!*  Select fname, Cast('' as date) as date, Cast(0 as i) as size From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite 
		*!*  Scan 
		*!*    Adir(laDummy, Alltrim(fname))
		*!*    ldDate = m.laDummy(1, 3)
		*!*    lnSize = m.laDummy(1, 2)
		*!*    Replace date with m.ldDate, size with m.lnSize 
		*!*  Endscan
		If !Empty(m.lcParameter )
		  Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where m.lcParameter  $ Lower(Fname)
		Endif
		lcText = This.GetDataFromGrid([Select file:], m.lcCursorfiles + [.fname])
		If !Empty(m.lcText)
		  This.ReplaceCurrentLine([#Include ] + m.lcText + ccCR)
		Endif
		
		
	ENDPROC

	PROCEDURE gethelptopics
		* a = all windows
		* c = command window
		* e = prg
		* f = vcx/scx
		* m = menu / blank parameter
		
		Local lcSidekickOptions
		
		Text To m.lcSidekickOptions Noshow Textmerge Pretext 7
		 a   | <blank>     | Menu                                                   | skorg
		 a   | !           | Create and run Sidekick extensions                     | skta
		 a   | !!          | Edit Sidekick extensions                               | skta
		 c   | *           | Picklist of projects in active .sk file                | skorg
		 ef  | * <number>  | Repeat * characters to split code into segments        | skorg| Number of characters: 
		 c   | +           | Picklist of all VFP files in the path, edit            | skdir
		 ef  | +           | Inserts contents from prg                              | skins   | Name of file to include:
		 a   | ++          | Picklist of VFP files with more information, edit      | skdir#dirc
		 a   | +++         | Picklist of VFP files with more information, run       | skdir#dirrun
		 c   | -           | Opens default files listed in active .sk               | skorg
		 a   | . (dot)     | Opens Sidekick "test area"                             | skta
		 ef  | = <func>    | Inserts return value from function                     | skeval  | Function name to evaluate:
		 a   | ?           | Menu                                                   | skmnu
		 cef | ?= <var>    | Returns ?'memvar',mvar                                 | skdb  | Variable name:
		 c   | 0           | Opens active .sk file for editing                      | skorg
		 c   | 0 *         | Picklist of Sidekick files in the path                 | skorg
		 c   | 0 <file>    | Makes filename.sk the active Sidekick file             | skorg | .sk file to become active:
		 c   | 1           | Items in group 1 are opened or run                     | skorg
		 c   | 2-9999      | Items in specified group opened or run                 | skorg | Group number to process:
		 a   | Br          | Browse the currently selected table or cursor          | skbr
		 ef  | Db <var>    | Returns DebugOut 'memvar',mvar                         | skdb  | Variable name:
		 f   | DD          | DoDefault() syntax builder                             | skdd  | NA
		 c   | De          | Picklist of prg files with a description               | skdesc
		 ef  | De          | Adds "* Description *" template to the active file     | skdesc
		 a   | Dr          | Picklist of all VFP files in the path, edit            | skdir
		 cef | Ec          | The content of the clipboard is executed               | skec
		 cef | Ed          | Easy way to open most files                            | sked    | Filename or URL:
		 cef | Es          | Creates EditSource command for the opened window(s)    | skes
		 ef  | Eval <func> | Inserts return value from function                     | skeval  | Function name to evaluate:
		 cef | Fp          | Opens SuperBrowse as a Field Picker                    | skfp    | Specify table name:
		 cef | Help        | Opens Sidekick page in the default Browser             | <default> 
		 cef | Hk          | Picklist of all assigned hot keys                      | skhk
		 ef  | Inc         | Insert #Include statement from Picklist of .h files    | skinc   | na 
		 ef  | Ins         | Inserts contents from prg                              | skins   | na 
		 a   | Lo          | Shows all open tables and cursors in active datasession| sklo
		 cef | Lorem       | Random "Lorem Ipsum" text generator                    | skrt    | Number of sentences (2):
		 ef  | Menu        | Menu                                                   | skmnu
		 cef | No          | NewObject syntax builder                               | skno    | na  
		 a   | Pa          | Shows the current Set Path setting plus some more      | skpa  
		 c   | Pr          | Picklist of projects in active .sk file                | skorg
		 cef | Rt          | Random readable text generator                         | skrt
		 a   | SF          | Select From syntax helper                              | sksf
		 cef | Sk          | Run or create custom made Sidekick extensions          | skext
		 cef | Sked        | Edit custom made Sidekick extensions                   | skext
		 cef | Ta          | Sidekick "Test area"                                   | skta
		 cef | Th          | Picklist of registered Thor tools                      | skth
		 ce  | Tidy        | To selectively move files to another folder            | sktidy
		 cef | Tool        | Picklist of registered Thor tools                      | skth
		 cef | Ver         | Shows Sidekick version number                          | <ver>
		 ce  | Unzip       | To Unzip files                                         | skzip#unzip
		 ce  | Zip         | To Zip files                                           | skzip
		
		Endtext
		Return m.lcSidekickOptions
	ENDPROC

	PROCEDURE getlastcharacter
		Lparameters tcText, tnNumber
		m.tnNumber = Evl(m.tnNumber,1)
		Return Right(Trim(m.tcText),m.tnNumber)
	ENDPROC

	PROCEDURE getlastfile
		Lparameters tcFileName
		Local lcExtension, lcJustName, lcReturn, lnFiles
		Local Array laDummy[1]
		m.tcFileName = Evl(m.tcFileName,'')
		tlFolder = .T.
		lcJustName = Addbs(Justpath(m.tcFileName)) + Juststem(m.tcFileName)
		lcExtension = Justext(m.tcFileName)
		If Empty(m.lcExtension)
		  lnFiles = Adir(laDummy, m.lcJustName + [*.], [D])
		else
		  lnFiles = Adir(laDummy, Forceext(m.lcJustName  + [*], m.lcExtension))
		EndIf
		If m.lnFiles > 0
		  Asort(m.laDummy, 1, -1, 1)
		  lcReturn = m.laDummy
		Else
		  m.lcReturn = m.tcFileName
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getlastword
		  Lparameters tcText, tcDelimiter                                                                                                                                                                                                                             
		  If Pcount() < 2 Or Vartype(m.tcDelimiter) # [C]                                                                                                                                                                                                             
		    tcDelimiter = [ ]                                                                                                                                                                                                                                         
		  Endif                                                                                                                                                                                                                                                       
		Return Trim(Getwordnum(m.tcText, Getwordcount(m.tcText, m.tcDelimiter), m.tcDelimiter))                                                                                                                                                                     
		
		
	ENDPROC

	PROCEDURE getlineno
		Lparameters tcFile, tnLine
		Local lcReturn, lnLines
		
		Local Array laDummy[1]
		
		lnLines = Alines(laDummy, Filetostr(m.tcFile))
		lcReturn = []
		If m.tnLine <= m.lnLines
		  lcReturn = m.laDummy(m.tnLine)
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getlinestoprocess
		Lparameters tnGroup
		
		Local Array laLines[1]
		#Define ccAmp  [&] + [&]
		
		If ! this.CheckOrCreateSidekickFile()
		  Return
		EndIf
		
		llFound = .F.
		lnLines = Alines(laLines, Filetostr(this.cSidekickFile))
		For lnCounter = 1 To m.lnLines
		  lnLine = Val(Getwordnum(m.laLines(m.lnCounter), 1))
		  If m.lnLine = m.tnGroup Or (m.lnLine = 0 And Getwordnum(m.laLines(m.lnCounter), 1) = [0])
		    llFound = .T.
		    lcCommand = Strextract(m.laLines(m.lnCounter), [ ])
		    If ccAmp $ m.lcCommand
		      lcCommand = Strextract(m.laLines(m.lnCounter), [ ], ccAmp, 1)
		    EndIf
		    this.RunSidekickLine(m.lcCommand)
		  Endif
		Endfor
		If !m.llFound
		  this.GiveMessage( [Group number ] + Transform(m.tnGroup) + [ doesn't exist in ] + this.cSidekickFile , 0, [Nothing to do!])
		Endif
		
		
	ENDPROC

	PROCEDURE getmemosize
		Lparameters tcFileDBF
		Local lcFileMemo, lnFiles, lnReturn
		
		Local Array laDummy[1]
		
		lnReturn = 0
		Do Case
		  Case Lower(Justext(m.tcFileDBF)) = [dbf]
		    lcFileMemo = Forceext(m.tcFileDBF, [fpt])
		  Case Lower(Justext(m.tcFileDBF)) = [dbc]
		    lcFileMemo = Forceext(m.tcFileDBF, [dct])
		  Case Inlist(Lower(Justext(m.tcFileDBF)), [vcx], [scx], [frx], [lbx], [mnx], [pjx])
		    lcFileMemo = Forceext(m.tcFileDBF, Left(Lower(Justext(m.tcFileDBF)), 2) + [t])
		  Otherwise
		    lcFileMemo = []
		Endcase
		If !Empty(m.lcFileMemo)
		  lnFiles = Adir(laDummy, m.lcFileMemo)
		  If m.lnFiles = 1
		    lnReturn = m.laDummy(1, 2)
		  Endif
		Endif
		Return m.lnReturn
		
		
	ENDPROC

	PROCEDURE getmethdfromprg
		Lparameters tcProcedure, tcFile
		Local lcFile, lcProc, lcReturn, lnEnd, lnSelect, lnStart, lnX
		
		Local Array laDummy[1]
		
		lnSelect = Select()
		lcProc = Lower(Padr(m.tcProcedure, 100))
		lcFile = Forceext(m.tcFile, [prg])
		lnX = Aprocinfo(laDummy, m.lcFile, 0)
		lcReturn = []
		If m.lnX > 0.
		  Select 0
		  Create Cursor curDummy (Name c(100), Line i, Type c(25), ind i)
		  Append From Array m.laDummy
		  Select Name, Line From curDummy Into Cursor curDummy Readwrite Where Type = [Procedure]
		  Locate For Lower(Name) == m.lcProc
		  If Found()
		    lnStart = Line
		    Skip
		    lnX = Alines(laDummy, Filetostr(m.lcFile ))
		    If !Eof([curdummy])
		      lnEnd = Line - 1
		    Else
		      lnEnd = m.lnX
		    Endif
		    If m.lnX > 0
		      lcReturn = []
		      For lnX = m.lnStart To m.lnEnd
		        lcReturn  = m.lcReturn + Trim(m.laDummy(m.lnX )) + crlf
		      Endfor
		    Endif
		  Endif
		  Use In Select([curdummy])
		Endif
		Select (m.lnSelect)
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getnextfile
		Lparameters tcFilename, tnDigits
		m.tnDigits = Evl(m.tnDigits,3)
		lcJustName = Addbs(JustPath(m.tcFilename)) + JustStem(m.tcFilename)
		lnLength = Len(m.lcJustName)
		For lnX = Len(m.lcJustName) to 1 step -1
		  If !IsDigit(Substr(m.lcJustName,m.lnX,1))
		    lnLast = Int(Val(Substr(m.lcJustName,m.lnX + 1, Len(m.lcJustName) - m.lnX)))
		    If m.lnLast > m.lnX and (m.lnLength - m.lnX > m.tnDigits)
		      m.tnDigits = m.lnLength - m.lnX
		    Endif
		    m.lcJustName = Left(m.lcJustName,m.lnX)
		    exit
		  EndIf
		Endfor
		Return ForceExt(m.lcJustName + Padl(m.lnLast + 1,m.tnDigits ,'0'),JustExt(m.tcFilename))
		
		
	ENDPROC

	PROCEDURE getnextproject
		Local lcFileToRead, lcText, lnLength, lnLines, lnNewProject, lnX
		
		Local Array laDummy[1]
		Local Array laProject[1]
		
		lcFileToRead = this.cSidekickFile 
		lnLines = Alines(laDummy, Filetostr(m.lcFileToRead ))
		Dimension m.laProject(1)
		For lnX = 1 To m.lnLines
		  lcText = Getwordnum(m.laDummy(m.lnX ), 1)
		  If Val(m.lcText) > 0
		    lnLength = Alen(m.laProject)
		    If m.lnLength > 1 Or !Empty(m.laProject(1))
		      lnLength = m.lnLength + 1
		      Dimension m.laProject(m.lnLength)
		    Endif
		    laProject(m.lnLength) = Val(m.lcText)
		  Endif
		Endfor
		If Alen(m.laProject ) = 1 And Empty(m.laProject(1))
		  lnNewProject = 1
		Else
		  lnNewProject = 1
		  Do While .T.
		    If Ascan(m.laProject, m.lnNewProject ) > 0
		      lnNewProject = m.lnNewProject + 1
		    Else
		      Exit
		    Endif
		  Enddo
		Endif
		Return m.lnNewProject
		
		
	ENDPROC

	PROCEDURE getnumberedline
		Lparameters tcFile, tnLine
		Local lcReturn, lnLine, lnLines, lnX
		
		Local Array laDummy[1]
		
		#Define ccAmp  [&] + [&]
		
		lnLines = Alines(laDummy, Filetostr(m.tcFile))
		lcReturn = []
		If m.lnLines > 0
		  For lnX = 1 To m.lnLines
		    lnLine = Val(Getwordnum(m.laDummy(m.lnX), 1))
		    If m.lnLine = m.tnLine
		      lcReturn = Strextract(m.laDummy(m.lnX), [ ])
		      If ccAmp $ m.lcReturn
		        lcReturn = Strextract(m.laDummy(m.lnX), [ ], ccAmp, 1)
		      Endif
		      Exit
		    Endif
		  Endfor
		Endif
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE getrandomtext
		Lparameters tnParagraphs, tnSentences
		tnParagraphs = Evl(m.tnParagraphs, 1)
		tnSentences = Evl(m.tnSentences, 1)
		Return GetDataFromURL(Textmerge([http://metaphorpsum.com/paragraphs/<<Int(m.tnParagraphs)>>/<<Int(m.tnSentences)>>]))
		
	ENDPROC

	PROCEDURE getrecordsindbf
		Lparameters tcFileName
		Local lcContents, lcLen, lnHandle, lnRec
		
		If Empty(m.tcFileName)
		  Return - 1
		Endif
		If Empty(Justext(m.tcFileName))
		  tcFileName = Forceext(m.tcFileName, [dbf])
		Endif
		Try
		  lnHandle = Fopen(m.tcFileName )
		  lcContents = Fread(m.lnHandle, 20)
		  lcLen = Substr(m.lcContents, 5, 4)
		  Fclose(m.lnHandle )
		  lnRec = CToBin(m.lcLen, [4RS])
		Catch
		  Try
		    Use (m.tcFileName) Again In 0 Alias GetRecords
		    lnRec = Reccount([GetRecords])
		    Use In GetRecords
		  Catch
		    lnRec = -2
		  Endtry
		Endtry
		Return m.lnRec
		
		
	ENDPROC

	PROCEDURE getsidekickfile
		Local lcDef, lcFile
		
		lcDef = This.cSidekickDef 
		If File(m.lcDef )
		  lcFile = Mline(Filetostr(m.lcDef), 1)
		  If !Empty(m.lcFile)
		    lcFile = This.GetLastWord(m.lcFile)
		    lcFile = Forceext(m.lcFile, [sk])
		  Endif
		Endif
		If Empty(m.lcFile)
		  lcFile = This.cSidekickFile 
		Endif
		Return m.lcFile
	ENDPROC

	PROCEDURE getsortabledate		&& Returns YYMMDD format from date
		Lparameters tdDate
		m.tdDate = Evl(m.tdDate,Date())
		Return Substr(Dtoc(m.tdDate,1),3)
	ENDPROC

	PROCEDURE getthorfiles
		Lparameters tcMask, tcCursor
		Local lcFileSkel, ldDate, lnFiles, lnFolders, lnReturn, lnSelect, lnSize, lnX, lnX2
		
		Local Array laDummy[1]
		Local Array laFolders[1]
		
		lnSelect = Select()
		Select 0
		tcCursor = Evl(m.tcCursor, [curFiles])
		Create Cursor (m.tcCursor) (Fname c(240), Filedate D, FileSize i)
		tcMask = Evl(m.tcMask, [prg])
		Dimension m.laFolders(3)
		laFolders(1) = _Screen.Cthorfolder + [Tools]
		laFolders(2) = _Screen.Cthorfolder + [Tools\My tools]
		laFolders(3) = _Screen.Cthorfolder + [procs]
		lnFolders = Alen(m.laFolders)
		For lnX = 1 To m.lnFolders
		  If m.lnX = 0
		    lcFileSkel = [*.] + m.tcMask
		  Else
		    lcFileSkel = Alltrim(m.laFolders(m.lnX)) + [\*.] + m.tcMask
		  Endif
		  lnFiles = Adir(laDummy, m.lcFileSkel)
		  If m.lnFiles > 0
		    For lnX2 = 1 To m.lnFiles
		      ldDate = m.laDummy(m.lnX2, 3)
		      lnSize = m.laDummy(m.lnX2, 2)
		      If m.lnX = 0
		        Insert Into (m.tcCursor) (Fname, Filedate, FileSize) Values (m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Else
		        Insert Into (m.tcCursor) (Fname, Filedate, FileSize) Values (Trim(m.laFolders(m.lnX)) + [\] + m.laDummy(m.lnX2, 1), m.ldDate, m.lnSize )
		      Endif
		    Endfor
		  Endif
		Endfor
		lnReturn = Reccount()
		Select (m.lnSelect)
		Return m.lnReturn
		
		
	ENDPROC

	PROCEDURE givemessage
		Lparameters tcMessage, tnDialog, tcTitle, tnTimeOut
		m.tcMessage = Evl(m.tcMessage,'No text given')
		m.tcTitle = Evl(m.tcTitle, this.cProgram)
		m.tnTimeOut = Evl(m.tnTimeOut,0)
		m.tnDialog = Evl(m.tnDialog,0+64)
		Return MessageBox( m.tcMessage,m.tnDialog,m.tcTitle,m.tnTimeOut )
		
	ENDPROC

	PROCEDURE handledescription
		#Define ccCR Chr(13)
		Do Case
		  Case This.nWindowType = 0 && Command window
		    Wait Window 'Wait while Sidekick processes files!' at 10,25 nowait noclear
		    This.ListDescript()
		  Case Inlist(This.nWindowType, 1, 2) && Program or text file
		    If this.nLineno < this.nMaxDescriptLine 
		      If Empty(this.cParameter)
		        lcText = this.cDescriptionMask1 + Space(3) + this.cDescriptionMask2 + ccCR
		      Else 
		        lcText = this.cDescriptionMask1 + ' ' + this.cParameter + ' ' + this.cDescriptionMask2 + ccCR
		      EndIf
		      this.oEditorWin.Delete()
		      this.oEditorWin.Insert(m.lcText)
		      If Empty(this.cParameter)
		        this.oEditorWin.SetInsertionPoint(this.oEditorWin.GetSelStart() -4)
		      EndIf
		    Else 
		      Wait Window Textmerge([Current line number is outside the Description range (1 to <<this.nMaxDescriptLine>>)!])
		    Endif
		Endcase
	ENDPROC

	PROCEDURE handlemrutable
		Lparameters tcCommand
		Local lcClause, lcCommand, lcData, lcFilter, lcFullName, lcMRU, lcMethod, lcModule, lcSQL, lcSelect
		Local lcTable, lcWord, lnIgnoreFields, lnLineNo, lnWords, lnX
		
		lnIgnoreFields = 2
		
		If Inlist(m.tcCommand, [Add], [Delete])
		  lcData = This.GetEditSourceCode(This.nHandle, 0, [])
		  lcFullName = Lower(Getwordnum(m.lcData, 1))
		  lcModule = Lower(Getwordnum(m.lcData, 2))
		  lcMethod = Lower(Getwordnum(m.lcData, 3))
		  lnLineNo = Val(Getwordnum(m.lcData, 4))
		Endif
		Do Case
		  Case m.tcCommand = [Add]
		    Update (This.cMRUTable) Set Datetime = Datetime(), Lineno = m.lnLineNo, Active = .T. Where Lower(FullName) = m.lcFullName And Lower(Module) = m.lcModule And Lower(Method) = m.lcMethod
		    If _Tally = 0
		      *!*        Insert Into (This.cMRUTable) (FullName, Module, Method, Lineno, Datetime, Active) Values ;
		      *!*          (Getwordnum(m.lcData, 1), Getwordnum(m.lcData, 2), Getwordnum(m.lcData, 3), Val(Getwordnum(m.lcData, 4)), Datetime(),.T.)
		      Insert Into (This.cMRUTable) (FullName, Module, Method, Lineno, Datetime, Active) Values ;
		        (m.lcFullName, m.lcModule, m.lcMethod, m.lnLineNo, Datetime(),.T.)
		    Endif
		    This.CutCurrentLine()
		  Case m.tcCommand = [Delete]
		    Update (This.cMRUTable) Set Datetime = Datetime(), Active = .F. Where Lower(FullName) = m.lcFullName And Lower(Module) = m.lcModule And Lower(Method) = m.lcMethod
		    This.CutCurrentLine()
		  Case m.tcCommand = [List]
		    Do Case
		      Case [e] $ This.cOption
		        lcFilter = [Where External]
		      Case [a] $ This.cOption
		        lcFilter = []
		        lnIgnoreFields = 1
		      Otherwise
		        lcFilter = [Where Active]
		    Endcase
		    Select * From (This.cMRUTable) Where Active Into Cursor (This.cCursor) Readwrite Order By Datetime Desc
		    lnWords = Getwordcount(This.cParameter)
		    For lnX = 1 To m.lnWords
		      lcWord = Getwordnum(This.cParameter, m.lnX)
		      Select * From (This.cCursor) Where m.lcWord $ Lower(FullName + [|] + Module + [|] + Method + [|] + Descript) Into Cursor (This.cCursor) Readwrite
		    Endfor
		    Text To m.lcSQL Noshow Textmerge Pretext 1 + 2 + 4 + 8
		      Select Cast(JustFname(fullname) as c(200)) as filename,
		        Cast(Fullname as c(240)) as fullname,
		        Cast(module as c(40)) as module,
		        Cast(method as c(40)) as method,
		        descript as description,
		        datetime,
		        lineno,
		        external,
		        active
		        from <<this.cCursor>> <<m.lcFilter >>
		        into cursor <<this.cCursor>> readwrite
		    Endtext
		    Execscript(m.lcSQL)
		    lcTable = This.GetDataFromGrid([Select what to edit:], [fullname], m.lnIgnoreFields )
		    If Lastkey() = 27
		      Return .T.
		    Endif
		    If !Empty(m.lcTable) And !External
		      lcFullName = Lower(FullName)
		      lcModule = Lower(Module)
		      lcMethod = Lower(Method)
		      Update (This.cMRUTable) Set Datetime = Datetime() Where Lower(FullName) = m.lcFullName And Lower(Module) = m.lcModule And Lower(Method) = m.lcMethod And Active
		    Endif
		    Do Case
		      Case External And (!Empty(Module) Or !Empty(Method))
		        lcCommand = Alltrim(Module)
		        lcCommand = Evl(m.lcCommand, Alltrim(Method))
		        lcData = Alltrim(FullName)
		        This.shellX(m.lcCommand, , m.lcData)
		      Case Empty(Module) And Empty(Method) And !External
		        lcData = Alltrim(FullName)
		        lnLineNo = Evl(Lineno, 1)
		        Editsource(m.lcData, m.lnLineNo)
		      Case !Empty(m.lcTable)
		        lcCommand = Alltrim(FullName)
		        If !Empty(Module)
		          lcCommand = m.lcCommand + [.] + Alltrim(Module)
		        Endif
		        If !Empty(Method)
		          lcCommand = m.lcCommand + [.] + Alltrim(Method)
		        Endif
		        If !Empty(Lineno)
		          lcCommand = m.lcCommand + [:] + Transform(Lineno)
		        Endif
		        This.RunEd(m.lcCommand )
		      Otherwise
		        Use In Select(This.cMRUTable)
		    Endcase
		  Case m.tcCommand = [Check]
		    lcMRU = Forceext(This.cMRUTable, [dbf])
		    If !File(m.lcMRU)
		      lcSelect = Select()
		      Select 0
		      If Directory([data]) And [DATA] $ Set([Path])
		        lcMRU = Forcepath(m.lcMRU, [data])
		      Endif
		      Create Table (m.lcMRU) (;
		          FullName c(240),;
		          Module c(100),;
		          Method c(40),;
		          Lineno i,;
		          Descript c(40),;
		          Datetime T,;
		          Active l)
		      Use
		      Select (m.lcSelect)
		    Endif
		Endcase
		
		
	ENDPROC

	PROCEDURE highlightcurrentline
		Local lnEndPos, loEditorWin
		
		loEditorWin  = Execscript(_Screen.cThorDispatcher, [Thor_Proc_EditorWin])
		If m.loEditorWin.FindWindow() < 0
		  Return
		Endif
		lnEndPos = m.loEditorWin.GetLineStart(m.loEditorWin.GetSelStart(), 1)
		If m.loEditorWin.GetLineNumber(m.lnEndPos) < m.loEditorWin.GetLineNumber(1e8)
		  lnEndPos = m.lnEndPos - 1
		Endif
		m.loEditorWin.Select(m.loEditorWin.GetLineStart(m.loEditorWin.GetSelStart(), 0), m.lnEndPos )
		
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcCommand
		
		Local lnX
		this.cVersion  = '1.00'
		If !Pemstatus(_Screen, [lTest], 5)
		  _Screen.AddProperty([lTest],.F.)
		Endif
		This.cExact = Set([Exact])
		Set Exact Off
		This.nSelect = Select()
		This.cClip = _Cliptext
		This.Cpoint = Set([Point])
		Set Point To [.]
		This.lNoInterface = Vartype(m.tcCommand) = [L]
		This.cCommentString = Evl(This.ReadRegistryOption([EditorCommentString]), [*!*])
		Use in (Select(this.cCursor))
		ExecScript(_screen.cthordispatcher,'thor_proc_getsidekickoptions')
		This.ReadSettings()
		Aused(This.aInUse)
		*!*  If !File(This.cSidekickDef) TBFix??????
		*!*    Strtofile([sidekick.sk], This.cSidekickDef)
		*!*  Endif
		This.cSidekickFile = Filetostr(This.cSidekickDef)
		If !Pemstatus(_Screen, [cSidekickFile], 5)
		  _Screen.AddProperty([cSidekickFile], This.cSidekickFile)
		EndIf
		this.HandleMRUTable('Check')
		If Empty(m.tcCommand) And !This.lNoInterface
		  This.oEditorWinInit()
		
		  This.oEditor = Execscript(_Screen.cThorDispatcher, [class= HighlightedText from Thor_Proc_HighlightedText.PRG])
		  For lnX = 1 To 2
		    This.oEditor.GetHighlightedText([Statement], .T.)
		    This.cParcedText = This.oEditor.cHighlightedText
		    If Empty(This.cParcedText)
		      Wait Window [] Timeout 0.001
		    Else
		      Exit
		    Endif
		  Endfor
		Else
		  This.cCommand = m.tcCommand
		  This.cParcedText = Evl(m.tcCommand, [])
		EndIf
		If .F.
		  Clear 
		  ?'this.nwindowtype', this.nwindowtype
		  ?'this.ctitle', this.ctitle
		  ?'this.coption', this.coption
		Endif
		*!*  Set Step On 
		If Empty(this.cparcedtext) 
		  lcCommand = InputBox('Type command:','Sidekick', this.cDefaultCommand ,0,'','<>')
		  If m.lcCommand = '<>' && Cancel
		    Return
		  Else 
		    this.cParcedText = Alltrim(Lower(m.lcCommand))
		  Endif
		Endif
		
		This.cParcedText = Trim(This.cParcedText, 0, Chr(13), Chr(10), Chr(0))
		this.cParcedText = Chrtran(This.cParcedText, [|], [ ])
		tcCommand = This.cParcedText
		This.cParameterOriginal = This.cParcedText
		If !Empty(this.cParcedText) or !This.lNoInterface 
		  This.FindSwitch()
		  This.FindCommand()
		  This.FindParameters()
		  If Inlist(This.nWindowType, 0, 1) And This.cTitle == This.cSidekickFile And !Inlist(m.tcCommand, [es], [es all], [de], [desc], [descript], [description], [+],'us')
		    This.RunSidekickLine(This.cParcedText )
		  Else
		    If This.cTitle == This.cSidekickFile And This.cCommand == [+]
		      This.cCommand = [es]
		      This.cParameter = [+ ] + This.cParameter
		    Endif
		    This.cParameter = Trim(This.cParameter)
		    This.FindFunction()
		  Endif
		EndIf
		_Cliptext = This.cClip
		
	ENDPROC

	PROCEDURE insertmethod
		Local lcCode, lcMethod, lcProc, lcSource, lcText, lnProcs, lnSelect, lnX
		
		Local Array laProc[1]
		
		#Define crlf Chr(13)+Chr(10)
		
		If This.cCommand = [+] And Empty(This.cParameter ) And Len(This.cCommand) > 2
		  lcMethod = Substr(This.cCommand, 2)
		Else
		  lcMethod = This.cParameter
		Endif
		lcCode = []
		If Inlist(Lower(Justext(m.lcMethod)), [prg], [h])
		  If File(m.lcMethod)
		    lcCode = Filetostr(m.lcMethod)
		  Else
		    this.GiveMessage([File not found!], 48, Alltrim(m.lcMethod))
		  Endif
		Else
		  lcText = []
		  lnSelect = Select()
		  Select 0
		  Create Cursor CurMethods (Method c(240), Source c(240), Code m)
		  Wait Window 'Wait while Sidekick processes files!' at 10,25 nowait noclear
		  This.GetFilesInPath([prg], [curPrgs])
		  Select curprgs
		  Scan
		    lcSource = curprgs.Fname
		    lnProcs = Aprocinfo(laProc, curprgs.Fname, 0)
		    If Lower(curprgs.fname)='tempa'
		    Endif
		    For lnX = 1 To m.lnProcs
		      If m.laProc(m.lnX, 3) = [Procedure] And (m.lcMethod $ Lower(m.laProc(m.lnX, 1)) Or Empty(m.lcMethod)) && And ![.] $ m.laProc(m.lnX, 1) 
		        lcProc = m.laProc(m.lnX, 1)
		        lcCode = this.GetMethdFromPrg(m.lcProc, m.lcSource)
		        If '.'$m.lcProc 
		          m.lcProc = JustExt(m.lcProc)
		        Endif
		        Insert Into CurMethods (Source, Method, Code) Values (m.lcSource, m.lcProc, m.lcCode )
		      Endif
		    Endfor
		  Endscan
		  Select CurMethods
		  Index On Lower(Method) Tag Method
		  Locate
		  Wait clear
		  If Reccount() > 0
		    lcCode = This.GetDataFromGrid([Select method to insert], [curmethods.code])
		  Else
		    this.GiveMessage([No match found!], 48, m.lcMethod)
		  Endif
		  Select (m.lnSelect)
		  lcMethod = Trim(CurMethods.Method)
		  lcSource = Trim(CurMethods.Source )
		  Use In Select([curmethods])
		  Use In Select([curprgs])
		Endif
		If !Empty(m.lcCode)
		  If This.nWindowType = 10
		    This.ReplaceCurrentLine(This.removeProcEndproc(m.lcCode) + crlf)
		  Else
		    This.ReplaceCurrentLine(m.lcCode + crlf)
		  Endif
		Endif
		
		
	ENDPROC

	PROCEDURE insertresult
		#Define ccCR Chr(13)
		Local lcMethod, lcText
		
		If This.cCommand = [=] And Empty(This.cParameter) And Len(This.cCommand) > 1
		  lcMethod = Substr(This.cCommand, 2)
		Else
		  lcMethod = This.cParameter
		Endif
		
		lcText = []
		If !Right(m.lcMethod, 1) = [)]
		  lcMethod = m.lcMethod + [()]
		Endif
		Try
		  lcText = Transform(Evaluate(m.lcMethod))
		Catch
		  this.GiveMessage([No or invalid result!], 0 + 48, m.lcMethod )
		Endtry
		If !Empty(m.lcText)
		  This.ReplaceCurrentLine(m.lcText + ccCR)
		Endif
		
		
	ENDPROC

	PROCEDURE listallcustomtools
		m.lcFilename = this.cParameter
		If Left(this.cCommand,1) = '!' and Len(this.cCommand)>1
		  m.lcFilename = Substr(this.cCommand,2)
		Endif
		
		
		If Empty(m.lcFileName)
		  lnSelect = Select()
		  lcCursor = [curCustom]
		  lnTools = this.GetFilesInPath([prg], m.lcCursor )
		  Select Cast(Lower(Substr(Juststem(Fname), 4)) As c(30)) As Program, FileSize, Filedate, Cast([] As c(100)) As Descript, Fname;
		    From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where Lower(Left(Juststem(Fname), 3)) = [sk_]
		  If _Tally = 0
		    this.GiveMessage([No tool matching sk_ *.prg found], 0 + 48, [No custom tool defined])
		  Else
		    Scan
		      lcFile = Alltrim(Fname)
		      lcDescript = this.GetDescript(m.lcFile )
		      If !Empty( m.lcDescript )
		        Replace Descript With m.lcDescript
		      Endif
		    Endscan
		    Go Top
		    lcProg = this.GetDataFromGrid(Textmerge([My "<<this.cProgram>>" extensions (R/O) to run:]), [fname], 1)
		    Use
		    Select (m.lnSelect)
		    If !Empty(m.lcProg)
		      Do (m.lcProg)
		    Endif
		    If !this.lSKComment 
		      this.CutCurrentLine()
		    Endif
		  Endif
		Else
		  lcFilename = Getwordnum(m.lcFileName, 1)
		  lcPar = Getwordnum(m.lcFileName, 2)
		  lcProg = Forceext([sk_] + m.lcFilename, [prg])
		  If File(m.lcProg )
		    If !Empty(m.lcPar)
		      Do (m.lcProg ) With m.lcPar
		    Else
		      Do (m.lcProg )
		    Endif
		  Else
		    If this.GiveMessage([File ] + m.lcProg + [ is not found], 4 + 48, [Create it?]) = 6
		      Do Case
		        Case Directory([prog])
		          lcPath = [prog]
		        Case Directory([prg])
		          lcPath = [prg]
		        Otherwise
		          lcPath = []
		      Endcase
		      this.lSKComment = .F.
		      Modify Command (Forcepath(m.lcProg, m.lcPath)) Nowait
		    Endif
		  Endif
		Endif
		If !this.lSKComment 
		  this.CutCurrentLine()
		Endif
		
		
	ENDPROC

	PROCEDURE listdescript
		Local lcCursorfiles, lcDescript, lcFile, lcSelected, lcText, lnFiles, lnX
		
		Local Array laDummy[1]
		Local Array laFiles[1]
		
		Dimension m.laFiles(1)
		lcCursorfiles = This.cCursor
		lnFiles = This.GetAllFiles(,@m.laFiles)
		If m.lnFiles = 0
		  Return
		Endif
		Select 0
		Create Cursor (m.lcCursorfiles) (Filename c(240), FullName c(240), Descript c(100), Datetime D, Size i, LineS i, Text m, uDescript c(100))
		For lnX = 1 To m.lnFiles
		  If Lower(Justext(m.laFiles(m.lnX))) =  [prg]
		    lcDescript = This.GetDescript(m.laFiles(m.lnX))
		    If !Empty(m.lcDescript)
		      lcFile = Alltrim(m.laFiles(m.lnX))
		      Adir(laDummy, m.lcFile)
		      Insert Into (m.lcCursorfiles);
		        (Filename, FullName, Descript, uDescript, Datetime, Size) Values;
		        (This.ShowCase( Justfname(m.lcFile)),;
		          This.ShowCase( m.lcFile),;
		          m.lcDescript,;
		          Upper(m.lcDescript),;
		          This.dir2dt(m.laDummy(1, 4), m.laDummy(1, 3)),;
		          m.laDummy(1, 2))
		    Endif
		  Endif
		Endfor
		This.AddLinesAndText()
		If !Empty(This.cParameter)
		  For lnX = 1 To Getwordcount(This.cParameter)
		    lcText = Lower(Getwordnum(This.cParameter, m.lnX))
		    Select * From (m.lcCursorfiles) Where m.lcText $ Lower(Filename) Or m.lcText $ Lower(Descript) Order By uDescript Into Cursor (m.lcCursorfiles) Readwrite
		  Endfor
		Endif
		Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Order By uDescript
		Index On Upper(Filename) Tag Filename
		Index On Upper(FullName) Tag FullName
		Index On Datetime Tag Datetime
		Index On Size Tag Size
		Index On lines Tag Lines
		Index On Upper(Descript) Tag Descript
		Set Order To
		Go Top
		Wait clear
		lcSelected = This.GetDataFromGrid([Prg files with description], [Fullname], 1)
		If !Empty(m.lcSelected)
		  This.oEditorWin.Delete()
		  Modify Command (m.lcSelected) Nowait
		Endif
		
	ENDPROC

	PROCEDURE listfiles
		Lparameters tcFilter
		Local lcCursorfiles, lcDescript, lcFile, lcFilter, lcMessage, lcText, lcWord, llRecords, lnFiles
		Local lnX, loDummy
		
		Local Array laDummy[1]
		
		lcCursorfiles = This.cCursor
		#Define ccSelectFilter '!!'
		#Define ccVFPFilesToList [dbf], [scx], [vcx], [prg], [h], [dbc], [frx], [lbx], [mnx], [txt], [sk]
		#Define ccVFPTablesExtended [dbf], [dbc], [frx], [lbx], [mnx], [pjx], [scx], [vcx]
		#Define crlf Chr(13)+Chr(10)
		If ccSelectFilter $ m.tcFilter
		  This.cFilter = [Include]
		  tcFilter = Strtran(m.tcFilter, ccSelectFilter, [])
		Endif
		tcFilter = Evl(m.tcFilter, [vfp])
		tcFilter = Lower(m.tcFilter)
		Select 0
		If ![t] $ This.cOption
		  lnFiles = This.GetFilesInPath([*], m.lcCursorfiles)
		Else
		  lnFiles = This.GetThorFiles([*], m.lcCursorfiles)
		Endif
		If m.lnFiles = 0
		  Return
		Endif
		Do Case
		  Case [e] $ This.cOption
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Inlist(Lower(Justext(Fname)), [prg], [scx])
		    lcMessage = [Select a file to run:]
		  Case [f] $ This.cOption
		    lcMessage = [Pick a source table:]
		  Case This.cCommand = [unzip]
		    lcMessage = [Select file to unzip:]
		  Otherwise
		    lcMessage = [Select a file to edit:]
		Endcase
		Do Case
		  Case m.tcFilter = [dbf] And [s] $ This.cOption And !Empty(This.cParameter)
		    lcFilter = Getwordnum(This.cParameter, 1)
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Lower(Justext(Fname)) == [scx] And m.lcFilter $ Lower(Juststem(Fname))
		  Case m.tcFilter = [dbf] And [s] $ This.cOption
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Lower(Justext(Fname)) == [scx]
		  Case m.tcFilter = [dbf] And [v] $ This.cOption And !Empty(This.cParameter)
		    lcFilter = Getwordnum(This.cParameter, 1)
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Lower(Justext(Fname)) == [vcx] And m.lcFilter $ Lower(Juststem(Fname))
		  Case m.tcFilter = [dbf] And [v] $ This.cOption
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Lower(Justext(Fname)) == [vcx]
		  Case m.tcFilter = [dbf] And !Empty(This.cParameter)
		    lcFilter = Getwordnum(This.cParameter, 1)
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Lower(Justext(Fname)) == [dbf] And m.lcFilter $ Lower(Juststem(Fname))
		  Case m.tcFilter = [dbf]
		    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where Lower(Justext(Fname)) == [dbf]
		  Case m.tcFilter = [.v] && [.vcx]
		    Do Case
		      Case [.vcx] $ This.cParameter
		        This.AddOption([v])
		        This.cParameter = Strtran(This.cParameter, [.vcx], [])
		      Case [.vc] $ This.cParameter
		        This.AddOption([v])
		        This.cParameter = Strtran(This.cParameter, [.vc], [])
		      Case [.v] $ This.cParameter
		        This.AddOption([v])
		        This.cParameter = Strtran(This.cParameter, [.v], [])
		    Endcase
		Endcase
		*!*  For lnX = 1 To Getwordcount(This.cParameter)
		*!*    lcWord = Getwordnum(This.cParameter, m.lnX)
		*!*    Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Where m.lcWord $ Lower(Fname)
		*!*  Endfor
		If Reccount(m.lcCursorfiles) = 0
		  This.GiveMessage([No match found])
		  Return .F.
		Endif
		Update (m.lcCursorfiles) Set Fname = [ ] + Fname Where Empty(Justpath(Fname))
		Do Case
		  Case m.tcFilter = [vfp]
		    Select Fname, Cast(Justfname(Fname) As c(50)) As f1, Filedate, FileSize From (m.lcCursorfiles) ;
		      Into Cursor (m.lcCursorfiles) Readwrite Where Inlist(Lower(Justext(Fname)), ccVFPFilesToList)
		  Case [?] = m.tcFilter Or m.tcFilter == [*]
		    Select Fname, Cast(Justfname(Fname) As c(50)) As f1, Filedate, FileSize From (m.lcCursorfiles) ;
		      Into Cursor (m.lcCursorfiles) Readwrite Where .T.
		  Case m.tcFilter = [dbf] And !Empty(This.cParameter)
		    For lnX = 1 To Getwordcount(This.cParameter )
		      lcWord = Getwordnum(This.cParameter, m.lnX)
		      Select Fname, Cast(Justfname(Fname) As c(50)) As f1, Filedate, FileSize From (m.lcCursorfiles) ;
		        Into Cursor (m.lcCursorfiles) Readwrite Where m.lcWord $ Lower(Fname);
		        And Inlist(Lower(Justext(Fname)), ccVFPFilesToList)
		    Endfor
		  Case m.tcFilter = [dbf] && And !Empty(This.cParameter)
		    Select Fname, Cast(Justfname(Fname) As c(50)) As f1, Filedate, FileSize From (m.lcCursorfiles) ;
		      Into Cursor (m.lcCursorfiles) Readwrite && Where Inlist(Lower(Justext(Fname)), ccVFPFilesToList)
		  Otherwise
		    For lnX = 1 To Getwordcount(m.tcFilter)
		      lcWord = Getwordnum(m.tcFilter, m.lnX)
		      If [.] $ m.tcFilter
		        Select Fname, Cast(Justfname(Fname) As c(50)) As f1, Filedate, FileSize From (m.lcCursorfiles) ;
		          Into Cursor (m.lcCursorfiles) Readwrite Where m.lcWord $ Lower(Fname)
		      Else
		        Select Fname, Cast(Justfname(Fname) As c(50)) As f1, Filedate, FileSize From (m.lcCursorfiles) ;
		          Into Cursor (m.lcCursorfiles) Readwrite Where m.lcWord $ Lower(Fname);
		          And Inlist(Lower(Justext(Fname)), ccVFPFilesToList)
		      Endif
		    Endfor
		Endcase
		If Reccount(m.lcCursorfiles) = 0
		  This.RunEd(This.cParameter )
		  Return
		Endif
		Select Max(Len(Trim(f1))), Max(Len(Trim(Fname))) From (m.lcCursorfiles) Into Array laDummy
		Select Cast(This.ShowCase(f1) As c(m.laDummy(1, 1))) As Filename,;
		  Cast(This.ShowCase(Alltrim(Fname)) As c(m.laDummy(1, 2))) As FullName,;
		  Filedate, FileSize From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Order By 1
		llRecords = .F.
		If [a] $ This.cOption Or [e] $ This.cOption
		  Select Count(*) From (m.lcCursorfiles) Where Inlist(Lower(Justext(Filename)), ccVFPTablesExtended) Into Array laDummy
		Else
		  Select Count(*) From (m.lcCursorfiles) Where Inlist(Lower(Justext(Filename)), [dbf]) Into Array laDummy
		Endif
		llRecords = m.laDummy  > 0
		If [n] $ This.cOption
		  Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles) Readwrite Order By Filename, Filedate Desc
		Endif
		
		If m.llRecords And Empty(Field([records]))
		  Alter Table (m.lcCursorfiles) Add Column RecordS i
		  Alter Table (m.lcCursorfiles) Add Column Fields i
		  Alter Table (m.lcCursorfiles) Add Column MemoSize i
		Endif
		*!*  Set Step On 
		
		Do Case
		  Case [a] $ This.cOption Or [e] $ This.cOption
		    Set Filter To Inlist(Lower(Justext(Filename)), ccVFPTablesExtended)
		  Otherwise
		    Set Filter To Inlist(Lower(Justext(Filename)), [dbf])
		Endcase
		Scan For RecordS = 0
		  Replace RecordS With This.GetRecordsInDBF(FullName)
		  Replace Fields With This.GetFieldCount(Fullpath(FullName))
		  Replace MemoSize With This.GetMemoSize(Fullpath(FullName))
		Endscan
		Set Filter To
		If [a] $ This.cOption Or [e] $ This.cOption
		  Alter Table (m.lcCursorfiles) Add Column LineS i
		  Alter Table (m.lcCursorfiles) Add Column Text m
		  This.AddLinesAndText()
		  Alter Table (m.lcCursorfiles) Add Column Descript c(100)
		  Scan
		    lcFile = Alltrim(FullName)
		    lcDescript = This.GetDescript(m.lcFile )
		    If !Empty( m.lcDescript )
		      Replace Descript With m.lcDescript
		    Endif
		  Endscan
		  Go Top
		Endif
		
		If !Empty(This.cFilter)
		  lcFilter = This.cFilter
		  Alter Table (m.lcCursorfiles) Add Column (m.lcFilter) l
		Endif
		If Inlist(m.tcFilter, [dbf], [.vcx]) And [v] $ This.cOption && vcx
		  If [l] $ This.cOption
		    Alter Table (m.lcCursorfiles) Add Column [classes] c(15)
		    Do While .T.
		      Locate For Empty(Classes)
		      If !Found()
		        Exit
		      Endif
		      Scatter Memo Name m.loDummy
		      lcFile = Alltrim(FullName)
		      Select ObjName From (m.lcFile) Where reserved1 == [Class] And !Deleted() Into Array laDummy
		      Asort(m.laDummy)
		
		      For lnX = 1 To Alen(m.laDummy)
		        If m.lnX = 1
		          Replace Classes With m.laDummy(m.lnX)
		        Else
		          loDummy.Classes = m.laDummy(m.lnX)
		          Append Blank
		          Gather Memo Name m.loDummy
		        Endif
		      Endfor
		    Enddo
		
		  Else
		    Alter Table (m.lcCursorfiles) Add Column [classes] m
		    Scan
		      lcFile = Alltrim(FullName)
		      Select ObjName From (m.lcFile) Where reserved1 == [Class] And !Deleted() Into Array laDummy
		      Asort(m.laDummy)
		      lcText = []
		      For lnX = 1 To Alen(m.laDummy)
		        lcText = m.lcText + Alltrim(m.laDummy(m.lnX)) + crlf
		      Endfor
		      lcText = Trim(m.lcText, 1, Chr(13), Chr(10))
		      Replace Classes With m.lcText
		    Endscan
		  Endif
		Endif
		This.DropFieldIfEmpty(m.lcCursorfiles, [records], 1)
		This.DropFieldIfEmpty(m.lcCursorfiles, [lines], 1)
		This.DropFieldIfEmpty(m.lcCursorfiles, [Fields], 1)
		This.DropFieldIfEmpty(m.lcCursorfiles, [text])
		This.DropFieldIfEmpty(m.lcCursorfiles, [descript], 2)
		This.DropFieldIfEmpty(m.lcCursorfiles, [memosize], 1)
		If [l] $ This.cOption And Inlist(m.tcFilter, [dbf], [.vcx]) And [v] $ This.cOption && vcx
		  Select * From (m.lcCursorfiles) Into Cursor (m.lcCursorfiles + [1]) Readwrite
		  Use In (m.lcCursorfiles)
		  Select * From (m.lcCursorfiles + [1]) Into Cursor (m.lcCursorfiles) Readwrite Order By Filename, Classes
		  Index On Classes Tag Classes
		Endif
		
		Index On Upper(FullName) Tag FullName
		Index On Upper(Filename) Tag Filename
		Index On Filedate Tag Filedate
		Index On FileSize Tag FileSize
		Set Order To
		Wait Clear
		lcText = This.GetDataFromGrid(m.lcMessage, [fullname], 0)
		Do Case
		  Case !Empty(This.cFilter)
		  Case [e] $ This.cOption And Inlist(Lower(Justext(m.lcText)), [prg], [scx])
		    This.RunProgram(m.lcText)
		  Case Lower(Justext(m.lcText)) = [zip]
		  Case This.cCommand == [us]
		  Case This.nWindowType = 0 And This.cCommand == [use]
		  Case This.cCommand = [sf]
		  Case Lower(Justext(m.lcText)) = [sk]
		    Modify Command (m.lcText) Nowait
		  Case !Empty(m.lcText)
		    If Ascan(This.aInUse, Juststem(m.lcText), -1, -1, 1, 1 + 2 + 4) > 0
		      This.cTableToKeepOpen = Juststem(m.lcText)
		    Endif
		    This.RunEd(Fullpath(m.lcText))
		Endcase
		Return m.lcText
		
		
	ENDPROC

	PROCEDURE listopentables
		Local lcCursor, lnFiles, lnWorkArea, lnX
		
		Local Array laDummy[1]
		
		lnWorkArea = 0
		lcCursor = This.cCursor && 'curOpenTables'
		Create Cursor (m.lcCursor) (Workarea i, Alias c(20), Table c(50), RecordS i, Order c(50))
		
		lnFiles = Aused(laDummy)
		For lnX = 1 To m.lnFiles
		  Insert Into (m.lcCursor) (Workarea, Alias) Values (m.laDummy(m.lnX, 2), m.laDummy(m.lnX, 1))
		Endfor
		Scan
		  Replace Table With This.ShowCase( This.FixPath( Dbf(Workarea))),;
		    RecordS With Reccount(Workarea),;
		    Order With Order(Workarea)
		Endscan
		Select * from (m.lcCursor) into cursor (m.lcCursor) readwrite where alias # Upper(m.lcCursor)
		Index On Alias Tag Alias
		Index On Table Tag Table
		Index On Workarea Tag Workarea
		
		This.lNoMessage = .T.
		If Reccount() > 1
		  lnWorkArea = Val(This.GetDataFromGrid([List of open tables], [workarea]))
		Else
		  This.GiveMessage([No tables are open!])
		Endif
		If m.lnWorkArea > 0
		  *!*    Select (m.lnWorkArea)
		*!*    this.GiveMessage(Textmerge('Work area <<m.lnWorkArea >> is selected'))
		  this.GiveMessage(Alltrim(alias) + ' is selected!')
		  This.nSelect = m.lnWorkArea
		Endif
		
	ENDPROC

	PROCEDURE listprojects
		Local lcClip, lcTable, lcText, lnSelect
		
		lcTable = This.cSidekickFile 
		lnSelect = Select()
		lcClip = _Cliptext
		If This.nWindowType = 0
		  Select 0
		  Create Cursor curProjects (text1 c(240), Projnotxt c(3), Project c(50), projno i)
		  Append From (m.lcTable) Sdf
		  Replace All Projnotxt With Ltrim(Strextract(text1, [#], [ ], 1)),;
		    projno With Val(Strextract(text1, [#], [ ], 1))
		  Replace All Project With Strextract(text1, [ ], [], 1) For projno > 0
		  Select Projnotxt, Project  From curProjects x;
		    Where x.projno > 0 Order By projno;
		    Into Cursor curProjects Readwrite
		  If _Tally > 0
		    Select Projnotxt As ProjectNo, Project  From curProjects Into Cursor curProjects Readwrite
		    If !Empty(this.cParameter)
		      lnWords = GetWordCount(this.cParameter)
		      For lnX = 1 to m.lnWords 
		        lcWord = GetWordNum(this.cParameter,m.lnX)
		        Select * from curprojects into cursor curprojects readwrite where m.lcWord $ Lower(Projectno + '|' + Project)
		      Endfor
		    Endif
		    Go Top
		    lcText = This.GetDataFromGrid([Select project from ] + this.cSidekickFile , [projectno])
		    If !Empty(m.lcText)
		      This.ProcessSidekickFile(m.lcText )
		    Endif
		  EndIf
		  this.CutCurrentLine()
		*!*    This.oEditorWin.Delete()
		Endif
		Select (m.lnSelect)
		
		
	ENDPROC

	PROCEDURE listusedtables
		Local lcCursor, lnTables
		
		Local Array laDummy[1]
		lnTables = Aused(laDummy)
		If m.lnTables > 0
		  lcCursor = this.cCursor 
		  Create Cursor (m.lcCursor) (Fullname c(250), workarea i, Alias c(10), Table c(25), Size i, Date d, records i, memosize i)
		  Append From Array m.laDummy Fields Fullname, workarea
		  Scan 
		    Replace Fullname With Dbf(Trim(Fullname))
		    Replace Table With Justfname(Fullname),;
		      RecordS With This.GetRecordsInDBF(FullName),; 
		      MemoSize With This.GetMemoSize(Fullpath(FullName)),; 
		      alias with Alias(workarea)
		  Endscan
		  Select Max(Len(Trim(Fullname))), Max(Len(Trim(Table))) From (m.lcCursor) Into Array laDummy
		  Select Cast(Table As c(m.laDummy(1, 2))) As Table, alias, Cast(Fullname As c(m.laDummy(1, 1))) As Fullname, Size, Date, records, memosize From (m.lcCursor) Into Cursor (m.lcCursor) Readwrite Where !Empty(alias)
		Else
		  Return .F.
		Endif
		If Reccount() > 0
		  Scan
		    If Adir(laDummy, Fullname) > 0
		      Replace Size With m.laDummy(1, 2), Date With m.laDummy(1, 3)
		    Endif
		  Endscan
		Endif
		Return Reccount() > 0
	ENDPROC

	PROCEDURE makedodefault
		Local lcResult
		#Define ccCR Chr(13)
		
		lcResult = [DoDefault(] + _oPEMEditor.oUtils.oBeautifyX.FetchParametersList() + [)] + ccCR
		this.ReplaceCurrentLine(m.lcResult)
	ENDPROC

	PROCEDURE makefieldpicker
		Local lcAlias, lcFormFileName, lcReturn
		
		If !Empty(This.cParameter)
		  lcAlias = This.cParameter
		Else
		  lcAlias = Alias()
		Endif
		If Empty(m.lcAlias)
		  Wait Window [No table selected or specified] At 10, 25 Timeout 3
		Else
		  Execscript(_Screen.cThorDispatcher, [PEME_OpenTable], m.lcAlias)
		  lcFormFileName = Execscript(_Screen.cThorDispatcher, [Full Path=PEME_Snippet_FP.SCX])
		  Do Form (m.lcFormFileName) With m.lcAlias, [], [] To m.lcReturn
		  this.ReplaceCurrentLine(m.lcReturn)
		Endif
		
	ENDPROC

	PROCEDURE makeloremtext
		*!*  lnLength = Int(Val(GetWordNum(this.cParameter,1,', ' )))
		*!*  lnParagraphs = Int(Val(GetWordNum(this.cParameter,2,', ')))
		*!*  lcText = this.GetLoremText(m.lnLength,m.lnParagraphs  )
		Local lcText, lnLength
		
		lnLength = Val(This.cParameter)
		lnLength = Min(Evl(m.lnLength, 2),122)
		Text To m.lcText Noshow Textmerge Pretext 1 + 2
		Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis dictum semper quam id imperdiet. Ut et arcu eu felis euismod tristique. Aliquam varius rutrum nibh, ut rhoncus nisl commodo a. Maecenas nisi neque, sagittis non dolor et, finibus vestibulum dui. Interdum et malesuada fames ac ante ipsum primis in faucibus. Aenean augue orci, dictum a consectetur nec, dictum sit amet mauris. Morbi vitae mollis metus, pellentesque aliquet nunc.
		
		Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean consectetur, eros rhoncus eleifend porta, ipsum est fringilla nisi, vitae congue dui ante sit amet orci. Maecenas eget bibendum nibh, sit amet volutpat libero. Nulla a aliquam mi. Nullam mattis laoreet dapibus. Donec interdum est sit amet purus aliquet rutrum. Mauris ornare interdum malesuada. Vivamus a neque eu odio laoreet pellentesque eu ac felis.
		
		Nulla iaculis sem vestibulum elit pretium, quis imperdiet justo vulputate. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nulla facilisis tempus odio eu vulputate. Etiam tincidunt et metus quis dictum. Quisque non lectus fringilla, ullamcorper libero ut, scelerisque ex. Cras luctus erat sit amet rhoncus porttitor. Nam finibus volutpat arcu hendrerit dignissim. Proin bibendum nisl lacinia viverra fringilla. Vestibulum pellentesque quis mi non euismod. Etiam varius nibh et quam sagittis, nec hendrerit nisi elementum. Nulla aliquam turpis id orci suscipit, eu faucibus nisl venenatis. Duis lacinia felis nibh, sit amet consequat leo vestibulum vitae. Praesent eu sollicitudin nibh. Pellentesque iaculis non ipsum quis hendrerit. Donec ex est, malesuada vel ullamcorper vel, dapibus eget ligula.
		
		Etiam vel facilisis nunc. Cras sed nulla nec nunc mattis ullamcorper id nec augue. Curabitur vehicula orci sit amet odio facilisis semper. Praesent eu tempus ex. Fusce porttitor lectus dictum urna feugiat, nec aliquam dolor lacinia. Integer eget faucibus risus. Donec at purus quis tortor auctor fermentum aliquam sed elit. Quisque ac lorem in nibh fermentum tempor. In viverra odio ut neque tempus fringilla.
		
		Aenean quis sollicitudin eros. Nunc lacinia odio a velit feugiat, non posuere augue facilisis. Phasellus viverra justo risus, viverra facilisis nisi condimentum eu. Suspendisse nibh augue, aliquet nec efficitur nec, volutpat ac purus. Nunc vehicula ornare ornare. Nulla facilisi. Pellentesque quis enim quam. Maecenas mi felis, facilisis id enim laoreet, luctus bibendum mauris. Maecenas tincidunt non massa eget posuere. Donec ut efficitur tellus. Pellentesque massa mauris, laoreet in eleifend non, gravida at mi. Proin eu sem dignissim, rhoncus metus quis, ultricies odio. Nam at massa non sapien bibendum facilisis. Donec sit amet elementum nunc, sed pellentesque nunc. Maecenas aliquam nulla non elit varius, et varius justo auctor. Etiam neque leo, consequat quis luctus nec, sollicitudin sed ante.
		
		Vivamus tristique lacus nulla, dignissim rhoncus nisl lobortis vel. Donec nec lobortis nulla. Interdum et malesuada fames ac ante ipsum primis in faucibus. Morbi accumsan iaculis tellus ut volutpat. Vivamus a augue in nisi malesuada dignissim nec id lorem. Sed facilisis luctus sapien vitae venenatis. Morbi tempus elementum enim at placerat. Vestibulum pellentesque justo iaculis fermentum pulvinar. Donec venenatis imperdiet lectus, sed volutpat dolor porttitor eu. Sed sollicitudin vel sapien ullamcorper vehicula. Nunc placerat lobortis elit a vehicula. Etiam pulvinar congue enim eu tincidunt. Mauris nec dolor lobortis, ornare nunc a, pulvinar lorem. Cras congue ipsum eu aliquam eleifend. Nullam lobortis, mauris non pellentesque aliquet, nisi quam lacinia libero, et malesuada libero est sed risus.
		
		Pellentesque sit amet blandit velit, vitae pharetra nibh. Curabitur sed posuere libero. Ut lobortis, lectus a dignissim tincidunt, urna leo euismod dolor, eget dapibus ligula ante a mi. Quisque blandit efficitur suscipit. Praesent efficitur eros sit amet nunc elementum ornare. Quisque id nisi eros. Nulla facilisi. Pellentesque et neque orci. Ut arcu lorem, posuere a hendrerit vitae, blandit sed sapien. Donec vehicula, urna dignissim facilisis auctor, dui lectus venenatis elit, at eleifend tortor ligula eget tortor. Aenean blandit non neque eget tristique. Proin rhoncus eget massa quis posuere. Proin vel imperdiet magna. Vestibulum tincidunt condimentum scelerisque.
		
		Phasellus sem mauris, sagittis vel sapien et, commodo placerat ex. Suspendisse eu tellus tristique, bibendum arcu eu, venenatis purus. Ut egestas, leo id scelerisque dictum, mi leo venenatis libero, quis imperdiet quam elit eu quam. Aenean at sem lectus. Etiam id sem nisi. Donec ut ex velit. Nunc at nisi sit amet neque viverra blandit. Aenean nec venenatis nisl. Sed ullamcorper ipsum non finibus iaculis. Donec condimentum molestie nunc vel finibus. Maecenas quis lobortis risus, in luctus magna. Praesent elit leo, luctus ac commodo ac, tincidunt sed nisl. Pellentesque tristique arcu elit, vel cursus erat lacinia non. Etiam a molestie justo. Vivamus ullamcorper quam eu vulputate faucibus.
		
		Aenean pretium sit amet massa ac rutrum. Nunc eget commodo urna. Duis faucibus vitae lacus sed facilisis. Donec tincidunt sed elit a auctor. Proin rutrum leo id pretium molestie. Sed porta interdum dolor, nec lobortis dui convallis sit amet. Vestibulum congue turpis id est mollis, in iaculis nunc commodo. Vivamus nisi odio, fermentum non congue et, consequat non nulla. Sed eu blandit quam, et lacinia odio. Proin convallis viverra libero, vel finibus elit volutpat at. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.
		
		Nunc quis metus nec metus ornare pharetra id vel nulla. Cras varius faucibus elit a ultricies. Nam feugiat augue massa, eu sodales justo porta at. Vestibulum imperdiet, sem in ullamcorper malesuada, ipsum turpis elementum ex, at auctor ipsum orci vel quam. Maecenas sollicitudin ligula arcu, eget semper nibh scelerisque vitae. Suspendisse sed nunc tellus. Aenean dictum, ipsum vitae malesuada facilisis, augue augue vehicula odio, non tristique lorem tortor in mi. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec elementum ante. Donec vitae tincidunt orci. Duis a accumsan erat.
		EndText
		m.lcText = Left(m.lcText, At([.], m.lcText, m.lnLength))
		If 'c' $ this.cOption 
		  this.CutCurrentLine()
		  this.cClip = m.lcText 
		Else   
		  This.ReplaceCurrentLine(m.lcText )
		Endif
		
		
		
	ENDPROC

	PROCEDURE makerandowtext
		Local lcText, lnParagraphs, lnSentences
		
		lnSentences = Val(Getwordnum(This.cParameter, 2, [, ]))
		lnParagraphs = Val(Getwordnum(This.cParameter, 1, [, ]))
		lnParagraphs = Evl(m.lnParagraphs, 1)
		lnSentences = Evl(m.lnSentences, 1)
		lcText = This.GetRandomText(m.lnParagraphs, m.lnSentences)
		If 'c' $ this.cOption 
		  this.CutCurrentLine()
		  this.cClip = m.lcText 
		Else   
		  This.ReplaceCurrentLine(m.lcText )
		Endif
		
	ENDPROC

	PROCEDURE makesktestarea
		lcTANumber = this.cParameter 
		If InList(Left(this.cCommand,1),'.',',') and Len(this.cCommand) > 1
		  m.lcTANumber = Substr(this.cCommand,2)
		EndIf   
		If !Empty(m.lcTANumber )
		  m.lcTANumber = [_] + m.lcTANumber 
		Endif
		Modify Command Forceext([SKTestarea] + m.lcTANumber, [prg]) Nowait
		
		
	ENDPROC

	PROCEDURE makestringfromarray
		Lparameters taArray, tcPath, tnColumn
		m.tcPath = Evl(m.tcPath,'')
		m.tnColumn = Evl(m.tnColumn,1)
		lnLines = Alen(m.taArray,1)
		lcReturn = ''
		For lnX = 1 to m.lnLines 
		  m.lcReturn = m.lcReturn + ForcePath(Trim(m.taArray(m.lnX,m.tnColumn)),m.tcPath) + ','
		Endfor
		Return Rtrim(m.lcReturn,0,',')
	ENDPROC

	PROCEDURE modifyform
		Local lcCode, lcCursor, lcDBF, lcFile, lcMessage, lcMethod, lcProc, lcWord, lnProcs, lnWords, lnX
		
		Local Array laDummy[1]
		Local Array laProc[1]
		
		lcCursor = This.cCursor
		
		If [.] $ This.cParameter Or !Pemstatus(_Screen, [sklastform], 5)
		  This.cParameter = Chrtran(This.cParameter, [.], [])
		  This.GetFilesInPath([scx], m.lcCursor )
		  Select (m.lcCursor)
		  Select Cast(Justfname(Fname) As c(50)) As Form, Fname, FileSize As Size, Filedate As Date;
		    From (Alias()) Into Cursor ( Alias()) Readwrite
		  Select Max(Len(Trim(Form))), Max(Len(Trim(Fname))) From (Alias()) Into Array laDummy
		  Select Cast(Form As c(m.laDummy(1))) As Form, Cast(Fname As c(m.laDummy(2))) As Fname, Size, Date;
		    From (Alias()) Into Cursor ( Alias()) Readwrite
		  lnWords = Getwordcount(This.cParameter)
		  For lnX = 1 To m.lnWords
		    lcWord = Getwordnum(This.cParameter, m.lnX)
		    Select * From (Alias()) Where m.lcWord $ Lower(Fname) Into Cursor (Alias()) Readwrite
		  Endfor
		  lcMessage = [Select a form to modify:]
		  If Reccount() > 1
		    lcDBF = This.GetDataFromGrid(m.lcMessage, [fname])
		  Else
		    lcDBF = Alltrim(Fname)
		  Endif
		  _Screen.AddProperty([sklastform], m.lcDBF)
		Endif
		If Pemstatus(_Screen, [sklastform], 5) And !Empty(_Screen.sklastform)
		  lcDBF = _Screen.sklastform
		  Select Methods From (m.lcDBF) Into Array laDummy Where BaseClass = [form]
		  If _Tally > 0
		    lcFile = Forceext([sk] + Sys(2015), [prg])
		    *!*    lcCursor = 'cur'+Sys(2015)
		    Strtofile(m.laDummy(1, 2), m.lcFile)
		    lnProcs = Aprocinfo(laProc, m.lcFile)
		    *!*    Select 0
		    If m.lnProcs > 0
		      Create Cursor (m.lcCursor + [1]) (Function c(25), Code m)
		      For lnX = 1 To m.lnProcs
		        If m.laProc(m.lnX, 3) = [Procedure] && And (m.lcMethod $ Lower(m.laProc(m.lnX, 1)) Or Empty(m.lcMethod)) && And ![.] $ m.laProc(m.lnX, 1)
		          lcProc = m.laProc(m.lnX, 1)
		          lcCode = This.GetMethdFromPrg(m.lcProc, m.lcFile )
		          If [.] $ m.lcProc
		            lcProc = Justext(m.lcProc)
		          Endif
		          Insert Into (m.lcCursor + [1]) (Function, Code) Values (m.lcProc, m.lcCode)
		        Endif
		      Endfor
		    Endif
		    If File(m.lcFile)
		      Erase (m.lcFile)
		    Endif
		    Select (m.lcCursor + [1])
		    lcMessage = Proper(Juststem(m.lcDBF)) + [ - Select a method:]
		    lcMethod = This.GetDataFromGrid(m.lcMessage, [Function])
		    Wait Window m.lcMethod At 10, 25
		    _Screen.AddProperty([sklastmethod], m.lcMethod )
		  Else
		    Wait Window [ingen] At 10, 25
		    *tbfix
		  Endif
		  *!*    Use in (m.lcCursor)
		Endif
		
		
		
		
		
	ENDPROC

	PROCEDURE notes
		Text To lcDummy Noshow Textmerge Pretext 1+2+4
		Path:
		  /n No path
		  /f Full path
		  /r Relative path
		
		No (NewObject builder)  
		  /n Newest first
		
		Zip:
		  /d Delete after zip
		  
		Listfiles: 
		  /l List all classes as records  
		
		Fix: 
		  Autosize if PG
		  Header click: textbox.setfocus
		
		
		EndText
		
	ENDPROC

	PROCEDURE oeditorwininit
		This.oEditorWin = Execscript(_Screen.cThorDispatcher, [Thor_Proc_EditorWin])
		This.nWindowType = This.oEditorWin.FindWindow()
		This.nSelStart = This.oEditorWin.GetSelStart()
		This.nSelEnd = This.oEditorWin.GetSelend()
		This.nFileSize = This.oEditorWin.GetFileSize()
		This.nHandle = This.oEditorWin.GetWindowHandle()
		If this.nwindowtype >= 0
		  This.cTitle = This.oEditorWin.GetTitle()
		  This.nLineno = This.oEditorWin.GetLineNumber(This.nSelStart)
		Else 
		  This.cTitle = 'No active window!'
		Endif
		
	ENDPROC

	PROCEDURE ozipinit
		If Vartype(this.oZip) # 'O'
		  lcProcess = Execscript(_Screen.cThorDispatcher, [Full Path=] + [thor_proc_sidekick.VCX])
		  this.oZip = NewObject('ozip', m.lcProcess)
		Endif
		
	ENDPROC

	PROCEDURE processsidekickfile
		Lparameters tcProject
		Local lcParam1
		If !This.CheckOrCreateSidekickFile()
		  Return
		EndIf
		lcParam1 = this.GetLineNo(this.cSidekickFile , 1)
		If Lower(Getwordnum(m.lcParam1, 1)) = [default]
		  lcParam1 = Getwordnum(m.lcParam1, Getwordcount(m.lcParam1 ))
		Else
		  this.GiveMessage([No Default group defined in ] + this.cSidekickFile , 0)
		  Return
		EndIf
		If !Empty(m.tcProject)
		  m.lcParam1 = m.tcProject
		Endif
		If Val(m.lcParam1) > 0
		  this.GetLinesToProcess(Val(m.lcParam1))
		Else
		  this.RunEd(m.lcParam1)
		Endif
		
	ENDPROC

	PROCEDURE readclasslibs
		Local lcClass, lcFile, lnClasses, lnI, lnReturn, lnSelect, lnX, loList, loTools, lx
		
		Local Array laClasses[1]
		Local Array laDummy[1]
		lnReturn = 0
		If llNoProject && No active project, use MRU
		  loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		  loList = m.loTools.GetMRUList([VCX])
		  lnSelect = Select()
		  Select 0
		  Create Cursor curClassLib (Class c(50), Classlib c(100))
		  Index On Upper(Classlib) Tag Classlib
		  Index On Upper(Class) Tag Class
		  For Each m.lcClass In m.loList
		    Try
		      lcFile = Getwordnum(m.lcClass, 1, [|])
		      If Adir(laDummy, m.lcFile) > 0
		        lnClasses = Avcxclasses(laClasses, M.lcFile)
		        For lnI = 1 To M.lnClasses
		          Insert Into curClassLib (Class, Classlib);
		            Values (m.laClasses[m.lni, 1], Lower(M.lcFile))
		        Endfor
		      Endif
		    Catch
		    Endtry
		  Endfor
		  Select Distinct Class, Classlib From curClassLib Order By 2, 1 Into Cursor curClassLib Readwrite
		  If _Tally > 0
		    AddProperty(_vfp, [noClasses(] + Transform(_Tally) + [,2)], .F.)
		    AddProperty(_vfp, [noLenClasses], _Tally)
		    lnReturn = _Tally
		    lnX = 1
		    Scan
		      Store this.ShowCase(Trim(curClassLib.Class)) To ([_vfp.noClasses(] + Transform(m.lnX) + [,1)])
		      Store this.ShowCase(curClassLib.Classlib) To ([_vfp.noClasses(] + Transform(m.lnX) + [,2)])
		      lnX = m.lnX + 1
		    Endscan
		  Endif
		Else
		  loTools = Execscript (_Screen.cThorDispatcher, [class= tools from pemeditor])
		  lx = m.loTools.GetClasslist(, , .T., .F., .T., .F.)
		  If Alen(m.lx.List) > 1
		    AddProperty(_vfp, [noClasses(] + Transform(Alen(m.lx.List, 1)) + [,2)], .F.)
		    AddProperty(_vfp, [noLenClasses], Alen(m.lx.List, 1))
		    For lnX = 1 To Alen(m.lx.List, 1)
		      Store this.ShowCase(m.lx.List(m.lnX, 1)) To ([_vfp.noClasses(] + Transform(m.lnX) + [,1)])
		      Store this.ShowCase(Justfname(m.lx.List(m.lnX, 2))) To ([_vfp.noClasses(] + Transform(m.lnX) + [,2)])
		    Endfor
		    lnReturn = Alen(m.lx.List, 1)
		  Endif Alen(m.lx.List) > 1
		Endif
		
		Return m.lnReturn
		
		
	ENDPROC

	PROCEDURE readregistryoption
		Lparameters tcOption
		Local lcReturn
		
		tcOption = Evl(m.tcOption, [EditorCommentString])
		lcReturn = Execscript(_Screen.cThorDispatcher, [Thor_Proc_GetRegistryOption.prg], m.tcOption )
		Return m.lcReturn
	ENDPROC

	PROCEDURE readsettings
		This.nMaxDescriptLine = _Screen.oSKOptions.nMaxDescriptLine
		This.nZipDelay = _Screen.oSKOptions.nZipDelay
		This.nTimeOut = _Screen.oSKOptions.nWaittimeout * 1000
		This.nNextLength = _Screen.oSKOptions.nNextLength
		This.cBackupFolder = _Screen.oSKOptions.cBackupFolder
		This.cUnzipFolder = _Screen.oSKOptions.cUnzipFolder
		This.cZipTarget = _Screen.oSKOptions.cZipTarget
		This.cSidekickDef = [Sidekick.txt] && TBFixxxx
		This.cRun = _Screen.oSKOptions.cRunCommand
		This.cSidekickHelp = Addbs(_Screen.oSKOptions.cHelpURL)
		This.cMRUTable = ForceExt(_Screen.oSKOptions.cMRUTable,'dbf')
		This.cDefaultCommand = _Screen.oSKOptions.cDefaultCommand
		If _Screen.oSKOptions.nFontSize < 6
		  This.nFontSize = _Screen.FontSize
		Else
		  This.nFontSize = _Screen.oSKOptions.nFontSize
		Endif
		If _Screen.oSKOptions.lGridAuto
		  This.AddOption([b])
		Endif
		If _Screen.oSKOptions.lnewfirst
		  This.AddOption([n])
		Endif
		Do Case
		  Case _Screen.oSKOptions.nDisplayCase = 1
		    This.cDisplayCase = [lower]
		  Case _Screen.oSKOptions.nDisplayCase = 2
		    This.cDisplayCase = [proper]
		  Otherwise
		    This.cDisplayCase = [Upper]
		Endcase
		Do Case
		  Case _Screen.oSKOptions.npathreturned = 1 && Relative Path
		    This.cPathReturned = [r]
		  Case _Screen.oSKOptions.npathreturned = 2 && FullPath
		    This.cPathReturned = [f]
		  Otherwise
		    This.cPathReturned = [] && No path
		Endcase
		this.cSKFile = 'sk_'
		If not File(this.cMRUTable)
		  Select 0
		  If Directory('data')
		    lcFolder = 'data'
		  Else 
		    m.lcFolder = ''
		  Endif
		  Create Table (ForcePath(this.cMRUTable,m.lcFolder))  (fullname char(240), module char(100), Method char(40), lineno integer, Descript char(40), datetime  datetime, Active L, external L)
		  Select (this.nSelect)
		Endif
		
	ENDPROC

	PROCEDURE removedoublecharacter
		Lparameters tcText, tcCharacter
		If Pcount() < 2
		  m.tcCharacter = Space(1)
		Endif
		lcString = Replicate(m.tcCharacter,2)
		Do while m.lcString$m.tcText
		  m.tcText = Strtran(m.tcText,m.lcString, m.tcCharacter)
		Enddo
		Return m.tcText
		
		
	ENDPROC

	PROCEDURE removeprocendproc
		Lparameters tcCode
		#Define crlf Chr(13)+Chr(10)
		Local lcLine, lcReturn, lcWord, lnLines, lnSelect, lnX
		
		Local Array laCode[1]
		
		lnSelect = Select()
		lnLines = Alines(laCode, m.tcCode)
		Select 0
		Create Cursor curCode (cCode c(254))
		For lnX = 1 To m.lnLines
		  lcLine = m.laCode(m.lnX)
		  lcWord = Lower(Getwordnum(m.lcLine, 1))
		  Do Case
		    Case Empty(m.lcLine)
		      Loop
		    Case Left(m.lcWord, 4) = [func]
		      Loop
		    Case Left(m.lcWord, 4) = [proc]
		      Loop
		    Case Left(m.lcWord, 4) = [endp]
		      Exit
		    Case Left(m.lcWord, 5) = [endfu]
		      Exit
		    Otherwise
		      Insert Into curCode (cCode) Values (m.lcLine)
		  Endcase
		Endfor
		lcReturn = []
		Scan
		  lcReturn = m.lcReturn + cCode + crlf
		Endscan
		Select (m.lnSelect)
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE replacecurrentline
		Lparameters tcText
		This.CutCurrentLine()
		This.WriteCurrentLine(m.tcText)
		
	ENDPROC

	PROCEDURE restoreselection
		This.oEditor.Select(This.nSelStart, This.nSelEnd)
	ENDPROC

	PROCEDURE returnunknowncommand
		Lparameters tnText
		Local lcText
		#Define ccUnknownCommand 'Illegal command'
		
		_Cliptext = _Screen.cClip
		Do Case
		  Case Empty(m.tnText)
		    lcText = ccUnknownCommand + [!]
		  Case m.tnText = 1
		    lcText = ccUnknownCommand + [ in this window!]
		EndCase
		this.GiveMessage(ccUnknownCommand,,Transform(m.tnText), this.nTimeOut)
		
		
		
	ENDPROC

	PROCEDURE runed
		Lparameters tcPar
		Local lcCommand, lcExt, lcFile, lcFolder, lcMethod, lcObject, lcParOrg, lcParam1, lcParameters
		Local llRun, lnLine, lnLineNo, loTools
		#Define ccPipe "|"
		#Define ccAmp  [&] + [&]
		#Define ccUnknownCommand 'Illegal command'
		lcParOrg = m.tcPar
		If Getwordnum(m.tcPar, 1) == This.cRun
		  llRun = .T.
		  tcPar = Substr(m.tcPar, Len(This.cRun) + 2 )
		Endif
		If Occurs(["], m.tcPar) > 0 And Occurs(["], m.tcPar) % 2 = 0
		  tcPar = Chrtran(m.tcPar, ["], ['])
		Endif
		lcParam1 = m.tcPar
		If Empty(m.tcPar) Or (Val(m.tcPar) > 0 And m.tcPar = Transform(Val(m.tcPar)))
		  lnLine = Val(m.tcPar)
		  lnLine = Evl(m.lnLine, 1)
		  If File(This.cSidekickFile )
		    lcParam1 = This.GetNumberedline(This.cSidekickFile , m.lnLine )
		  Else
		    Return
		  Endif
		Endif
		If m.lcParam1 = [0]
		  lcParam1 = This.cSidekickFile 
		Endif
		lcParam1 = Chrtran(m.lcParam1, ccPipe, [])
		lcParam1 = Alltrim(m.lcParam1, 0, [!], Chr(13))
		If ccAmp $ m.lcParam1
		  lcParam1 = Left(m.lcParam1, At(ccAmp, m.lcParam1) - 1)
		Endif
		If [(] $ m.lcParam1 And ! Inlist(Getwordnum(m.lcParam1, 1), This.cRun, [do])
		  lcParam1 = Evaluate(m.lcParam1)
		  If Vartype(m.lcParam1) = [L] && Function was called
		    Return
		  Endif
		Endif
		lcFolder = [classes\]
		lnLineNo = Int(Val(Strextract(m.lcParam1, [:], [], Occurs([:], m.lcParam1))))
		If m.llRun And (Empty(Justext(m.lcParam1)) or [.vcx']$m.lcParam1) 
		  Try
		    Execscript(m.lcParam1)
		  Catch
		    llRun = .F.
		  Endtry
		Endif
		If m.llRun
		  Return
		EndIf
		
		Do Case
		  Case Empty(Justext(m.lcParam1)) And Right(m.lcParam1, 1) # [)] And !Inlist(Lower(Left(m.lcParam1, 4)), [http], [mail])
		    lcExt = [prg]
		    lcParam1 = Forceext(m.lcParam1, m.lcExt)
		  Case [.scx] $ Lower(m.lcParam1)
		    lcExt = [scx]
		  Case [.vcx] $ Lower(m.lcParam1)
		    lcExt = [vcx]
		  Case [.prg] $ Lower(m.lcParam1)
		    lcExt = [prg]
		  Case Occurs([.], m.lcParam1) = 1
		    lcExt = Justext(m.lcParam1)
		  Case [.txt] $ Lower(m.lcParam1)
		    lcExt = [txt]
		  Case [.sk] $ Lower(m.lcParam1)
		    lcExt = [sk]
		  Otherwise
		    lcExt = []
		Endcase
		lcFile = Strextract(m.lcParam1, [], m.lcExt, 1, 1 + 4)
		lcFile = Chrtran(m.lcFile, ['], [])
		Do Case
		  Case Getwordnum(m.tcPar, 1) == [do]
		    This.TryExecute(m.tcPar)
		  Case Inlist(Lower(Strextract(m.lcParam1, [], [:], 1, 4)), [http:], [https:])
		    this.ShellX(m.lcParam1)
		  Case m.lcExt = [sk]
		    Modify Command (m.tcPar) Nowait
		  Case m.lcExt = [vcx] Or m.lcExt = [scx]
		    lcParam1 = Lower(m.lcParam1)
		    If [:] $ m.lcParam1
		      lcParameters = Strextract(m.lcParam1, m.lcExt + [.], [:])
		    Else
		      lcParameters = Strextract(m.lcParam1, m.lcExt + [.])
		    Endif
		    lcObject = Getwordnum(m.lcParameters, 1, [.])
		    lcMethod = Substr(m.lcParameters, Len(m.lcObject) + 2)
		    loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		    m.loTools.EditSourceX(m.lcFile, m.lcObject, m.lcMethod, m.lnLineNo)
		  Case Getwordnum(m.lcParam1, 1) = This.cRun
		    lcCommand = Ltrim(Strextract(m.lcParam1, This.cRun, []))
		    Try
		      Execscript(m.lcCommand)
		    Catch
		      Try
		        Do (m.lcCommand)
		      Catch
		        Try
		          Execscript(Juststem(m.lcCommand))
		        Catch
		          This.GiveMessage(ccUnknownCommand, , m.lcCommand)
		        Endtry
		      Endtry
		    Endtry
		  Case m.lcExt = [prg]
		    If m.lnLineNo > 0
		      If Occurs([:], m.lcParam1) > 1 And At([:], m.lcParam1, 2) > 2
		        lcParam1 = Left(m.lcParam1, At([:], m.lcParam1, Occurs([:], m.lcParam1)) - 1)
		      Endif
		      Editsource(m.lcFile, m.lnLineNo)
		    Else
		      If Lower(Getwordnum(m.lcParam1, 1)) = [ed]
		        lcParam1 = Substr(m.lcParam1, 3)
		      Endif
		      loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		      m.loTools.EditSourceX(m.lcParam1 )
		    Endif
		  Otherwise
		    loTools = Execscript (_Screen.cThorDispatcher, [Class= tools from pemeditor])
		    m.loTools.EditSourceX(m.lcParam1 )
		Endcase
		
		
	ENDPROC

	PROCEDURE runprogram
		Lparameters tcFile
		Local lcCommand, lcExt
		
		lcExt = Lower(Justext(m.tcFile))
		Do Case
		  Case m.lcExt = [prg]
		    lcCommand = Textmerge([do <<m.tcFile>>])
		  Case m.lcExt = [scx]
		    lcCommand = Textmerge([do form <<m.tcFile>>])
		Endcase
		Try
		  Execscript(m.lcCommand)
		Catch
		  this.GiveMessage([Can not run file!], 48, m.tcFile)
		Endtry
		
		
	ENDPROC

	PROCEDURE runsidekickline
		Lparameters tcCommand
		Do Case
		  Case Getwordnum(m.tcCommand, 1) = [do]
		    Execscript(m.tcCommand)
		  Case Getwordnum(m.tcCommand, 1) = this.cRun 
		    tcCommand = Strextract(m.tcCommand, this.cRun , [])
		    Execscript(m.tcCommand)
		  Otherwise
		    Try 
		      ExecScript(m.tcCommand)
		    Catch 
		      This.RunEd(m.tcCommand )
		    Endtry
		Endcase
		
	ENDPROC

	PROCEDURE scanallwindows
		Lparameters toWindows, tnCallerHandler, tnPrefix, tnEdType
		Local lcCode, lcPrefix, lcReturn, lnHandle, loWindow
		
		If _Screen.lTest
		  Set Step On
		Endif
		
		#Define crlf Chr(13)+Chr(10)
		Do Case
		  Case Empty(m.tnPrefix )
		    lcPrefix = []
		  Case m.tnPrefix = -1
		    lcPrefix = [] && [0 ]
		  Otherwise
		    lcPrefix = Transform(m.tnPrefix) + [ ]
		Endcase
		lcReturn = []
		For Each m.loWindow In m.toWindows FoxObj
		  lnHandle = m.loWindow.nWHAndle
		  If m.lnHandle = m.tnCallerHandler
		    Loop
		  Endif
		  lcCode = This.GetEditSourceCode(m.lnHandle, m.tnEdType, m.lcPrefix)
		  If !Empty(m.lcCode)
		    If Empty(m.lcReturn )
		      lcReturn = m.lcCode
		    Else
		      lcReturn = m.lcReturn + crlf + m.lcCode
		    Endif
		  Endif
		Endfor
		Return m.lcReturn
		
		
	ENDPROC

	PROCEDURE setstepon
		If 'z' $ this.cOption 
		  Set step on
		Endif
	ENDPROC

	PROCEDURE setupgrid
		this.oGrid = CreateObject('pg')
		this.oGrid.Visible = .t.
		
	ENDPROC

	PROCEDURE setupregistry
		this.oRegistry = CreateObject('vfpxregistry')
	ENDPROC

	PROCEDURE shellx
		Lparameters tcURL, tcCommand, tcParameter
		tcCommand = Evl(m.tcCommand, [open])
		tcParameter = Evl(m.tcParameter, [])
		#Define SW_HIDE 0
		#Define SW_SHOWNORMAL 1
		#Define SW_SHOWMINIMIZED 2
		#Define SW_SHOWMAXIMIZED 3
		*!*   Legal verbs: open, edit, print, find, explore, NULL
		Declare Integer ShellExecute In shell32.Dll ;
		  Integer hndWin, String cAction, String cFileName, ;
		  String cParams, String cDir, Integer nShowWin
		ShellExecute( 0, m.tcCommand, m.tcURL, m.tcParameter, [], SW_SHOWNORMAL )
	ENDPROC

	PROCEDURE showcase
		Lparameters tcText
		If !Inlist(Lower(This.cdisplaycase), [upper], [lower], [proper])
		  this.cDisplayCase = 'lower'
		Endif
		Return Evaluate(Textmerge([Trim(<<this.cDisplayCase>>(m.tcText))]))
		
		
	ENDPROC

	PROCEDURE showcurrentpath
		Local lcFolder, lcPath, lnElements, lnFiles, lnI, lnSize, lnX
		
		Local Array laDummy[1]
		Local Array laFiles[1]
		
		lcPath = Set([Path])
		Create Cursor (This.cCursor) (Type c(10),Folder c(200), Files i, Size i)
		lcRoot = Addbs(Fullpath(Set([Default]))) + [*.*]
		
		lnFiles = Adir(laFiles, m.lcRoot )
		lnSize = 0
		If m.lnFiles > 0
		  For lnI = 1 To m.lnFiles
		    lnSize = m.lnSize + m.laFiles(m.lnI, 2)
		  Endfor
		Endif
		Insert Into (This.cCursor) (Type, Folder, Files, Size) Values ('Default', JustPath(m.lcRoot) , m.lnFiles, m.lnSize  )
		
		lnElements = Alines(laDummy, m.lcPath, 1 + 4, [;], [,])
		If m.lnElements > 0
		  For lnX = 1 To m.lnElements
		    lcFolder = m.laDummy(m.lnX)
		    lnFiles = Adir(laFiles, Addbs(m.lcFolder) + [*.*])
		    lnSize = 0
		    For lnI = 1 To m.lnFiles
		      lnSize = m.lnSize + m.laFiles(m.lnI, 2)
		    Endfor
		    
		    If ! ':' $ m.lcFolder 
		      m.lcFolder = '..\' + m.lcFolder 
		    Endif
		    Insert Into (This.cCursor) (Type, Folder, Files, Size) Values ('', m.lcFolder, m.lnFiles, m.lnSize  )
		
		  Endfor
		Endif
		Select * From (This.cCursor) Into Cursor (This.cCursor) Order By type, Folder
		This.GetDataFromGrid([Current path],,,,'N')
	ENDPROC

	PROCEDURE tryexecscript
		Try 
		  ExecScript(this.cClip)
		Catch 
		  this.GiveMessage([Can't execute the clipboard], 48, [], 3000)
		Endtry
		
	ENDPROC

	PROCEDURE tryexecute
		Lparameters tcCommand
		Local llOK
		
		#Define ccUnknownCommand 'Illegal command'
		tcCommand = Evl(m.tcCommand, This.cParameter )
		Try
		  Execscript(m.tcCommand )
		  llOK = .T.
		Catch
		  This.GiveMessage(ccUnknownCommand, , m.tcCommand)
		Endtry
		Return m.llOK
		
		
	ENDPROC

	PROCEDURE writecurrentline
		Lparameters tcText
		Local lcClip
		If Vartype(m.tcText) # [C] or this.nWindowType < 0
		  Return
		Endif
		
		this.oEditorWin.Insert(m.tcText)
		
		
		
	ENDPROC

	PROCEDURE ZOrder
		LPARAMETERS nOrder
	ENDPROC

ENDDEFINE

DEFINE CLASS vfpxregistry AS custom 		&& A class that works with the Windows Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "vfpx\vfpxregistry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Close the current registry key
		*m: deletekey		&& Delete the specified key
		*m: deletekeyvalue		&& Deletes a value under a key
		*m: enumeratekeys		&& Enumerate key names from the specfied key
		*m: enumeratekeyvalues		&& Enumerate values under the specified key
		*m: getkey		&& Gets the value for the specified key
		*m: iskey		&& Returns .T. if the specified key exists
		*m: iskeyvalue		&& Returns .T. if the specified key value exists
		*m: moveregistrykeys		&& Moves all keys and values from one location to another
		*m: openkey		&& Opens the specified key
		*m: setkey		&& Sets the specified key to the specified value
		*p: ncurrentkey		&& The current open key
		*p: nmainkey		&& The main key for the Registry
		*p: nresult		&& The result code of the most recent method call
	*</DefinedPropArrayMethod>

	PROTECTED ncurrentkey
	*<PropValue>
		Name = "vfpxregistry"
		ncurrentkey = 0
		nmainkey = 0
		nresult = 0
		Width = 17
	*</PropValue>
	
	PROTECTED PROCEDURE closekey		&& Close the current registry key
		* Close the current key and blank the current key value.
		
		with This
			RegCloseKey(.nCurrentKey)
			.nCurrentKey = 0 
		endwith
		
	ENDPROC

	PROCEDURE deletekey		&& Delete the specified key
		* Delete the specified key and all subkeys and values under it.
		
		lparameters tcSubKey, ;
			tnMainKey
		local laKeys[1], ;
			lnKeys, ;
			llReturn, ;
			lnI, ;
			lcKey, ;
			lnMainKey, ;
			lcSubKey
		with This
		
		* Call ourselves recursively to delete all subkeys first.
		
			lnKeys   = .EnumerateKeys(tcSubKey, @laKeys, tnMainKey)
			llReturn = .T.
			for lnI = 1 to lnKeys
				lcKey    = addbs(tcSubKey) + laKeys[lnI]
				llReturn = .DeleteKey(lcKey, tnMainKey)
				if not llReturn
					exit
				endif not llReturn
			next lnI
			if llReturn
		
		* If the main key wasn't passed, use the default value.
		
				lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, ;
					.nMainKey, tnMainKey)
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
				lcSubKey = iif(right(tcSubKey, 1) = '\', ;
					left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteKey(lnMainKey, lcSubKey)
				llReturn = .nResult = cnSUCCESS
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes a value under a key
		* Delete the specified value in the specified key.
		
		lparameters tcSubKey, ;
			tcValue, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Delete the key and return .T. if it succeeded.
		
				.nResult = RegDeleteValue(.nCurrentKey, tcValue)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the value.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE enumeratekeys		&& Enumerate key names from the specfied key
		lparameters tcSubKey, ;
			taKeyNames, ;
			tnMainKey
		local lnMainKey, ;
			lnNames, ;
			lcKey, ;
			lnSize, ;
			lcBuffer1, ;
			lnSize1, ;
			lcBuffer2
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnNames  = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnSize    = cnBUFFER_SIZE
					lcBuffer1 = space(cnBUFFER_SIZE)
					lnSize1   = cnBUFFER_SIZE
					lcBuffer2 = space(cnBUFFER_SIZE)
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, @lnSize, ;
						cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey   = alltrim(lcKey)
							lcKey   = left(lcKey, len(lcKey) - 1)
							lnNames = lnNames + 1
							dimension taKeyNames[lnNames]
							taKeyNames[lnNames] = lcKey
		
		* If we had an error and it's not EOF, return an error code.
		
						case .nResult <> cnERROR_EOF
							lnNames = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnNames = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnNames
		
	ENDPROC

	PROCEDURE enumeratekeyvalues		&& Enumerate values under the specified key
		lparameters tcSubKey, ;
			taKeyValues, ;
			tnMainKey
		local lnMainKey, ;
			lnValues, ;
			lcKey, ;
			lnKeySize, ;
			lcValue, ;
			lnValSize, ;
			lnType, ;
			lcBuffer, ;
			lnSize
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key.
		
			if .OpenKey(tcSubKey, lnMainKey)
		
		* Initialize the number of names and the result code.
		
				lnValues = 0
				.nResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
				do while .nResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
					lcKey     = space(cnBUFFER_SIZE)
					lnKeySize = cnBUFFER_SIZE
					lcValue   = space(cnBUFFER_SIZE)
					lnValSize = cnBUFFER_SIZE
					lnType    = 0
		
		* Get the next key name from the Registry.
		
					.nResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
						@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)
					do case
		
		* If we got a name, add it to the array.
		
						case .nResult = cnSUCCESS
							lcKey    = left(lcKey, lnKeySize)
							lnValues = lnValues + 1
							dimension taKeyValues[lnValues, 2]
							taKeyValues[lnValues, 1] = lcKey
							do case
								case lnType = cnREG_SZ
									taKeyValues[lnValues, 2] = left(lcValue, ;
										lnValSize - 1)
								case lnType = cnREG_DWORD
									taKeyValues[lnValues, 2] = ctobin(left(lcValue, 4), ;
										'4RS')
								case lnType = cnREG_EXPAND_SZ
									lcValue  = left(lcValue, lnValSize - 1)
									lcBuffer = space(cnBUFFER_SIZE)
									lnSize   = cnBUFFER_SIZE
									lnSize   = ExpandEnvironmentStrings(@lcValue, ;
										@lcBuffer, lnSize)
									taKeyValues[lnValues, 2] = left(lcBuffer, ;
										lnSize - 1)
								case lnType = cnREG_BINARY
									taKeyValues[lnValues, 2] = left(lcValue, lnValSize)
								case lnType = cnREG_MULTI_SZ
									taKeyValues[lnValues, 2] = strtran(left(lcValue, ;
										lnValSize - 1), ccNULL, ccCR)
										&& use ALINES() on the return value to get the individual
										&& values
							endcase
		
		* If we had an error and it's not EOF, return 0 entries.
		
						case .nResult <> cnERROR_EOF
							lnValues = 0
					endcase
				enddo while .nResult = cnSUCCESS
		
		* Close the registry key.
		
				.CloseKey()
		
		* We couldn't open the key, so return 0 entries.
		
			else
				lnValues = 0
			endif .OpenKey(tcSubKey, lnMainKey)
		endwith
		return lnValues
		
	ENDPROC

	PROCEDURE getkey		&& Gets the value for the specified key
		lparameters tcSubKey, ;
			tcValueName, ;
			tuDefault, ;
			tnMainKey, ;
			tl64Bit
		local lnMainKey, ;
			luValue, ;
			lcValueName, ;
			lcBuffer, ;
			lnSize, ;
			lnType, ;
			lnFlags
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the default to use wasn't passed, initialize it to an empty string.
		
			luValue = iif(vartype(tuDefault) = 'C', tuDefault, '')
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Create a buffer to hold the key value.
		
			lcBuffer = space(cnBUFFER_SIZE)
			lnSize   = cnBUFFER_SIZE
			lnType   = 0
		
		* If we're supposed to get a 64-bit value, do so.
		
			do case
				case tl64Bit
					lnFlags  = cnRRF_RT_ANY + cnRRF_SUBKEY_WOW6464KEY
					.nResult = RegGetValue(.nCurrentKey, tcSubKey, lcValueName, ;
						lnFlags, @lnType, @lcBuffer, @lnSize)
		
		* Get a 32-bit value.
		
				case .OpenKey(tcSubKey, lnMainKey)
					.nResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						@lnType, @lcBuffer, @lnSize)
					.CloseKey()
			endcase
		
		* Get the key value and convert it into the proper return value based on the
		* data type.
		
			do case
				case .nResult <> cnSUCCESS
				case lnType = cnREG_SZ
					luValue = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_EXPAND_SZ
					luValue  = left(lcBuffer, lnSize - 1)
					lcBuffer = space(cnBUFFER_SIZE)
					lnSize   = cnBUFFER_SIZE
					lnSize   = ExpandEnvironmentStrings(@luValue, @lcBuffer, ;
						lnSize)
					luValue  = left(lcBuffer, lnSize - 1)
				case lnType = cnREG_DWORD
					luValue = ctobin(left(lcBuffer, 4), '4RS')
				case lnType = cnREG_BINARY
					luValue = left(lcBuffer, lnSize)
				case lnType = cnREG_MULTI_SZ
					luValue = strtran(left(lcBuffer, lnSize - 1), ccNULL, ccCR)
						&& use ALINES() on the return value to get the individual
						&& values
			endcase
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE Init
		lparameters tnMainKey
		
		* Declare the API functions we'll need.
		
		declare integer RegOpenKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegCreateKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegDeleteKey in Win32API ;
			integer nKey, string @cSubKey
		declare integer RegCloseKey in Win32API ;
			integer nKey
		declare integer RegSetValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer nType, string cBuffer, integer nBufferSize
		declare integer RegQueryValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer @nType, string @cBuffer, integer @nBufferSize
		declare integer RegDeleteValue in Win32API ;
			integer nKey, string cSubKey
		declare integer RegEnumKey in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize
		declare integer RegEnumKeyEx in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
			integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
		declare integer RegEnumValue IN Win32API ;
			integer nKey, integer nValue, string @cSubKey, ;
			integer @nKeySize, integer nReserved, integer @nType, ;
			string @cValue, integer @nValSize
		declare integer ExpandEnvironmentStrings IN Win32API ;
			string @lpSrc, string @lpDst, integer nSize
		declare integer RegGetValue IN Win32API ;
			integer hkey, string lpSubKey, string lpValue, integer dwFlags, ;
			integer @pdwType, string @pvData, integer @pcbData
		
		* Initialize the main key.
		
		This.nMainKey = iif(vartype(tnMainKey) = 'N', tnMainKey, cnHKEY_CURRENT_USER)
		
		* Carry on with the base behavior.
		
		dodefault()
		
	ENDPROC

	PROCEDURE iskey		&& Returns .T. if the specified key exists
		lparameters tcSubKey, ;
			tnMainKey
		local lnMainKey, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* Try to open the registry key. If we could, the key exists, so close it.
		
			llReturn = .OpenKey(tcSubKey, lnMainKey)
			if llReturn
				.CloseKey()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE iskeyvalue		&& Returns .T. if the specified key value exists
		lparameters tcSubKey, ;
			tcValueName, ;
			tnMainKey
		This.GetKey(tcSubKey, tcValueName, , tnMainKey)
		return This.nResult = cnSUCCESS
		
	ENDPROC

	PROCEDURE moveregistrykeys		&& Moves all keys and values from one location to another
		lparameters tcOldKey, ;
			tcNewKey, ;
			tlNoDelete
		local laKeys[1], ;
			lnKeys, ;
			lnI, ;
			lcKey, ;
			lcOldKey, ;
			lcNewKey, ;
			laValues[1], ;
			lnValues
		with This
		
		* Get all subkeys and call ourselves recursively to get all subkeys of those
		* and copy them to the new location (and possibly remove them from the old
		* location).
		
			lnKeys = .EnumerateKeys(tcOldKey, @laKeys)
			for lnI = 1 to lnKeys
				lcKey    = laKeys[lnI]
				lcOldKey = addbs(tcOldKey) + lcKey
				lcNewKey = addbs(tcNewKey) + lcKey
				.MoveRegistryKeys(lcOldKey, lcNewKey, tlNoDelete)
			next lnI
		
		* Get all values copy them to the new location (and possibly remove them from
		* the old location).
		
			lnValues = .EnumerateKeyValues(tcOldKey, @laValues)
			for lnI = 1 to lnValues
				.SetKey(tcNewKey, laValues[lnI, 1], laValues[lnI, 2])
			next lnI
			if not tlNoDelete
				.DeleteKey(tcOldKey)
			endif not tlNoDelete
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE openkey		&& Opens the specified key
		lparameters tcSubKey, ;
			tnMainKey, ;
			tlCreate
		local lnHandle, ;
			lcSubKey, ;
			llReturn
		
		* Try to create or open the registry key. If it succeeded, store the key handle
		* in the nCurrentKey property; if not, zero nCurrentKey.
		
		with This
			lnHandle = 0
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
			lcSubKey = iif(right(tcSubKey, 1) = '\', ;
				left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
			if tlCreate
				.nResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
			else
				.nResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
			endif tlCreate
			llReturn     = .nResult = cnSUCCESS
			.nCurrentKey = iif(llReturn, lnHandle, 0)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setkey		&& Sets the specified key to the specified value
		lparameters tcSubKey, ;
			tcValueName, ;
			tuValue, ;
			tnMainKey, ;
			tnType
		local lnMainKey, ;
			lcDataType, ;
			lcValue, ;
			lnSize, ;
			lcValueName, ;
			llReturn
		with This
		
		* If the main key wasn't passed, use the default value.
		
			lnMainKey = iif(vartype(tnMainKey) <> 'N' or tnMainKey = 0, .nMainKey, ;
				tnMainKey)
		
		* If the type wasn't specified, initialize it to cnREG_SZ.
		
			lnType = iif(vartype(tnType) = 'N', tnType, cnREG_SZ)
		
		* Convert the value to a string if necessary. Terminate the string with a null
		* and calculate the size.
		
			lcDataType = vartype(tuValue)
			do case
				case lnType = cnREG_MULTI_SZ
					lcValue = strtran(tuValue, ccCR, ccNULL)
				case lcDataType = 'C'
					lcValue = tuValue
				case lcDataType $ 'NIFYB' and lnType = cnREG_DWORD
					lcValue = bintoc(tuValue, '4RS')
				case lcDataType $ 'NIFYB'
					lcValue = transform(tuValue)
				case lcDataType = 'D'
					lcValue = dtoc(tuValue)
				case lcDataType = 'T'
					lcValue = ttoc(tuValue)
				case lcDataType = 'L'
					lcValue = iif(tuValue, 'Y', 'N')
			endcase
			if inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
				lcValue = lcValue + ccNULL
			endif inlist(lnType, cnREG_SZ, cnREG_EXPAND_SZ)
			lnSize = len(lcValue)
		
		* If the value name wasn't specified, initialize it to an empty string, meaning
		* the default value.
		
			lcValueName = iif(vartype(tcValueName) = 'C', tcValueName, '')
		
		* Try to open or create the registry key. If we couldn't, return .F.
		
			if .OpenKey(tcSubKey, lnMainKey, .T.)
		
		* Set the key value.
		
				.nResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
					lnType, lcValue, lnSize)
				llReturn = .nResult = cnSUCCESS
		
		* Close the registry key and return the success flag.
		
				.CloseKey()
			endif .OpenKey(tcSubKey, lnMainKey, .T.)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
